<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>G加菲</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.gmlyo.com/"/>
  <updated>2019-07-18T05:48:48.820Z</updated>
  <id>http://www.gmlyo.com/</id>
  
  <author>
    <name>G加菲</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python如何将字符串转为字典</title>
    <link href="http://www.gmlyo.com/2019/07/18/Python%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E5%AD%97%E5%85%B8/"/>
    <id>http://www.gmlyo.com/2019/07/18/Python如何将字符串转为字典/</id>
    <published>2019-07-18T05:48:22.000Z</published>
    <updated>2019-07-18T05:48:48.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python如何将字符串转为字典"><a href="#Python如何将字符串转为字典" class="headerlink" title="Python如何将字符串转为字典"></a>Python如何将字符串转为字典</h1><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在工作中遇到一个小问题，需要将一个<code>python</code>的字符串转为字典，比如字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_info = <span class="string">'&#123;"name" : "john", "gender" : "male", "age": 28&#125;'</span></span><br></pre></td></tr></table></figure><p>我们想把它转为下面的字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user_dict = &#123;<span class="string">"name"</span> : <span class="string">"john"</span>, <span class="string">"gender"</span> : <span class="string">"male"</span>, <span class="string">"age"</span>: <span class="number">28</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>有以下几种方法</strong></p><h2 id="通过json来转换"><a href="#通过json来转换" class="headerlink" title="通过json来转换"></a>通过json来转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_info= <span class="string">'&#123;"name" : "john", "gender" : "male", "age": 28&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict = json.loads(user_info)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict</span><br><span class="line">&#123;<span class="string">u'gender'</span>: <span class="string">u'male'</span>, <span class="string">u'age'</span>: <span class="number">28</span>, <span class="string">u'name'</span>: <span class="string">u'john'</span>&#125;</span><br></pre></td></tr></table></figure><p>但是使用<code>json</code>进行转换存在一个潜在的问题。</p><p>由于<code>json</code>语法规定<strong>数组或对象之中的字符串必须使用双引号，不能使用单引号</strong>（<a href="http://json.org/" target="_blank" rel="noopener">官网</a>上有一段描述是 “A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes”），因此下面的转换是错误的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_info = <span class="string">"&#123;'name' : 'john', 'gender' : 'male', 'age': 28&#125;"</span></span><br><span class="line"><span class="comment"># 由于字符串使用单引号，会导致运行出错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict = json.loads(user_info)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/__init__.py"</span>, line <span class="number">339</span>, <span class="keyword">in</span> loads</span><br><span class="line">    <span class="keyword">return</span> _default_decoder.decode(s)</span><br><span class="line">  File <span class="string">"/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/decoder.py"</span>, line <span class="number">364</span>, <span class="keyword">in</span> decode</span><br><span class="line">    obj, end = self.raw_decode(s, idx=_w(s, <span class="number">0</span>).end())</span><br><span class="line">  File <span class="string">"/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/decoder.py"</span>, line <span class="number">380</span>, <span class="keyword">in</span> raw_decode</span><br><span class="line">    obj, end = self.scan_once(s, idx)</span><br><span class="line">ValueError: Expecting property name: line <span class="number">1</span> column <span class="number">2</span> (char <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="通过eval"><a href="#通过eval" class="headerlink" title="通过eval"></a>通过eval</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_info = <span class="string">'&#123;"name" : "john", "gender" : "male", "age": 28&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict = eval(user_info)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict</span><br><span class="line">&#123;<span class="string">'gender'</span>: <span class="string">'male'</span>, <span class="string">'age'</span>: <span class="number">28</span>, <span class="string">'name'</span>: <span class="string">'john'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_info = <span class="string">"&#123;'name' : 'john', 'gender' : 'male', 'age': 28&#125;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict = eval(user_info)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict</span><br><span class="line">&#123;<span class="string">'gender'</span>: <span class="string">'male'</span>, <span class="string">'age'</span>: <span class="number">28</span>, <span class="string">'name'</span>: <span class="string">'john'</span>&#125;</span><br></pre></td></tr></table></figure><p>通过<code>eval</code>进行转换就不存在上面使用<code>json</code>进行转换的问题。但是，使用<code>eval</code>却存在<code>安全性的问题</code>，比如下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让用户输入 `user_info`</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_info = raw_input(<span class="string">'input user info: '</span>)</span><br><span class="line"><span class="comment"># 输入 &#123;"name" : "john", "gender" : "male", "age": 28&#125;，没问题</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict = eval(user_info)</span><br><span class="line"><span class="comment"># 输入 __import__('os').system('dir')，user_dict 会列出当前的目录文件！</span></span><br><span class="line"><span class="comment"># 再输入一些删除命令，则可以把整个目录清空了！</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict = eval(user_info)</span><br></pre></td></tr></table></figure><h2 id="通过literal-eval"><a href="#通过literal-eval" class="headerlink" title="通过literal_eval"></a>通过literal_eval</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ast</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user = <span class="string">'&#123;"name" : "john", "gender" : "male", "age": 28&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict = ast.literal_eval(user)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict</span><br><span class="line">&#123;<span class="string">'gender'</span>: <span class="string">'male'</span>, <span class="string">'age'</span>: <span class="number">28</span>, <span class="string">'name'</span>: <span class="string">'john'</span>&#125;</span><br><span class="line">user_info = <span class="string">"&#123;'name' : 'john', 'gender' : 'male', 'age': 28&#125;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict = ast.literal_eval(user)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_dict</span><br><span class="line">&#123;<span class="string">'gender'</span>: <span class="string">'male'</span>, <span class="string">'age'</span>: <span class="number">28</span>, <span class="string">'name'</span>: <span class="string">'john'</span>&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>ast.literal_eval</code>进行转换既不存在使用<code>json</code>进行转换的问题，也不存在使用<code>eval</code>进行转换的<code>安全性问题</code>，因此推荐使用<code>ast.literal_eval</code>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/OnlyDreams/p/7850920.html" target="_blank" rel="noopener">https://www.cnblogs.com/OnlyDreams/p/7850920.html</a><br><a href="http://funhacks.net/2016/04/24/python_%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E5%AD%97%E5%85%B8/" target="_blank" rel="noopener">http://funhacks.net/2016/04/24/python_将字符串转为字典/</a><br><a href="http://javascript.ruanyifeng.com/stdlib/json.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/stdlib/json.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python如何将字符串转为字典&quot;&gt;&lt;a href=&quot;#Python如何将字符串转为字典&quot; class=&quot;headerlink&quot; title=&quot;Python如何将字符串转为字典&quot;&gt;&lt;/a&gt;Python如何将字符串转为字典&lt;/h1&gt;
    
    </summary>
    
      <category term="Python笔记" scheme="http://www.gmlyo.com/categories/Python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python如何将字符串转为字典" scheme="http://www.gmlyo.com/tags/Python%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>Markdown代码块中有反引号处理</title>
    <link href="http://www.gmlyo.com/2019/06/16/Markdown%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD%E6%9C%89%E5%8F%8D%E5%BC%95%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    <id>http://www.gmlyo.com/2019/06/16/Markdown代码块中有反引号处理/</id>
    <published>2019-06-15T18:36:38.000Z</published>
    <updated>2019-06-15T18:49:03.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown代码块中有反引号处理"><a href="#Markdown代码块中有反引号处理" class="headerlink" title="Markdown代码块中有反引号处理"></a>Markdown代码块中有反引号处理</h1><a id="more"></a><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">````html  <span class="comment">// 这里写4个反引号</span></span><br><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;点击时的区域标题&lt;/summary&gt;</span><br><span class="line">  ```bash</span><br><span class="line">  echo <span class="string">"hello shell"</span></span><br><span class="line">  echo <span class="string">"hello python"</span></span><br><span class="line">  ```</span><br><span class="line">&lt;/details&gt;</span><br><span class="line">````  <span class="comment">// 这里用4个反引号关闭</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.jianshu.com/p/d6ca2d4dfaab" target="_blank" rel="noopener">https://www.jianshu.com/p/d6ca2d4dfaab</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown代码块中有反引号处理&quot;&gt;&lt;a href=&quot;#Markdown代码块中有反引号处理&quot; class=&quot;headerlink&quot; title=&quot;Markdown代码块中有反引号处理&quot;&gt;&lt;/a&gt;Markdown代码块中有反引号处理&lt;/h1&gt;
    
    </summary>
    
      <category term="Markdown笔记" scheme="http://www.gmlyo.com/categories/Markdown%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Markdown代码块中有反引号处理" scheme="http://www.gmlyo.com/tags/Markdown%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD%E6%9C%89%E5%8F%8D%E5%BC%95%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Markdown代码折叠与收起</title>
    <link href="http://www.gmlyo.com/2019/06/16/Markdown%E4%BB%A3%E7%A0%81%E6%8A%98%E5%8F%A0%E4%B8%8E%E6%94%B6%E8%B5%B7/"/>
    <id>http://www.gmlyo.com/2019/06/16/Markdown代码折叠与收起/</id>
    <published>2019-06-15T17:35:31.000Z</published>
    <updated>2019-06-15T18:50:07.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown代码折叠与收起"><a href="#Markdown代码折叠与收起" class="headerlink" title="Markdown代码折叠与收起"></a>Markdown代码折叠与收起</h1><p>介绍：有的时候，代码太长，全部展开显得很臃肿，所以我们可以采用代码折叠的方式。</p><a id="more"></a><p>Markdown很方便，但基本语法有些不足：比如无法使用折叠语法，无法让文字有不同的颜色。<br>这些功能可以实现，不过需要使用 html 语法进行扩展。这篇文章主要是整理一下这些技巧，方便更好的使用。</p><h2 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h2><p>折叠语法：<code>&lt;details&gt;</code> 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>点击时的区域标题：点击查看详细内容<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> - 测试 测试测试<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>title，value，callBack可以缺省<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>details</code>：折叠语法标签<br><code>summary</code>：折叠语法展示的摘要<br><code>pre</code>：以原有格式显示元素内的文字是已经格式化的文本<br><code>code</code>：指定代码范例<br><code>blockcode</code>：表示程序的代码块</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>点击时的区域标题<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  ```bash</span><br><span class="line">  echo "hello shell"</span><br><span class="line">  echo "hello python"</span><br><span class="line">  ```</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><details><br>  <summary>点击时的区域标题：点击查看详细内容</summary><br>  <p> - 测试 测试测试</p><br>  <pre><code>title，value，callBack可以缺省</code></pre><br></details><details><br>  <summary>点击时的区域标题</summary><br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello shell"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello python"</span></span><br></pre></td></tr></table></figure><br><br></details><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://guoflight.github.io/posts/28189/" target="_blank" rel="noopener">https://guoflight.github.io/posts/28189/</a><br><a href="https://www.cnblogs.com/buwuliao/p/9578918.html" target="_blank" rel="noopener">https://www.cnblogs.com/buwuliao/p/9578918.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown代码折叠与收起&quot;&gt;&lt;a href=&quot;#Markdown代码折叠与收起&quot; class=&quot;headerlink&quot; title=&quot;Markdown代码折叠与收起&quot;&gt;&lt;/a&gt;Markdown代码折叠与收起&lt;/h1&gt;&lt;p&gt;介绍：有的时候，代码太长，全部展开显得很臃肿，所以我们可以采用代码折叠的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown笔记" scheme="http://www.gmlyo.com/categories/Markdown%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Markdown代码折叠与收起" scheme="http://www.gmlyo.com/tags/Markdown%E4%BB%A3%E7%A0%81%E6%8A%98%E5%8F%A0%E4%B8%8E%E6%94%B6%E8%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python数据类型</title>
    <link href="http://www.gmlyo.com/2019/05/18/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.gmlyo.com/2019/05/18/Python数据类型/</id>
    <published>2019-05-17T16:47:18.000Z</published>
    <updated>2019-05-18T03:40:27.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python数据类型"><a href="#Python数据类型" class="headerlink" title="Python数据类型"></a>Python数据类型</h1><a id="more"></a><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>什么是数据？为何要有多种类型的数据？<br>数据即变量的值，如：<code>age=18</code>，<code>18</code>则是我们保存的数据。<br>变量是用来反映/保持状态以及状态变化的，毫无疑问针对不同的状态就应该用不同类型的数据去标识。</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p><code>整型</code>和<code>浮点型</code>统称为数字类型</p><h3 id="int整型"><a href="#int整型" class="headerlink" title="int整型"></a>int整型</h3><p>用于标识：年龄，等级，身份证号，QQ号，个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int（整型）</span></span><br><span class="line">在<span class="number">32</span>位机器上，整数的位数为<span class="number">32</span>位，取值范围为<span class="number">-2</span>**<span class="number">31</span>～<span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>，即 <span class="number">-2147483648</span>～<span class="number">2147483647</span></span><br><span class="line">在<span class="number">64</span>位系统上，整数的位数为<span class="number">64</span>位，取值范围为<span class="number">-2</span>**<span class="number">63</span>～<span class="number">2</span>**<span class="number">63</span><span class="number">-1</span>，即 <span class="number">-9223372036854775808</span>～<span class="number">9223372036854775807</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># long（长整型）</span></span><br><span class="line">跟C语言不同，Python 的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。</span><br><span class="line">注意：自从 Python2<span class="number">.2</span> 起，如果整数发生溢出，Python 会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母 L 也不会导致严重后果了。</span><br><span class="line">注意：在 Python3 里不再有 long 类型了，全都是int</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= <span class="number">2</span>**<span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)    <span class="comment"># type()是查看数据类型的方法</span></span><br><span class="line">&lt;type <span class="string">'long'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">2</span>**<span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(b)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># complex复数型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=<span class="number">1</span><span class="number">-2j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.imag</span><br><span class="line"><span class="number">-2.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.real</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int整型</span></span><br><span class="line">age=<span class="number">10</span>  <span class="comment"># age=int(10)</span></span><br><span class="line"></span><br><span class="line">print(id(age))</span><br><span class="line"><span class="number">9462848</span></span><br><span class="line"></span><br><span class="line">print(type(age))</span><br><span class="line">int</span><br><span class="line"></span><br><span class="line">print(age)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="float浮点型"><a href="#float浮点型" class="headerlink" title="float浮点型"></a>float浮点型</h3><p>用于标识：工资，身高，体重<br>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">salary=<span class="number">3.1</span>  <span class="comment"># salary=float(3.1)</span></span><br><span class="line"></span><br><span class="line">print(id(salary))</span><br><span class="line"><span class="number">140185593323832</span></span><br><span class="line"></span><br><span class="line">print(type(salary))</span><br><span class="line">float</span><br><span class="line"></span><br><span class="line">print(salary)</span><br><span class="line"><span class="number">3.1</span></span><br></pre></td></tr></table></figure><h3 id="str字符串"><a href="#str字符串" class="headerlink" title="str字符串"></a>str字符串</h3><p>在 Python 中，加了引号的字符就是字符串类型，Python 并没有字符类型<br>用于标识：描述性的内容，如姓名，性别，国籍，种族<br>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">'zhangsan'</span>  <span class="comment"># name=str('zhangsan')</span></span><br></pre></td></tr></table></figure><p>单引号、双引号、多引号有什么区别？<br>单双引号没有任何区别，只有下面这种情况，需要考虑单双的配合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">"My name is zhangsan, I'm 18 years old!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多引号什么作用？作用就是多行字符串必须用多引号</span></span><br><span class="line">msg = <span class="string">'''</span></span><br><span class="line"><span class="string">今天我想写首小诗，</span></span><br><span class="line"><span class="string">歌颂我的同桌，</span></span><br><span class="line"><span class="string">你看他那乌黑的短发，</span></span><br><span class="line"><span class="string">好像一只炸毛鸡。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(msg)</span><br></pre></td></tr></table></figure><p>字符串拼接（只能在字符串之间进行，且只能相加或相乘）<br>数字可以进行加减乘除等运算，字符串呢？也能，但只能进行”相加”和”相乘”运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name=<span class="string">'zhangsan'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age=<span class="string">'18'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name+age  <span class="comment"># 相加其实就是简单拼接</span></span><br><span class="line"><span class="string">'zhangsan18'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name*<span class="number">5</span> </span><br><span class="line"><span class="string">'zhangsanzhangsanzhangsanzhangsanzhangsan'</span></span><br></pre></td></tr></table></figure><p>注意1：字符串相加的效率不高<br><code>字符串1</code>+<code>字符串3</code>，并不会在<code>字符串1</code>的基础上加<code>字符串2</code>，而是申请一个全新的<code>内存空间</code>存入<code>字符串1</code>和<code>字符串3</code>，相当于<code>字符串1</code>与<code>字符串3</code>的空间被<code>复制</code>了一次。<br>注意2：只能<code>字符串加字符串</code>，不能<code>字符串加其他类型</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python数据类型&quot;&gt;&lt;a href=&quot;#Python数据类型&quot; class=&quot;headerlink&quot; title=&quot;Python数据类型&quot;&gt;&lt;/a&gt;Python数据类型&lt;/h1&gt;
    
    </summary>
    
      <category term="Python笔记" scheme="http://www.gmlyo.com/categories/Python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python数据类型" scheme="http://www.gmlyo.com/tags/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python内存管理</title>
    <link href="http://www.gmlyo.com/2019/05/18/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.gmlyo.com/2019/05/18/Python内存管理/</id>
    <published>2019-05-17T16:40:56.000Z</published>
    <updated>2019-05-17T16:41:16.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python内存管理"><a href="#Python内存管理" class="headerlink" title="Python内存管理"></a>Python内存管理</h1><a id="more"></a><p>变量存哪了？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim p1.py</span><br><span class="line">x = 10</span><br></pre></td></tr></table></figure><p>当我们在<code>p1.py</code>中定义一个变量<code>x=10</code>，那么计算机把这个<code>变量值10</code>存放在哪里了呢？<br>回顾计算机的三大核心组件为：CPU、内存和硬盘。一定不是CPU，那是存放在内存还是硬盘中了呢？<br>再回顾变量运行的三个过程，如果我们没有使用Python解释器运行<code>p1.py</code>这个文件，那么<code>x=10</code>很明显只是很普通的四个字符<code>x、=、1、0</code>。而只有Python解释器运行了这个文件，那字符进入了内存，才会有变量这个概念。也就是说<code>变量是存放在内存当中</code>的。</p><p>变量存放在内存中这句话太宽泛了，我们把它具体化。现在想象我们在学校（电脑内存）里上课，学校每开一个班，学校都会开辟一个教室给这个班级上课用（存放变量值10），而班级的门牌号则是（变量名x）。也就是说，对于电脑内存这个大内存，每定义一个变量就会在这个大内存中开辟一个小空间，小空间内存放变量值10，然后内存给这个小空间一个变量名x（门牌号），x指向10。</p><h2 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h2><p>对于<code>p1.py</code>，如果我们再加上一段代码<code>x=11</code>，大内存会开辟另一个小空间存储<code>变量值11</code>，把变量值绑定另一个门牌号x，但是由于之前有x，所以大内存会解除x与10的连接，让x与11连接。这个时候10由于没有了门牌号，所以成为了Python眼中的垃圾，Python就会处理这个垃圾，释放10的内存占用，这就是Python的垃圾回收机制。而其他语言需要手动把10的内存占用释放掉。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>从上述的解释我们可以知道只要某个变量值绑定着门牌号，就不是垃圾，反之变量值没有绑定着门牌号，这个变量值就是垃圾，Python就会自动清理这个垃圾。这里我们对于这个门牌号给定一个专业的解释，在Python中这个门牌号被称作引用计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">257</span>  <span class="comment"># 257 引用计数加1为1</span></span><br><span class="line">y = x    <span class="comment"># 257 引用计数加1为2</span></span><br><span class="line">x = <span class="number">258</span>  <span class="comment"># 257 引用计数减1为1；258引用计数加1为1</span></span><br><span class="line"><span class="keyword">del</span> y    <span class="comment"># 257 引用计数减1为0，触发Python垃圾回收机制，Python清理257的内存占用</span></span><br></pre></td></tr></table></figure><p>上述代码就是一个引用计数加减的过程。</p><h2 id="小整数池"><a href="#小整数池" class="headerlink" title="小整数池"></a>小整数池</h2><p>对于引用计数，需要注意的是：Python实现<code>int</code>的时候有个小整数池。为了避免因创建相同的值而重复申请内存空间所带来的效率问题，Python解释器会在启动时创建出小整数池，范围是<code>[-5,256]</code>，该范围内的小整数对象是全局解释器范围内被重复使用，永远不会被回收。</p><p>在PyCharm中运行Python程序时，PyCharm出于对性能的考虑，会扩大小整数池的范围，其他的字符串等不可变类型也都包含在内一便采用相同的方式处理了，我们只需要记住这是一种优化机制，至于范围到底多大，无需细究。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>   <span class="comment"># 10引用计数加1为1</span></span><br><span class="line">y = x    <span class="comment"># 10引用计数加1为2</span></span><br><span class="line">z = <span class="number">10</span>   <span class="comment"># 10引用计数加1为3</span></span><br><span class="line">x = <span class="number">11</span>   <span class="comment"># 10引用计数减1为2；11引用计数加1为1</span></span><br><span class="line"><span class="keyword">del</span> y    <span class="comment"># 10引用计数减1为1</span></span><br><span class="line"><span class="keyword">del</span> z    <span class="comment"># 10引用计数减1为0，但不触发Python垃圾回收机制，因为10数据Python小整数池内的数，会在Python解释器关闭前一直存在</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python内存管理&quot;&gt;&lt;a href=&quot;#Python内存管理&quot; class=&quot;headerlink&quot; title=&quot;Python内存管理&quot;&gt;&lt;/a&gt;Python内存管理&lt;/h1&gt;
    
    </summary>
    
      <category term="Python笔记" scheme="http://www.gmlyo.com/categories/Python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python内存管理" scheme="http://www.gmlyo.com/tags/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python定义变量的三个特征</title>
    <link href="http://www.gmlyo.com/2019/05/17/Python%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E5%BE%81/"/>
    <id>http://www.gmlyo.com/2019/05/17/Python定义变量的三个特征/</id>
    <published>2019-05-16T18:36:56.000Z</published>
    <updated>2019-05-17T04:32:04.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python定义变量的三个特征"><a href="#Python定义变量的三个特征" class="headerlink" title="Python定义变量的三个特征"></a>Python定义变量的三个特征</h1><a id="more"></a><h2 id="定义变量的三个特征"><a href="#定义变量的三个特征" class="headerlink" title="定义变量的三个特征"></a>定义变量的三个特征</h2><p>对于每个变量，Python都提供了这三个方法分别获取变量的三个特征，其中python的内置功能<code>id()</code>，内存地址不一样，则<code>id()</code>后打印的结果不一样，因为每一个变量值都有其内存地址，而<code>id</code>是用来反映变量值在内存中的位置，内存地址不同则<code>id</code>不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取变量的变量值</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取变量的id，可以理解成变量在内存中的地址</span></span><br><span class="line">print(id(x))</span><br><span class="line"><span class="number">9462848</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取变量的数据类型</span></span><br><span class="line">print(type(x))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="变量比较"><a href="#变量比较" class="headerlink" title="变量比较"></a>变量比较</h2><h3 id="判断变量值是否相等用"><a href="#判断变量值是否相等用" class="headerlink" title="判断变量值是否相等用"></a>判断变量值是否相等用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name1=<span class="string">'张三'</span></span><br><span class="line">name2=<span class="string">'李四'</span></span><br><span class="line"></span><br><span class="line">print(name1==name2)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="判断变量id是否相等"><a href="#判断变量id是否相等" class="headerlink" title="判断变量id是否相等"></a>判断变量id是否相等</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">11</span></span><br><span class="line">y = x</span><br><span class="line">z = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">print(x == y)  <span class="comment"># True</span></span><br><span class="line">print(x <span class="keyword">is</span> y)  <span class="comment"># True</span></span><br><span class="line">print(x <span class="keyword">is</span> z)  <span class="comment"># True，整数池的原因</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">257</span></span><br><span class="line">z = <span class="number">257</span></span><br><span class="line"></span><br><span class="line">print(x <span class="keyword">is</span> z)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>从上述的打印消息可以看出<br><code>id</code>相等的变量，<code>值</code>一定相等，指向的是同一个内存地址<br><code>值</code>相等的变量，<code>id</code>不一定相等</p><p>其中在第一次打印<code>print(x is z)</code>的时候就触发了上一章讲的整数池。这可以理解成Python的优化机制，<code>11</code>的值本身不大，并且由于我们快速的再一次使用了<code>11</code>，再由于申请内存空间需要计算机开销，因此Python让<code>x</code>和<code>z</code>都指向同一个<code>11</code>。因为存不是目的，取才是目的，这样进行优化的话并不会影响程序的运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python定义变量的三个特征&quot;&gt;&lt;a href=&quot;#Python定义变量的三个特征&quot; class=&quot;headerlink&quot; title=&quot;Python定义变量的三个特征&quot;&gt;&lt;/a&gt;Python定义变量的三个特征&lt;/h1&gt;
    
    </summary>
    
      <category term="Python笔记" scheme="http://www.gmlyo.com/categories/Python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python定义变量的三个特征" scheme="http://www.gmlyo.com/tags/Python%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E5%BE%81/"/>
    
  </entry>
  
  <entry>
    <title>Python变量</title>
    <link href="http://www.gmlyo.com/2019/05/16/Python%E5%8F%98%E9%87%8F/"/>
    <id>http://www.gmlyo.com/2019/05/16/Python变量/</id>
    <published>2019-05-16T12:56:01.000Z</published>
    <updated>2019-05-16T18:24:13.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python变量"><a href="#Python变量" class="headerlink" title="Python变量"></a>Python变量</h1><a id="more"></a><h2 id="什么是变量？（掌握）"><a href="#什么是变量？（掌握）" class="headerlink" title="什么是变量？（掌握）"></a>什么是变量？（掌握）</h2><p>变量即变化的量，核心是“变”与“量”二字，变即变化，量即衡量状态。</p><p>计算机通过记录状态去识别，这就是量的概念。</p><ul><li>变：现实世界中的状态是会发生改变的。</li><li>量：记录现实世界中的状态，让计算机能够像人一样去识别世间万物。<br>今年可能175cm，明年可能就是180cm了，那这种状态是不是会发生变化。</li></ul><h2 id="为什么要有变量？（掌握）"><a href="#为什么要有变量？（掌握）" class="headerlink" title="为什么要有变量？（掌握）"></a>为什么要有变量？（掌握）</h2><p>程序执行的本质就是一系列状态的变化，变是程序执行的直接体现，所以我们需要有一种机制能够反映或者说是保存下来程序执行时状态以及状态的变化。<br>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">英雄的等级为1，打怪升级（变）为10</span><br><span class="line">僵尸的存活状态True，被植物打死了，于是变为False</span><br><span class="line">人的名字为张三，也可以修改为张叁</span><br></pre></td></tr></table></figure><h2 id="定义变量（掌握）"><a href="#定义变量（掌握）" class="headerlink" title="定义变量（掌握）"></a>定义变量（掌握）</h2><p>变量名（相当于门牌号，指向值所在的空间），等号，变量值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'张三'</span></span><br><span class="line">gender = <span class="string">'male'</span></span><br><span class="line">age = 30</span><br><span class="line">height = 175</span><br><span class="line">weight = 130</span><br></pre></td></tr></table></figure><h2 id="变量的组成（掌握）"><a href="#变量的组成（掌握）" class="headerlink" title="变量的组成（掌握）"></a>变量的组成（掌握）</h2><ol><li>变量名：变量名用来引用变量值，凡是需要用变量值，都需要通过变量名</li><li>赋值符号：赋值</li><li>变量值：存放数据，用来记录现实世界中的某种状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name  <span class="comment"># 报错，无任何意义</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = 30</span><br><span class="line">height = 175</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(age)     <span class="comment"># 30</span></span><br><span class="line"><span class="built_in">print</span>(height)  <span class="comment"># 175</span></span><br></pre></td></tr></table></figure><h2 id="变量名的命名规范"><a href="#变量名的命名规范" class="headerlink" title="变量名的命名规范"></a>变量名的命名规范</h2><p>如果对于一个变量，想怎么命名就怎么命名，那样没有任何问题，顶多就是老板检查代码后，第二天就不用去公司了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sfasfewfasdfa=<span class="string">'张三'</span></span><br><span class="line"><span class="built_in">print</span>(sfasfewfasdfa)  <span class="comment"># '张三'</span></span><br></pre></td></tr></table></figure><p>定义一个变量就是在记录现实世界中的的状态，<code>存不是目的，取才是目的</code>。<br>变量的命名应该满足以下三个规范</p><ol><li>变量的命名应该能反映变量值所描述的状态，不可用中文</li><li>变量名必须用<code>字母</code>，<code>数字</code>，<code>下划线</code>组合，变量名的<code>第一个字符不能是数字</code></li><li>关键字不能声明为变量名</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>, <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'exec'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>, <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'print'</span>, <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]</span><br></pre></td></tr></table></figure><h2 id="变量名的两种方式（了解）"><a href="#变量名的两种方式（了解）" class="headerlink" title="变量名的两种方式（了解）"></a>变量名的两种方式（了解）</h2><h3 id="驼峰体"><a href="#驼峰体" class="headerlink" title="驼峰体"></a>驼峰体</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AgeOfZhangsan = <span class="number">30</span></span><br><span class="line">print(AgeOfZhangsan)  <span class="comment"># 30</span></span><br></pre></td></tr></table></figure><h3 id="下划线（推荐使用）"><a href="#下划线（推荐使用）" class="headerlink" title="下划线（推荐使用）"></a>下划线（推荐使用）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age_of_zhangsan = <span class="number">30</span></span><br><span class="line">print(age_of_zhangsan)  <span class="comment"># 30</span></span><br></pre></td></tr></table></figure><p>以上两种变量名的风格，推荐使用下划线的方式。</p><p>定义变量会有：id，type，value</p><ol><li><code>==</code>比较的是<code>value</code></li><li><code>is</code>比较的是<code>id</code></li></ol><p><strong>强调</strong></p><ol><li><code>id</code>相同，意味着<code>type</code>和<code>value</code>必定相同</li><li><code>value</code>相同<code>type</code>肯定相同，但<code>id</code>可能不同，如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=<span class="string">'Info Zhangsan:18'</span></span><br><span class="line">&gt;&gt;&gt; y=<span class="string">'Info Zhangsan:18'</span></span><br><span class="line">&gt;&gt;&gt; id(x)</span><br><span class="line">4376607152</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">4376607408</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; x == y</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x is y</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h2 id="常量（掌握）"><a href="#常量（掌握）" class="headerlink" title="常量（掌握）"></a>常量（掌握）</h2><p>变量是变化的量，常量则是不变的量。<br>Python中没有使用语法强制定义常量，也就是说，Python中定义常量本质上就是变量。<br>如果非要定义常量，变量名必须全大写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AGE_OF_ZHANGSAN = <span class="number">30</span></span><br><span class="line">print(AGE_OF_ZHANGSAN)  <span class="comment"># 30</span></span><br></pre></td></tr></table></figure><p>如果是常量，那就没必要更改，所以Python就只制定了一个规范，而没指定常量的语法。<br>而在C语言中有专门的常量定义语法，<code>const int age = 19;</code>，一旦定义<code>age</code>为常量，更改<code>age</code>即会报错。</p><h2 id="注释（掌握）"><a href="#注释（掌握）" class="headerlink" title="注释（掌握）"></a>注释（掌握）</h2><p>当把变量理解透了，就已经进入了编程的世界。随着学习的深入，用不了多久，就可以写复杂的上千甚至上万行的代码了，有些代码花了很久写出来，过了些天再回去看，发现竟然看不懂了，这很正常了。另外，以后在工作中会发现，一个项目多数是由几个甚至几十个开发人员一起做，要调用别人写的代码，别人也要用你的，如果代码不加注释，自己都看不懂，更别说别人了，这产会很麻烦。所以为了避免这种尴尬的事情发生，一定要增加代码的可读性。代码注释分单行和多行注释，单行注释用<code>#</code>，多行注释可以用<code>三对单/双引号</code>，使用三引号注释可以换行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">三单引号注释</span></span><br><span class="line"><span class="string">三单引号注释</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">三双引号多行注释</span></span><br><span class="line"><span class="string">三双引号多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="注释的原则"><a href="#注释的原则" class="headerlink" title="注释的原则"></a>注释的原则</h2><ol><li>不用全部加注释，只需要在自己觉得重要或不好理解的部分加注释即可</li><li>注释可以用中文或英文，但不要用拼音</li></ol><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p>掌握 -&gt; 熟悉 -&gt; 了解</p><ul><li>掌握：倒背如流</li><li>熟悉：正背如流</li><li>了解：看到能够想起</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.cnblogs.com/linhaifeng/articles/7133167.html" target="_blank" rel="noopener">http://www.cnblogs.com/linhaifeng/articles/7133167.html</a><br><a href="https://www.cnblogs.com/nickchen121/p/10722738.html" target="_blank" rel="noopener">https://www.cnblogs.com/nickchen121/p/10722738.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python变量&quot;&gt;&lt;a href=&quot;#Python变量&quot; class=&quot;headerlink&quot; title=&quot;Python变量&quot;&gt;&lt;/a&gt;Python变量&lt;/h1&gt;
    
    </summary>
    
      <category term="Python笔记" scheme="http://www.gmlyo.com/categories/Python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python变量" scheme="http://www.gmlyo.com/tags/Python%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>grep显示前后几行信息</title>
    <link href="http://www.gmlyo.com/2019/04/29/grep%E6%98%BE%E7%A4%BA%E5%89%8D%E5%90%8E%E5%87%A0%E8%A1%8C%E4%BF%A1%E6%81%AF/"/>
    <id>http://www.gmlyo.com/2019/04/29/grep显示前后几行信息/</id>
    <published>2019-04-29T04:00:11.000Z</published>
    <updated>2019-04-29T05:25:47.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="grep显示前后几行信息"><a href="#grep显示前后几行信息" class="headerlink" title="grep显示前后几行信息"></a>grep显示前后几行信息</h1><a id="more"></a><h2 id="显示foo及前5行"><a href="#显示foo及前5行" class="headerlink" title="显示foo及前5行"></a>显示foo及前5行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -B 5 foo file</span><br></pre></td></tr></table></figure><h2 id="显示foo及后5行"><a href="#显示foo及后5行" class="headerlink" title="显示foo及后5行"></a>显示foo及后5行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -A 5 foo file</span><br></pre></td></tr></table></figure><h2 id="显示-file-文件里匹配-foo-字串那行以及上下5行"><a href="#显示-file-文件里匹配-foo-字串那行以及上下5行" class="headerlink" title="显示 file 文件里匹配 foo 字串那行以及上下5行"></a>显示 file 文件里匹配 foo 字串那行以及上下5行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -C 5 foo file</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;grep显示前后几行信息&quot;&gt;&lt;a href=&quot;#grep显示前后几行信息&quot; class=&quot;headerlink&quot; title=&quot;grep显示前后几行信息&quot;&gt;&lt;/a&gt;grep显示前后几行信息&lt;/h1&gt;
    
    </summary>
    
      <category term="grep笔记" scheme="http://www.gmlyo.com/categories/grep%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="grep显示前后几行信息" scheme="http://www.gmlyo.com/tags/grep%E6%98%BE%E7%A4%BA%E5%89%8D%E5%90%8E%E5%87%A0%E8%A1%8C%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>Chrony 设置服务器集群系统时间同步</title>
    <link href="http://www.gmlyo.com/2019/01/25/Chrony%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    <id>http://www.gmlyo.com/2019/01/25/Chrony服务器集群系统时间同步/</id>
    <published>2019-01-25T05:39:16.000Z</published>
    <updated>2019-01-25T08:06:14.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chrony-设置服务器集群系统时间同步"><a href="#Chrony-设置服务器集群系统时间同步" class="headerlink" title="Chrony 设置服务器集群系统时间同步"></a>Chrony 设置服务器集群系统时间同步</h1><blockquote><p>RHEL7/CentOS7 新的 NTP 对时服务 Chrony</p></blockquote><a id="more"></a><h2 id="什么是Chrony？"><a href="#什么是Chrony？" class="headerlink" title="什么是Chrony？"></a>什么是Chrony？</h2><p>Chrony 是一个开源的自由软件，CentOS7/RHEL7 操作系统，已经是默认服务，默认配置文件在 <code>/etc/chrony.conf</code> 它能保持系统时间与时间服务器（NTP）同步，让时间始终保持同步。相对于 NTP 时间同步软件，占据很大优势。其用法也很简单。Chrony 应用本身已经有几年了，它其实是网络时间协议的 (NTP) 的另一种实现。一直以来众多发行版里标配的都是 ntpd 对时服务，自 CentOS7/RHEL7 起，Chrony 做为了发行版里的标配服务，不过老的 ntpd 服务依旧在 CentOS7/RHEL7 里可以找到。</p><h2 id="Chrony-两个核心组件"><a href="#Chrony-两个核心组件" class="headerlink" title="Chrony 两个核心组件"></a>Chrony 两个核心组件</h2><blockquote><p>Chrony 可以同时做为 NTP 服务的客户端和服务端。默认安装完后有两个程序 <code>chronyd</code> 和 <code>chronyc</code>。</p><p>chronyd（主程序文件）<br>是守护 daemon 进程程序，主要用于调整内核中运行的系统时间和时间服务器同步。它确定计算机增减时间的比率，并对此进行调整补偿。</p><p>chronyc（工具程序）<br>一个交互式命令行工具，提供一个用户界面，用于监控性能并进行多样化的配置。它可以在chronyd实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。</p></blockquote><p><strong> OS环境 </strong></p><blockquote><p>10.28.204.65 客户端<br>10.28.204.66 服务端<br>CentOS Linux release 7.6.1810 (Core)</p></blockquote><h2 id="安装-Chrony"><a href="#安装-Chrony" class="headerlink" title="安装 Chrony"></a>安装 Chrony</h2><blockquote><p>系统默认已经安装，如未安装，请执行以下命令安装</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install chrony</span><br></pre></td></tr></table></figure><h2 id="启动并加入开机自启动"><a href="#启动并加入开机自启动" class="headerlink" title="启动并加入开机自启动"></a>启动并加入开机自启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start chronyd.service</span><br><span class="line">systemctl <span class="built_in">enable</span> chronyd.service</span><br><span class="line">systemctl -l status chronyd.service</span><br><span class="line">systemctl stop chronyd.service</span><br><span class="line"><span class="comment"># 设置开机自启，默认是enable的</span></span><br><span class="line">systemctl restart chronyd.service</span><br></pre></td></tr></table></figure><h2 id="防火墙-Firewalld-设置"><a href="#防火墙-Firewalld-设置" class="headerlink" title="防火墙 Firewalld 设置"></a>防火墙 Firewalld 设置</h2><blockquote><p>因 NTP 使用 123/UDP 端口协议，所以允许 NTP 服务即可</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-service=ntp --permanent</span><br><span class="line">firewall-cmd --add-port=123/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="配置-Chrony"><a href="#配置-Chrony" class="headerlink" title="配置 Chrony"></a>配置 Chrony</h2><blockquote><p>以下是系统默认配置文件，对此加以说明</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/chrony.conf</span><br><span class="line"><span class="comment"># 使用pool.ntp.org项目中的公共服务器。以server开，理论上你想添加多少时间服务器都可以。</span></span><br><span class="line"><span class="comment"># Please consider joining the pool (http://www.pool.ntp.org/join.html).</span></span><br><span class="line"><span class="comment">#server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 3.centos.pool.ntp.org iburst</span></span><br><span class="line"></span><br><span class="line">server 0.cn.pool.ntp.org iburst minpoll 4 maxpoll 10</span><br><span class="line">server 1.cn.pool.ntp.org iburst minpoll 4 maxpoll 10</span><br><span class="line">server 2.cn.pool.ntp.org iburst minpoll 4 maxpoll 10</span><br><span class="line">server 3.cn.pool.ntp.org iburst minpoll 4 maxpoll 10</span><br><span class="line"></span><br><span class="line">server ntp1.aliyun.com iburst minpoll 4 maxpoll 10</span><br><span class="line">server ntp2.aliyun.com iburst minpoll 4 maxpoll 10</span><br><span class="line">server ntp3.aliyun.com iburst minpoll 4 maxpoll 10</span><br><span class="line">server ntp4.aliyun.com iburst minpoll 4 maxpoll 10</span><br><span class="line">server ntp5.aliyun.com iburst minpoll 4 maxpoll 10</span><br><span class="line">server ntp6.aliyun.com iburst minpoll 4 maxpoll 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据实际时间计算出服务器增减时间的比率，然后记录到一个文件中，在系统重启后为系统做出最佳时间补偿调整。</span></span><br><span class="line">driftfile /var/lib/chrony/drift</span><br><span class="line"></span><br><span class="line"><span class="comment"># chronyd根据需求减慢或加速时间调整，</span></span><br><span class="line"><span class="comment"># 在某些情况下系统时钟可能漂移过快，导致时间调整用时过长。</span></span><br><span class="line"><span class="comment"># 该指令强制chronyd调整时期，大于某个阀值时步进调整系统时钟。</span></span><br><span class="line"><span class="comment"># 只有在因chronyd启动时间超过指定的限制时（可使用负值来禁用限制）没有更多时钟更新时才生效。</span></span><br><span class="line">makestep 1.0 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将启用一个内核模式，在该模式中，系统时间每11分钟会拷贝到实时时钟（RTC）。</span></span><br><span class="line">rtcsync</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable hardware timestamping on all interfaces that support it.</span></span><br><span class="line"><span class="comment"># 通过使用hwtimestamp指令启用硬件时间戳</span></span><br><span class="line"><span class="comment">#hwtimestamp eth0</span></span><br><span class="line"><span class="comment">#hwtimestamp eth1</span></span><br><span class="line"><span class="comment">#hwtimestamp *</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Increase the minimum number of selectable sources required to adjust</span></span><br><span class="line"><span class="comment"># the system clock.</span></span><br><span class="line"><span class="comment">#minsources 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一台主机、子网，或者网络以允许或拒绝NTP连接到扮演时钟服务器的机器</span></span><br><span class="line">allow 192.168.0.0/16</span><br><span class="line"><span class="comment">#deny 192.168/16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Serve time even if not synchronized to a time source.</span></span><br><span class="line"><span class="comment"># 即使自己未能通过网络时间服务器同步到时间，也允许将本地时间作为标准时间授时给其它客户端</span></span><br><span class="line"><span class="built_in">local</span> stratum 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定包含NTP验证密钥的文件。</span></span><br><span class="line"><span class="comment">#keyfile /etc/chrony.keys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件的目录。</span></span><br><span class="line">logdir /var/<span class="built_in">log</span>/chrony</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select which information is logged.</span></span><br><span class="line"><span class="comment">#log measurements statistics tracking</span></span><br></pre></td></tr></table></figure><h2 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h2><h3 id="查看当前系统时区"><a href="#查看当前系统时区" class="headerlink" title="查看当前系统时区"></a>查看当前系统时区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timedatectl</span><br><span class="line">      Local time: Fri 2018-2-29 13:31:04 CST</span><br><span class="line">  Universal time: Fri 2018-2-29 05:31:04 UTC</span><br><span class="line">        RTC time: Fri 2018-2-29 08:17:20</span><br><span class="line">       Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line">     NTP enabled: yes</span><br><span class="line">NTP synchronized: yes</span><br><span class="line"> RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: no</span><br><span class="line">      DST active: n/a</span><br></pre></td></tr></table></figure><blockquote><p>如果你当前的时区不正确，请按照以下操作设置。</p></blockquote><h3 id="查看所有可用的时区"><a href="#查看所有可用的时区" class="headerlink" title="查看所有可用的时区"></a>查看所有可用的时区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl list-timezones</span><br></pre></td></tr></table></figure><blockquote><p>筛选式查看在亚洲 <code>S</code> 开的上海可用时区</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timedatectl list-timezones |  grep  -E <span class="string">"Asia/S.*"</span></span><br><span class="line">Asia/Sakhalin</span><br><span class="line">Asia/Samarkand</span><br><span class="line">Asia/Seoul</span><br><span class="line">Asia/Shanghai</span><br><span class="line">Asia/Singapore</span><br><span class="line">Asia/Srednekolymsk</span><br></pre></td></tr></table></figure><blockquote><p>设置当前系统为 Asia/Shanghai 上海时区</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure><blockquote><p>设置完时区后，强制同步下系统时钟</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chronyc -<span class="selector-tag">a</span> makestep</span><br><span class="line"><span class="number">200</span> OK</span><br></pre></td></tr></table></figure><h2 id="服务器集群之间的系统时间同步"><a href="#服务器集群之间的系统时间同步" class="headerlink" title="服务器集群之间的系统时间同步"></a>服务器集群之间的系统时间同步</h2><p>在生产环境中，其网络都是内网结构，那么内网如何保证服务器之间的时间同步呢？其实这个问题很简单，只需要搭建一台内网时间服务器，然后让所有计算机都到服务端（<code>10.28.204.66</code>）去同步时间即可。</p><blockquote><p>具体操作：在服务端注释以下内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 3.centos.pool.ntp.org iburst</span></span><br></pre></td></tr></table></figure><blockquote><p>并添加以下内容：表示与本机同步时间</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server 10.28.204.66 iburst</span><br></pre></td></tr></table></figure><blockquote><p>这样我们需求的一台内网时间服务器已经配置完毕。<br>同样在客户端注释掉其他 <code>server</code>，并在客户端 <code>10.28.204.65</code> 添加以下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server 10.28.204.66 iburst</span><br></pre></td></tr></table></figure><blockquote><p>到此已经完成系统时间的同步。如有多台机器，操作也是如此。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 时间同步 详细源状态</span></span><br><span class="line">chronyc sources</span><br><span class="line">chronyc sources -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 时间同步源服务器 状态</span></span><br><span class="line">chronyc sourcestats</span><br><span class="line">chronyc sourcestats -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置硬件时间</span></span><br><span class="line"><span class="comment"># 硬件时间默认为UTC</span></span><br><span class="line">timedatectl <span class="built_in">set</span>-local-rtc 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用NTP时间同步</span></span><br><span class="line">timedatectl <span class="built_in">set</span>-ntp yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过直接执行 chronyc 命令来修改设置</span></span><br><span class="line"><span class="comment"># 检查NTP访问是否对特定主机可用</span></span><br><span class="line">chronyc accheck</span><br><span class="line"><span class="comment"># 该命令会显示有多少NTP源在线/离线</span></span><br><span class="line">chronyc activity</span><br><span class="line"><span class="comment"># 手动添加一台新的NTP服务器</span></span><br><span class="line">chronyc add server</span><br><span class="line"><span class="comment"># 在客户端报告已访问到服务器</span></span><br><span class="line">chronyc clients</span><br><span class="line"><span class="comment"># 手动移除NTP服务器或对等服务器</span></span><br><span class="line">chronyc delete</span><br><span class="line"><span class="comment"># 手动设置守护进程时间</span></span><br><span class="line">chronyc settime</span><br><span class="line"><span class="comment"># 校准时间服务器，显示系统时间信息</span></span><br><span class="line">chronyc tracking</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他时间设置相关指令</span></span><br><span class="line"><span class="comment"># 查看日期时间、时区及NTP状态</span></span><br><span class="line">timedatectl</span><br><span class="line"><span class="comment"># 查看时区列表</span></span><br><span class="line">timedatectl list-timezones</span><br><span class="line"><span class="comment"># 修改时区</span></span><br><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br><span class="line"><span class="comment"># 修改日期时间</span></span><br><span class="line">timedatectl <span class="built_in">set</span>-time <span class="string">"2015-01-21 11:50:00"</span>  <span class="comment"># 可以只修改其中一个</span></span><br><span class="line"><span class="comment"># 开启NTP</span></span><br><span class="line">timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span>/flase</span><br></pre></td></tr></table></figure><blockquote><p>还有另一个有趣的命令 <code>system-config-date</code>，在 rhel7/centos7 里也给了我们一个可以图形化配置chrony 服务的工具 。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install system-config-date</span><br></pre></td></tr></table></figure><blockquote><p>安装完成后运行 <code>system-config-date</code> 命令，界面如下</p></blockquote><p><img src="https://i.loli.net/2019/01/25/5c4aa385e3206.png" alt="system-config-date.png"></p><blockquote><p> 最后需要注意的是，配置完 <code>/etc/chrony.conf</code> 后，需重启 chrony 服务，否则可能会不生效。</p></blockquote><h2 id="Chrony的优势"><a href="#Chrony的优势" class="headerlink" title="Chrony的优势"></a>Chrony的优势</h2><p>Chrony 的优势包括：</p><ul><li>更快的同步只需要数分钟而非数小时时间，从而最大程度减少了时间和频率误差，这对于并非全天 24 小时运行的台式计算机或系统而言非常有用。</li><li>能够更好地响应时钟频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率发生变化的节能技术而言非常有用。</li><li>在初始同步后，它不会停止时钟，以防对需要系统时间保持单调的应用程序造成影响。</li><li>在应对临时非对称延迟时（例如，在大规模下载造成链接饱和时）提供了更好的稳定性。</li><li>无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://renwole.com/archives/1032" target="_blank" rel="noopener">https://renwole.com/archives/1032</a><br><a href="https://www.jianshu.com/p/dfdedfb9c59f" target="_blank" rel="noopener">https://www.jianshu.com/p/dfdedfb9c59f</a><br><a href="https://my.oschina.net/91devel/blog/2878266" target="_blank" rel="noopener">https://my.oschina.net/91devel/blog/2878266</a><br><a href="http://www.pool.ntp.org/zone/asia" target="_blank" rel="noopener">http://www.pool.ntp.org/zone/asia</a><br><a href="http://www.pool.ntp.org/zone/cn" target="_blank" rel="noopener">http://www.pool.ntp.org/zone/cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Chrony-设置服务器集群系统时间同步&quot;&gt;&lt;a href=&quot;#Chrony-设置服务器集群系统时间同步&quot; class=&quot;headerlink&quot; title=&quot;Chrony 设置服务器集群系统时间同步&quot;&gt;&lt;/a&gt;Chrony 设置服务器集群系统时间同步&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;RHEL7/CentOS7 新的 NTP 对时服务 Chrony&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NTP笔记" scheme="http://www.gmlyo.com/categories/NTP%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Chrony 设置服务器集群系统时间同步" scheme="http://www.gmlyo.com/tags/Chrony-%E8%AE%BE%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>iptables防火墙NAT服务器的设置</title>
    <link href="http://www.gmlyo.com/2019/01/20/iptables%E9%98%B2%E7%81%AB%E5%A2%99NAT%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    <id>http://www.gmlyo.com/2019/01/20/iptables防火墙NAT服务器的设置/</id>
    <published>2019-01-19T18:07:13.000Z</published>
    <updated>2019-01-19T18:36:17.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iptables防火墙NAT服务器的设置"><a href="#iptables防火墙NAT服务器的设置" class="headerlink" title="iptables防火墙NAT服务器的设置"></a>iptables防火墙NAT服务器的设置</h1><a id="more"></a><h2 id="NAT-服务器的设置"><a href="#NAT-服务器的设置" class="headerlink" title="NAT 服务器的设置"></a>NAT 服务器的设置</h2><p>假设我们准备要架设一个路由器的延伸服务器，就称之为 NAT 服务器。NAT 是什么呢？简单的说，可以称它为内部 LAN 主机的  IP 分享器。</p><p><strong>NAT 的全名是 Network Address Translation</strong>，即网络地址的转换。通过字面上的意思我们来想一想，TCP/IP 的网络数据包不是有 IP 地址吗？IP 地址不是有来源与目的地吗？iptables 命令就能够修改 IP 数据包的报头数据，连目标或来源的 IP 地址都可以修改，甚至连 TCP 数据包报头的 port number 也能修改。</p><p>NAT 服务器的功能除了可以实现类似 IP 分享的功能之外</p><p><img src="https://i.loli.net/2019/01/20/5c436c2481af9.png" alt="firewall_01.png"></p><center>图：单一网络，仅有一个路由器的环境示意图</center><p>还可以达到类似 DMZ（非军事化隔离区）的功能。</p><p><img src="https://i.loli.net/2019/01/20/5c436c45c60be.png" alt="firewall_03.png"></p><center>图：架设在防火墙后端的网络服务器环境示意图</center><p>这完全取决于 NAT 是修改来源 IP 还是目标 IP。下面我们就来聊一聊此内容。</p><h2 id="什么是-NAT？SNAT？DNAT？"><a href="#什么是-NAT？SNAT？DNAT？" class="headerlink" title="什么是 NAT？SNAT？DNAT？"></a>什么是 NAT？SNAT？DNAT？</h2><p>在介绍 NAT 的实际操作之前，让我们再来看一下比较简单的数据包通过 iptables 而传送到后端主机的表与链流程。<br>参考图如下：</p><p><img src="https://i.loli.net/2019/01/20/5c436c5f62330.png" alt="iptables_04.png"></p><center>图：iptables 内建各表与链的相关性（简图）</center><p>当网络布线如 <code>单一网络</code> 的架构，若内部 LAN 有任何一台主机想要传送数据包出去时，那么这个数据包要如何通过 Linux 主机而传送出去呢？是这样的：</p><ol><li>先经过 NAT table 的 PREROUTING 链。</li><li>经由路由判断确定这个数据包是否要进入本机，若不进入本机，则下一步。</li><li>再经过 Filter table 的 FORWARD 链。</li><li>通过 NAT table 的 POSTROUTING 链，最后传送出去。</li></ol><p>NAT 服务器的重点就在于上面流程的第 1、4 步，也就是 NAT table 的两条重要的链：PREROUTING 与 POSTROUTING。那这两条链有什么重要的功能呢？重点在于修改 IP。但这两条链修改的 IP 是不一样的，<strong>POSTROUTING 修改的是来源 IP，PREROUTING 则修改的是目标 IP</strong>。由于修改的 IP 不一样，所以<strong>就称为来源 NAT (Source NAT, SNAT) 及目标 NAT (Destination NAT, DNAT)</strong>。我们先来谈一谈 IP 分享器功能的 SNAT。</p><h3 id="来源-NAT-SNAT-：修改数据包报头的来源项目"><a href="#来源-NAT-SNAT-：修改数据包报头的来源项目" class="headerlink" title="来源 NAT (SNAT)：修改数据包报头的来源项目"></a>来源 NAT (SNAT)：修改数据包报头的来源项目</h3><p>你应该有听说过 IP 路由器，它可以让家庭里的好几台主机同时通过一条 ADSL 网络连接到 Internet 上，如图 <code>单一网络</code> 中所示，那个 Linux 主机就是 IP 路由器。那么它是如何实现 IP 分享的功能呢？就是通过 NAT 表的 POSTROUTING 来处理的。假设网络布线如图 <code>单一网络</code> 所示， 那么 NAT 服务器是如何处理这个数据包的呢？</p><p>如图所示：</p><p><img src="https://i.loli.net/2019/01/20/5c436c791e576.png" alt="nat_01.png"></p><center>图：SNAT 数据包传送出去的示意图</center><p>在客户端 192.168.1.100 这台主机要连接到 <a href="http://tw.yahoo.com" target="_blank" rel="noopener">http://tw.yahoo.com</a> 去时，它的数据包报头会如何变化？</p><ol><li>客户端所发出的数据包报头中，来源会是 192.168.1.100，然后传送到 NAT 这台主机。</li><li>NAT 主机的内部接口 (192.168.1.2) 接收到这个数据包后，会主动分析报头数据，因为<strong>报头数据显示目的并非 Linux 本机，所以开始经过路由分析</strong>，将此数据包转到可以连接到 Internet 的 Public IP 处。</li><li><strong>由于 Private IP 与 Public IP 不能互通，所以 Linux 主机通过 iptables 的 NAT table 内的 POSTROUTING 链将数据包报头的来源伪装成为 Linux 的 Public IP，并且将两个不同来源 (192.168.1.100 及 Public IP) 的数据包对应写入暂存内存当中，然后将此数据包传送出去</strong>。</li></ol><p>此时 Internet 上面看到这个数据包时，都只会知道这个数据包来自 Public IP 而不知道其实是来自内部。好了，那么如果 Internet 返回数据包呢？又会怎么做？如图</p><p><img src="https://i.loli.net/2019/01/20/5c436c8e17aa3.png" alt="nat_02.png"></p><center>图：SNAT 数据包接收的示意图</center><ol><li>在 Internet 上面的主机接到这个数据包时，会将响应数据传送给那个 Public IP 的主机。</li><li>当 Linux NAT 服务器收到来自 Internet 的响应数据包后，会分析该数据包的序号，并比对刚刚记录到内存当中的数据，由于发现该数据包为后端主机之前传送出去的，<strong>因此在 NAT PREROUTING 链中，会将目标 IP 修改成为后端主机，亦即那台 192.168.1.100，然后发现目标已经不是本机 (Public IP)，所以开始通过路由分析数据包流向</strong>。</li><li>数据包会传送到 192.168.1.2 这个内部接口，然后再传送到最终目标 192.168.1.100 机器上去。</li></ol><p>经过这个流程，就可以发现，所有内部 LAN 的主机都可以通过这部 NAT 服务器连接出去，而大家在 Internet 上面看到的都是同一个 IP（就是 NAT 那台主机的 Public IP），所以，如果内部 LAN 主机没有连上不明网站的话，那么内部主机其实是具有一定程度的安全性的，因为 Internet 上的其他主机没有办法主动攻击你的 LAN 内的 PC。所以我们才会说，NAT 最简单的功能就是类似 IP 分享器。这也是 SNAT 的一种。</p><p>Tips：<br>NAT 服务器与路由器有什么不同？基本上，NAT 服务器一定是路由器，不过，NAT 服务器由于会修改 IP 报头数据，因此与单纯转递数据包的路由器不同。最常见的 IP 分享器就是一个路由器，但是这个 IP 分享器一定会有一个 Public IP 与一个 Private IP，让 LAN 内的 Private IP 可以通过 IP 分享器的 Public IP 传送出去。至于路由器通常两边都是 Public IP 或同时为 Private IP。</p><h3 id="目标-NAT-DNAT-：修改数据包报头的目标项目"><a href="#目标-NAT-DNAT-：修改数据包报头的目标项目" class="headerlink" title="目标 NAT (DNAT)：修改数据包报头的目标项目"></a>目标 NAT (DNAT)：修改数据包报头的目标项目</h3><p>SNAT 主要是应付内部 LAN 连接到 Internet 的使用方式，**DNAT 则主要用在内部主机想要架设可以让 Internet 访问的服务器。就有点类似图 <code>架设在防火墙后端的网络服务器</code> 的 DMZ 内的服务器。下面也先来谈一谈 DNAT 的运行吧。</p><p>如图所示：</p><p><img src="https://i.loli.net/2019/01/20/5c436ca1e87a7.png" alt="nat_03.png"></p><center>图：DNAT 的数据包传送示意图</center><p>假设内部主机 192.168.1.210 启动了 WWW 服务，这个服务的 port 开启在 port 80，那么 Internet 上面的主机 (61.xx.xx.xx) 要如何连接到内部服务器呢？当然，还是得要通过 Linux NAT 服务器。所以这台 Internet 上面的机器必须要连接到 NAT 的 Public IP 才行。</p><ol><li>外部主机想要连接到目的端的 WWW 服务，则必须要连接到 NAT 服务器上。</li><li>NAT 服务器已经设置好要分析出 port 80 的数据包，所以当 NAT 服务器接到这个数据包后，会将目标 IP 由 Public IP 改成 192.168.1.210，且将该数据包相关信息记录下来，等待内部服务器的响应。</li><li>上述的数据包在经过路由后，来到 Private 接口处，然后通过内部的 LAN 传送到 192.168.1.210 上。</li><li>192.186.1.210 会响应数据给 61.xx.xx.xx，这个回应当然会传送到 192.168.1.2 上去。</li><li>经过路由判断后，来到 NAT POSTROUTING 的链，然后通过第二步骤的记录，将来源 IP 由 192.168.1.210 改为 Public IP 后，就可以传送出去了。</li></ol><p>其实整个步骤几乎就等于 SNAT 的反向传送。这就是 DNAT。</p><h2 id="简单的NAT服务器：IP分享功能"><a href="#简单的NAT服务器：IP分享功能" class="headerlink" title="简单的NAT服务器：IP分享功能"></a>简单的NAT服务器：IP分享功能</h2><p>在 Linux 的 NAT 服务器服务当中，最常见的就是类似图 <code>单一网络</code> 的 IP 分享器功能。而由刚刚的介绍我们也该知道，这个 IP 分享器的功能其实就是 SNAT，作用就只是在 iptables 内的 NAT 表中，那个路由判断后的 POSTROUTING 链所做的工作就是进行 IP 的伪装。另外，需要了解的是，NAT 服务器必须要有一个 Public IP 接口，以及一个内部 LAN 连接的 Private IP 接口才行。下面的范例中，假设是这样的：</p><ul><li>外部接口使用 eth0，这个接口具有 Public IP。</li><li>内部接口使用 eth1，假设这个 IP 为 192.168.100.254。</li></ul><p>利用前面谈到的数据来设置网络参数后，务必要进行路由的检测，因为在 NAT 服务器的设置方面，最容易出错的地方就是路由。尤其是在拨号产生 ppp0 这个对外接口的环境下，这个问题最严重。一定要记住：<strong>如果 Public IP 取得的方式是拨号或 cable modem 时，对于配置文件 <code>/etc/sysconfig/network、ifcfg-eth0、ifcfg-eth1</code> 等，千万不要设置 GATEWAY</strong>，否则就会出现两个 default gateway，反而会造成问题。</p><p>编辑 iptables.rule 文件，该文件内已经含有 NAT 的脚本了。在该文件的第二部份关于 NAT 服务器的设置中，应该有看到下面这几行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i <span class="variable">$INIF</span> -j ACCEPT</span><br><span class="line"><span class="comment"># 这一行为非必要的，主要的目的是让内网 LAN 能够完全的使用 NAT 服务器资源</span></span><br><span class="line"><span class="comment"># 其中 $INIF 在本例中为 eth1 接口</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"><span class="comment"># 这一行则是在让 Linux 具有 router 的功能</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A POSTROUTING -s <span class="variable">$innet</span> -o <span class="variable">$EXTIF</span> -j MASQUERADE</span><br><span class="line"><span class="comment"># 这一行最关键！就是加入 NAT table 数据包伪装。本例中 $innet 是 192.168.100.0/24</span></span><br><span class="line"><span class="comment"># 而 $EXTIF 则是对外界面，本例中为 eth0</span></span><br></pre></td></tr></table></figure><p>以上输出重点在 “MASQUERADE”。这个设置值就是 <strong>IP 伪装成为封包出去 (-o) 的那块设备上的 IP</strong>。以上面的例子来说，就是 <code>$EXTIF</code>，也就是 <code>eth0</code>。所以数据包来源只要来自 <code>$innet</code> （也就是内部 LAN 的其他主机） ，只要该数据包可通过 <code>eth0</code> 传送出去，那就会自动的修改 IP 的来源报头成为 <code>eth0</code> 的 Public IP。将 iptables.rule 设置好你内、外网络接口，执行 iptables.rule 后，Linux 就拥有主机防火墙以及 NAT 服务器的功能。</p><p>例题：如同上面所述的案例，那么 LAN 内的其他 PC 应该要如何设置相关的网络参数？<br>答：答案其实很简单，将 NAT 服务器作为 PC 的 GATEWAY 即可。只要记得下面的参数值即可：</p><ul><li>NETWORK 为 192.168.100.0</li><li>NETMASK 为 255.255.255.0</li><li>BROADCAST 为 192.168.100.255</li><li>IP 可以设置 192.168.100.1 ~ 192.168.100.254 之间，不可重复</li><li>网关 (Gateway) 需要设置为 192.168.100.254（NAT 服务器的 Private IP）</li><li>DNS (/etc/resolv.conf) 需设置为 168.95.1.1 (Hinet) 或 139.175.10.20 (Seed Net)，这个请依 ISP 而定</li></ul><p>事实上，除了 IP 伪装 (MASQUERADE) 之外，我们还可以直接指定修改 IP 数据包报头的来源 IP。<br>如下面这个例子：</p><p>例题：假设对外的 IP 固定为 192.168.1.100，若不想使用伪装，该如何处理？<br>答：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 192.168.1.100</span><br></pre></td></tr></table></figure><p>例题：假设 NAT 服务器对外 IP 有好几个，那想要轮流使用不同的 IP 时，该如何设置？<br>假设你的 IP 范围为 192.168.1.210 ~ 192.168.1.220<br>答：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 192.168.1.210-192.168.1.220</span><br></pre></td></tr></table></figure><p>这样也可以修改网络数据包的来源 IP 资料。不过，除非使用的是固定 IP，且有多个 IP 可以对外连接，否则一般使用 IP 伪装即可，不需要使用到 SNAT。当然，你也可能有自己独特的环境。</p><h2 id="iptables-的额外内核模块功能"><a href="#iptables-的额外内核模块功能" class="headerlink" title="iptables 的额外内核模块功能"></a>iptables 的额外内核模块功能</h2><p>如果在 iptables.rule 文件内的第二部分仔细观察，可能会奇怪，为何我们需要加载一些有用的模块？比如 ip_nat_ftp 及 ip_nat_irc ？这是因为很多通信协议使用的数据包传输比较特殊，尤其是 FTP 文件传输使用两个 port 来处理数据。在这里我们需要知道，iptables 提供很多好用的模块，这些模块可以辅助数据包的过滤，可以让我们节省很多 iptables 的规则拟定工作。</p><h2 id="在防火墙后端的网络服务器上做-DNAT-设置"><a href="#在防火墙后端的网络服务器上做-DNAT-设置" class="headerlink" title="在防火墙后端的网络服务器上做 DNAT 设置"></a>在防火墙后端的网络服务器上做 DNAT 设置</h2><p>既然可以做 SNAT 的 IP 分享功能，我们当然可以使用 iptables 做出 DMZ。但是再次重申，不同的服务器数据包传输的方式可能有点差异，因此，建议新手不要玩这个东西。否则很容易导致某些服务无法顺利对 <strong>Internet 提供的问题</strong>。</p><p>先来谈一谈，如果想要处理 DNAT 的功能时，iptables 要如何下达命令？另外，我们必须要知道的是，<strong>DNAT 用到的是 NAT table 的 PREROUTING 链</strong>。不要搞错了。</p><p>例题：假设内网有部主机 IP 为 192.168.100.10，该主机是可对 Internet 开放的 WWW 服务器。该如何通过 NAT 机制，将 WWW 数据包传到该主机上？<br>答：假设 Public IP 所在的接口为 eth0 ，那么规则就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination 192.168.100.10:80</span><br></pre></td></tr></table></figure><p>上面例题中的 <code>-j DNAT --to-destination IP[:port]</code> 就是精髓，代表从 <code>eth0</code> 这个接口传入的，且想要使用 port 80 的服务时，将该数据包重新传递到 192.168.100.10:80 的 IP 及 port 上。可以同时修改 IP 与 port，真方便。其他还有一些较高级的 iptables 使用方式，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-j REDIRECT --to-ports &lt;port number&gt;</span><br><span class="line"><span class="comment"># 这个也挺常见的，基本上，就是进行本机上面 port 的转换</span></span><br><span class="line"><span class="comment"># 不过，特别留意的是，这个操作仅能够在 NAT table 的 PREROUTING 以及 </span></span><br><span class="line"><span class="comment"># OUTPUT 链上面实行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范例：将要求与 80 连接的数据包转递到 8080 这个 port</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp  --dport 80 -j REDIRECT --to-ports 8080</span><br><span class="line"><span class="comment"># 这种设置最容易在使用了非正规的 port 来进行某些 well known 的协议，</span></span><br><span class="line"><span class="comment"># 例如使用 8080 这个 port 来启动 WWW ，但是别人都以 port 80 来连接，</span></span><br><span class="line"><span class="comment"># 所以，就可以使用上面的方式来将对方对本机主机的连接传递到 8080 了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iptables防火墙NAT服务器的设置&quot;&gt;&lt;a href=&quot;#iptables防火墙NAT服务器的设置&quot; class=&quot;headerlink&quot; title=&quot;iptables防火墙NAT服务器的设置&quot;&gt;&lt;/a&gt;iptables防火墙NAT服务器的设置&lt;/h1&gt;
    
    </summary>
    
      <category term="iptables笔记" scheme="http://www.gmlyo.com/categories/iptables%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iptables防火墙NAT服务器的设置" scheme="http://www.gmlyo.com/tags/iptables%E9%98%B2%E7%81%AB%E5%A2%99NAT%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>iptables防火墙实例</title>
    <link href="http://www.gmlyo.com/2019/01/19/iptables%E9%98%B2%E7%81%AB%E5%A2%99%E5%AE%9E%E4%BE%8B/"/>
    <id>http://www.gmlyo.com/2019/01/19/iptables防火墙实例/</id>
    <published>2019-01-19T15:35:30.000Z</published>
    <updated>2019-01-19T18:21:24.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iptables防火墙实例"><a href="#iptables防火墙实例" class="headerlink" title="iptables防火墙实例"></a>iptables防火墙实例</h1><blockquote><p>推荐使用脚本来编写防火墙， 然后通过 <code>/etc/init.d/iptables save</code> 来将结果存储到 <code>/etc/sysconfig/iptables</code> 中去。而且此一特色还可以用在呼叫其他的 scripts ，可以让防火墙规则具有较为灵活的使用方式。 </p></blockquote><a id="more"></a><h2 id="规则草拟"><a href="#规则草拟" class="headerlink" title="规则草拟"></a>规则草拟</h2><p>下面介绍的这个防火墙，可以用来作为路由器上的防火墙，也可以用来作为本机的防火墙。 假设硬件连接如同下图所示， Linux 主机本身也是内部 LAN 的路由器，也就是一个简单的 IP 路由器的功能。假设目前网络接口有下面这些：</p><ul><li>外部网络使用 eth0（如果是拨号，有可能是 ppp0，请针对具体环境来设置）。</li><li>内部网络使用 eth1，且内部使用 192.168.100.0/24 这个 Class。</li><li>主机默认开放的服务有 WWW、SSH、HTTPS 等。</li></ul><p><img src="https://i.loli.net/2019/01/20/5c4367adb29cd.png" alt="centos_6_real_case.png"></p><center>图：一个局域网络的路由器架构示意图</center><p><strong>由于希望将信任网域 (LAN) 与不信任网域 (Internet) 完全分开，所以建议在 Linux 主机上面安装两块以上的实体网卡，将两块网卡接在不同的网络，这样可以避免很多问题</strong>。最重要的防火墙策略是：<strong>关闭所有的连接，仅开放特定的服务</strong>模式。 而且假设内部用户已经受过良好的训练，因此在 filter table 的 3 条链中默认策略是：</p><ul><li>INPUT 为 DROP</li><li>OUTPUT 及 FORWARD 为 ACCEPT</li></ul><p>整个防火墙流程图：</p><p><img src="https://i.loli.net/2019/01/20/5c4367f988687.png" alt="simple_firewall.png"></p><center>图：本机的防火墙规则流程示意图</center><p>原则上，内部 LAN 主机与主机本身的开放度很高，因为 OUTPUT 与 FORWARD 是完全开放的。对于小家庭的主机是这种设置可以接受的，因为内部的计算机数量不多，而且人员都是熟悉的，所以不需要特别加以控制。但是<strong>在大企业的内部，这样的规划是很不合格的，因为不能保证内部所有的人都可以按照我们的规定来使用 Network</strong>，也就是说家贼难防。因此，在这种环境下，连 OUTPUT 与 FORWARD 都需要特别加以管理才行。</p><h2 id="实际设置"><a href="#实际设置" class="headerlink" title="实际设置"></a>实际设置</h2><p>事实上，我们在设置防火墙的时候，不太可能会一个命令一个命令地输入，通常是利用 shell scripts 来帮我们实现这样的功能。下面是利用上面的流程图所规划出来的防火墙脚本，参考一下，但是需要将环境修改成适合自己的环境才行。此外，为了未来修改维护的方便，将整个 script 拆成 3 部分。</p><ul><li>iptables.rule：设置最基本的规则，包括清除防火墙规则、加载模块、设置服务可接受等。</li><li>iptables.deny：设置阻挡某些恶意主机的进入。</li><li>iptables.allow：设置允许某些自定义的后门来源主机进入。</li></ul><p>个人习惯是将这个脚本放置到 <code>/data/scripts/iptables</code> 目录下，你也可以自行放置到自己习惯的位置。那下面就来瞧瞧这个脚本是怎么写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/scripts/iptables</span><br><span class="line"><span class="built_in">cd</span> /data/scripts/iptables</span><br><span class="line"></span><br><span class="line">vim iptables.rule</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请先输入相关参数，不要输入错误</span></span><br><span class="line">EXTIF=<span class="string">"eth0"</span>             <span class="comment"># 这个是可以连上 Public IP 的网络接口</span></span><br><span class="line">INIF=<span class="string">"eth1"</span>              <span class="comment"># 内部 LAN 的连接接口；若无则写成 INIF=""</span></span><br><span class="line">INNET=<span class="string">"192.168.100.0/24"</span> <span class="comment"># 若无内部网域接口，请填写成 INNET=""</span></span><br><span class="line"><span class="built_in">export</span> EXTIF INIF INNET</span><br><span class="line"></span><br><span class="line"><span class="comment">########################### 第一部份，针对本机的防火墙设置 ###########################</span></span><br><span class="line"><span class="comment"># 1. 先设置好内核的网络功能</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /proc/sys/net/ipv4/conf/*/&#123;rp_filter,log_martians&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"1"</span> &gt; <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /proc/sys/net/ipv4/conf/*/&#123;accept_source_route,accept_redirects,\</span><br><span class="line">send_redirects&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"0"</span> &gt; <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 清除规则、设置默认策略及开放 lo 与相关的设置值</span></span><br><span class="line">PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin; <span class="built_in">export</span> PATH</span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 启动额外的防火墙 script 模块</span></span><br><span class="line"><span class="keyword">if</span> [ -f /data/scripts/iptables/iptables.deny ]; <span class="keyword">then</span></span><br><span class="line">    sh /data/scripts/iptables/iptables.deny</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f /data/scripts/iptables/iptables.allow ]; <span class="keyword">then</span></span><br><span class="line">    sh /data/scripts/iptables/iptables.allow</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -f /data/scripts/httpd-err/iptables.http ]; <span class="keyword">then</span></span><br><span class="line">    sh /data/scripts/httpd-err/iptables.http</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 允许某些类型的 ICMP 数据包进入</span></span><br><span class="line">AICMP=<span class="string">"0 3 3/4 4 11 12 14 16 18"</span></span><br><span class="line"><span class="keyword">for</span> tyicmp <span class="keyword">in</span> <span class="variable">$AICMP</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    iptables -A INPUT -i <span class="variable">$EXTIF</span> -p icmp --icmp-type <span class="variable">$tyicmp</span> -j ACCEPT</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 允许某些服务的进入，请依照自己的环境开启</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p TCP -i $EXTIF --dport  21 --sport 1024:65534 -j ACCEPT # FTP</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p TCP -i $EXTIF --dport  22 --sport 1024:65534 -j ACCEPT # SSH</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p TCP -i $EXTIF --dport  25 --sport 1024:65534 -j ACCEPT # SMTP</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p UDP -i $EXTIF --dport  53 --sport 1024:65534 -j ACCEPT # DNS</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p TCP -i $EXTIF --dport  53 --sport 1024:65534 -j ACCEPT # DNS</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p TCP -i $EXTIF --dport  80 --sport 1024:65534 -j ACCEPT # WWW</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p TCP -i $EXTIF --dport 110 --sport 1024:65534 -j ACCEPT # POP3</span></span><br><span class="line"><span class="comment"># iptables -A INPUT -p TCP -i $EXTIF --dport 443 --sport 1024:65534 -j ACCEPT # HTTPS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################### 第二部份，针对后端主机的防火墙设置 ###########################</span></span><br><span class="line"><span class="comment"># 1. 先加载一些有用的模块</span></span><br><span class="line">modules=<span class="string">"ip_tables iptable_nat ip_nat_ftp ip_nat_irc ip_conntrack ip_conntrack_ftp ip_conntrack_irc"</span></span><br><span class="line"><span class="keyword">for</span> mod <span class="keyword">in</span> <span class="variable">$modules</span>; <span class="keyword">do</span></span><br><span class="line">    testmod=$(lsmod | grep <span class="string">"^<span class="variable">$&#123;mod&#125;</span> "</span> | awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$testmod</span>"</span> == <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">        modprobe <span class="variable">$mod</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 清除 NAT table 的规则</span></span><br><span class="line">iptables -F -t nat</span><br><span class="line">iptables -X -t nat</span><br><span class="line">iptables -Z -t nat</span><br><span class="line">iptables -t nat -P PREROUTING ACCEPT</span><br><span class="line">iptables -t nat -P POSTROUTING ACCEPT</span><br><span class="line">iptables -t nat -P OUTPUT ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 若有内部接口的存在 (双网卡) 开放成为路由器，且为 IP 路由器</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$INIF</span>"</span> != <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">    iptables -A INPUT -i <span class="variable">$INIF</span> -j ACCEPT</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$INNET</span>"</span> != <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> innet <span class="keyword">in</span> <span class="variable">$INNET</span>; <span class="keyword">do</span></span><br><span class="line">            iptables -t nat -A POSTROUTING -s <span class="variable">$innet</span> -o <span class="variable">$EXTIF</span> -j MASQUERADE</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 如果你的 MSN 一直无法连接，或者是某些网站 OK 某些网站不 OK，</span></span><br><span class="line"><span class="comment"># 可能是 MTU 的问题，那你可以将下面这一行取消注释来启动 MTU 限制范围</span></span><br><span class="line"><span class="comment"># iptables -A FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -m tcpmss \</span></span><br><span class="line"><span class="comment">#          --mss 1400:1536 -j TCPMSS --clamp-mss-to-pmtu</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. NAT 服务器后端的 LAN 内对外之服务器设置</span></span><br><span class="line"><span class="comment"># iptables -t nat -A PREROUTING -p tcp -i $EXTIF --dport 80 \</span></span><br><span class="line"><span class="comment">#          -j DNAT --to-destination 192.168.1.210:80 # WWW</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 特殊的功能，包括 Windows 远程桌面所产生的规则，假设桌面主机为 1.2.3.4</span></span><br><span class="line"><span class="comment"># iptables -t nat -A PREROUTING -p tcp -s 1.2.3.4  --dport 6000 \</span></span><br><span class="line"><span class="comment">#          -j DNAT --to-destination 192.168.100.10</span></span><br><span class="line"><span class="comment"># iptables -t nat -A PREROUTING -p tcp -s 1.2.3.4  --sport 3389 \</span></span><br><span class="line"><span class="comment">#          -j DNAT --to-destination 192.168.100.20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 最终将这些功能存储下来</span></span><br><span class="line">/etc/init.d/iptables save</span><br></pre></td></tr></table></figure><p>特别留意上面脚本的特殊字体部分，基本上，只要修改一下最上方的接口部分，就能够运作这个防火墙了。不过因为每个人的环境都不相同，因此在设置完成后，依旧需要测试一下才行。不然，出了问题可就麻烦了。再来看一下关于 <code>iptables.allow</code> 的内容。假如我要让一个 140.116.44.0/24 这个网络的所有主机来源可以进入本机主机的话，那么这个文件的内容可以写成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim iptables.allow</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 下面是填写允许进入本机的其他网络或主机</span></span><br><span class="line">iptables -A INPUT -i <span class="variable">$EXTIF</span> -s 140.116.44.0/24 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是关于阻挡的文件设置方法</span></span><br><span class="line">vim iptables.deny</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 下面填写的是你要阻挡的那个 IP</span></span><br><span class="line">iptables -A INPUT -i <span class="variable">$EXTIF</span> -s 140.116.44.254 -j DROP</span><br><span class="line"></span><br><span class="line">chmod 700 iptables.*</span><br></pre></td></tr></table></figure><p>将这3个文件的权限设置为 700 且只属于 root 的权限后，就能够直接执行 iptables.rule 了。不过要注意的是，在上面的案例当中，默认将所有的服务通道都关闭的。所以你必须要到本机防火墙的第 5 步骤 处将一些注释 (#) 取消才行。同样地，如果有其他更多的 port 想要开启时，同样需要增加额外的规则。</p><p>不过，还是如同前面所说的，这个 firewall 仅能提供基本的安全防护，其他的相关问题还需要再测试。此外，如果希望一开机就自动执行这个 script 的话，请将这个文件的完整文件名写入 <code>/etc/rc.d/rc.local</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.d/rc.local</span><br><span class="line">...(其他省略)...</span><br><span class="line"><span class="comment"># 1. Firewall</span></span><br><span class="line">/data/scripts/iptables/iptables.rule</span><br></pre></td></tr></table></figure><p>事实上，这个脚本的最下面已经加入写入防火墙默认规则文件的功能，所以只要执行一次，就拥有最正确的规则了。上述的 <code>rc.local</code> 仅是预防万一而已。上述 3 个文件请不要在 Windows 系统上面编辑后才传送到 Linux 上运行，因为 Windows 系统的换行符问题，将可能导致该文件无法执行。建议传送到 Linux 后可以利用 <code>dos2unix</code> 指令去转换换行符等，就不会有问题了</p><p>这就是一个最简单的防火墙。同时，这个防火墙还可以具有最简答的 IP 路由器的功能，也就是在 iptables.rule 这个文件中的第二部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iptables防火墙实例&quot;&gt;&lt;a href=&quot;#iptables防火墙实例&quot; class=&quot;headerlink&quot; title=&quot;iptables防火墙实例&quot;&gt;&lt;/a&gt;iptables防火墙实例&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;推荐使用脚本来编写防火墙， 然后通过 &lt;code&gt;/etc/init.d/iptables save&lt;/code&gt; 来将结果存储到 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 中去。而且此一特色还可以用在呼叫其他的 scripts ，可以让防火墙规则具有较为灵活的使用方式。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iptables笔记" scheme="http://www.gmlyo.com/categories/iptables%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iptables防火墙实例" scheme="http://www.gmlyo.com/tags/iptables%E9%98%B2%E7%81%AB%E5%A2%99%E5%AE%9E%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>iptables防火墙数据包过滤软件</title>
    <link href="http://www.gmlyo.com/2019/01/18/iptables%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99/"/>
    <id>http://www.gmlyo.com/2019/01/18/iptables防火墙规则/</id>
    <published>2019-01-17T17:49:41.000Z</published>
    <updated>2019-01-17T18:00:16.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iptables防火墙数据包过滤软件"><a href="#iptables防火墙数据包过滤软件" class="headerlink" title="iptables防火墙数据包过滤软件"></a>iptables防火墙数据包过滤软件</h1><h2 id="iptables-的表-table-与链-chain"><a href="#iptables-的表-table-与链-chain" class="headerlink" title="iptables 的表 (table) 与链 (chain)"></a>iptables 的表 (table) 与链 (chain)</h2><a id="more"></a><h3 id="Filter（过滤器）"><a href="#Filter（过滤器）" class="headerlink" title="Filter（过滤器）"></a>Filter（过滤器）</h3><p>主要跟进入 Linux 本机的数据包有关，是默认的 table。</p><ul><li>INPUT：主要与想要进入我们 Linux 本机的数据包有关。</li><li>OUTPUT：主要与我们 Linux 本机所要送出的数据包有关。</li><li>FORWARD：这个与 Linux 本机比较没有关系，他可以转递数据包到后端的计算机中，与下列 NAT 的 table 相关性较高。</li></ul><h3 id="NAT（地址转换）"><a href="#NAT（地址转换）" class="headerlink" title="NAT（地址转换）"></a>NAT（地址转换）</h3><p>是 Network Address Translation 的缩写， 这个表格主要在进行来源与目的之 IP 或 port 的转换，与 Linux 本机较无关，主要与 Linux 主机后的局域网络内计算机较有相关。</p><ul><li>PREROUTING：在进行路由判断之前所要进行的规则 (DNAT/REDIRECT)</li><li>POSTROUTING：在进行路由判断之后所要进行的规则 (SNAT/MASQUERADE)</li><li>OUTPUT：与发送出去的数据包有关</li></ul><h3 id="Mangle（破坏者）"><a href="#Mangle（破坏者）" class="headerlink" title="Mangle（破坏者）"></a>Mangle（破坏者）</h3><p>这个表格主要是与特殊的数据包的路由标志有关，早期仅有 PREROUTING 及 OUTPUT 链，不过从 kernel 2.4.18 之后加入了 INPUT 及 FORWARD 链。由于这个表格与特殊标志相关性较高，所以在我们讨论的这种单纯的环境当中，较少使用 Mangle 这个表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t tables] [-L] [-nv]</span><br><span class="line">选项与参数：</span><br><span class="line">-t  <span class="comment"># 后面接 table ，例如 nat 或 filter ，若省略此项目，则使用默认的 filter</span></span><br><span class="line">-L  <span class="comment"># 列出目前的 table 的规则</span></span><br><span class="line">-n  <span class="comment"># 不进行 IP 与 HOSTNAME 的反查，显示信息的速度会快很多</span></span><br><span class="line">-v  <span class="comment"># 列出更多的信息，包括通过该规则的数据包总位数、相关的网络接口等</span></span><br></pre></td></tr></table></figure><h2 id="列出-filter-table-三条链的规则"><a href="#列出-filter-table-三条链的规则" class="headerlink" title="列出 filter table 三条链的规则"></a>列出 filter table 三条链的规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n</span><br><span class="line">Chain INPUT (policy ACCEPT)    <span class="comment"># 针对 INPUT 链，且默认政策为可接受</span></span><br><span class="line">target  prot opt <span class="built_in">source</span>     destination    <span class="comment"># 说明栏</span></span><br><span class="line">ACCEPT  all  --  0.0.0.0/0  0.0.0.0/0   state RELATED,ESTABLISHED  <span class="comment"># 第 1 条规则</span></span><br><span class="line">ACCEPT  icmp --  0.0.0.0/0  0.0.0.0/0                              <span class="comment"># 第 2 条规则</span></span><br><span class="line">ACCEPT  all  --  0.0.0.0/0  0.0.0.0/0                              <span class="comment"># 第 3 条规则</span></span><br><span class="line">ACCEPT  tcp  --  0.0.0.0/0  0.0.0.0/0   state NEW tcp dpt:22       <span class="comment"># 以下类推</span></span><br><span class="line">REJECT  all  --  0.0.0.0/0  0.0.0.0/0   reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)    <span class="comment"># 针对 FORWARD 链，且默认政策为可接受</span></span><br><span class="line">target  prot opt <span class="built_in">source</span>     destination</span><br><span class="line">REJECT  all  --  0.0.0.0/0  0.0.0.0/0   reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)    <span class="comment"># 针对 OUTPUT 链，且默认政策为可接受</span></span><br><span class="line">target  prot opt <span class="built_in">source</span>     destination</span><br></pre></td></tr></table></figure><h2 id="列出-nat-table-三条链的规则"><a href="#列出-nat-table-三条链的规则" class="headerlink" title="列出 nat table 三条链的规则"></a>列出 nat table 三条链的规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -L -n</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure><p>上面的输出结果中，每一个 Chain 就是前面提到的每个链。Chain 那一行括号里面的 policy 就是默认的策略。</p><ul><li>target：代表进行的操作，ACCEPT 是放行，而 REJECT 则是拒绝，此外，尚有 DROP (丢弃) 的项目。</li><li>prot：代表使用的数据包协议，主要有 TCP、UDP 及 ICMP 3 种数据包格式。</li><li>opt：额外的选项说明。</li><li>source：代表此规则是针对哪个 <code>来源IP</code> 进行限制。</li><li>destination：代表此规则是针对哪个 <code>目标IP</code> 进行限制。</li></ul><p>第一个范例因为没有加上 <code>-t</code> 的选项，所以默认就是 filter 这个表格内的 INPUT、OUTPUT、FORWARD 三条链的规则。<br>若针对单机来说，INPUT 与 FORWARD 算是比较重要的管制防火墙链， 所以可以发现最后一条规则的政策是 REJECT（拒绝）！虽然 INPUT 与 FORWARD 的政策是放行 (ACCEPT)， 不过最后一条规则就已经将全部的数据包都拒绝了！</p><p>这个命令的查看只是做格式化的查看，要详细解释每个规则会比较不容易。举例来说， 我们将 INPUT 的 5 条规则依据输出结果来说明一下，结果会变成：</p><ol><li>只要是数据包状态为 RELATED、ESTABLISHED 就予以接受</li><li>只要数据包协议是 icmp 类型的，就予以放行</li><li>无论任何来源 (0.0.0.0/0) 且要去任何目标的数据包，不论任何数据包格式 (prot 为 all)，一律都接受</li><li>只要是传给 port 22 的主动式连接 TCP 数据包就接受</li><li>全部的数据包信息一律拒绝</li></ol><p>还有第 3 条规则怎么会所有的数据包信息都予以接受呢？如果都接受的话，那么后续的规则根本就没有用了！ 其实那条规则只是针对每台主机都有的内部循环测试网络 (lo) 接口，如果没有列出接口，那么我们就很容易搞错。所以，建议使用 <code>iptables-save</code> 这个指令来查看防火墙规则。因为 <code>iptables-save</code> 会列出完整的防火墙规则，只是没有格式化输出而已。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">iptables-save [-t table]</span><br><span class="line">选项与参数：</span><br><span class="line">-t  <span class="comment"># 可以仅针对某些表来输出，例如仅针对 NAT 或 Filter 等</span></span><br><span class="line"></span><br><span class="line">iptables-save</span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Fri Jul 22 15:51:52 2011</span></span><br><span class="line">*filter                       <span class="comment"># 星号开头的指的是表，这里为 Filter</span></span><br><span class="line">:INPUT ACCEPT [0:0]           <span class="comment"># 冒号开头的指的是链，3条内建的链</span></span><br><span class="line">:FORWARD ACCEPT [0:0]         <span class="comment"># 3条内建链的策略都是 ACCEPT</span></span><br><span class="line">:OUTPUT ACCEPT [680:100461]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT    <span class="comment"># 针对 INPUT 的规则</span></span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT      <span class="comment"># 这条很重要，针对本机内部接口开放</span></span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited    <span class="comment"># 针对 FORWARD 的规则</span></span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Fri Jul 22 15:51:52 2011</span></span><br></pre></td></tr></table></figure><p>上面输出结果来看，内容含有 <code>lo</code> 的那条规则当中，<code>-i lo</code> 指的就是由 <code>lo</code> 网卡进来的数据包。这样就清楚多了！因为有写到接口的关系，不像之前的 <code>iptables -L -n</code>。不过，既然这个规则不是我们想要的，那该如何修改呢？建议先删除规则再慢慢建立各个需要的规则。那如何清除规则？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t tables] [-FXZ]</span><br><span class="line">选项与参数：</span><br><span class="line">-F  <span class="comment"># 清除所有的已制订的规则</span></span><br><span class="line">-X  <span class="comment"># 除掉所有用户 "自定义" 的 chain (应该说的是 tables ）</span></span><br><span class="line">-Z  <span class="comment"># 将所有的 chain 的计数与流量统计都归零</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除本机防火墙 (filter) 的所有规则</span></span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br></pre></td></tr></table></figure><p>由于这三条命令会将本机防火墙的所有规则都清除，但不会改变默认策略 (policy) ， 所以如果你不是在本机使用这三行命令时，很可能会将自己挡在门外（若 INPUT 设置为 DROP 时）要注意！</p><p>一般来说，我们在重新定义防火墙的时候，都会先将规则给清除掉。我们前面说到的 <strong>防火墙的规则顺序是有特殊意义的</strong>，所以，应当先清除掉规则，然后再一条一条来设置会比较容易一些。接下来就谈谈如何定义默认策略。</p><h2 id="定义默认策略-policy"><a href="#定义默认策略-policy" class="headerlink" title="定义默认策略 (policy)"></a>定义默认策略 (policy)</h2><p>清除规则之后，接下来就是要设置规则的策略。还记得策略指的是什么吗？<strong>当数据包不在我们设置的规则之内时，则该数据包的通过与否，是以 Policy 的设置为准</strong>，在本机的默认策略中，假设对于内部的用户有信心的话， 那么 Filter 内的 INPUT 链方面可以定义的比较严格一点，而 FORWARD 与 OUTPUT 则可以制订得松一些。通常都是将 INPUT 的 policy 定义为 DROP ，其他两个则定义为 ACCEPT。 至于 NAT table 则暂时先不理会。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]</span><br><span class="line">选项与参数：</span><br><span class="line">-P      <span class="comment"># 定义策略 (Policy)。注意，这个 P 为大写</span></span><br><span class="line">ACCEPT  <span class="comment"># 该数据包可接受</span></span><br><span class="line">DROP    <span class="comment"># 该数据包直接丢弃，不会让 Client 端知道为何被丢弃</span></span><br></pre></td></tr></table></figure><blockquote><p>将本机的 INPUT 设置为 DROP ，其他设置为 ACCEPT</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line">iptables-save</span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Fri Jul 22 15:56:34 2011</span></span><br><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Fri Jul 22 15:56:34 2011</span></span><br><span class="line"><span class="comment"># 由于 INPUT 设置为 DROP 而又尚未有任何规则，所以上面的输出结果显示</span></span><br><span class="line"><span class="comment"># 所有的数据包都无法进入的主机，是不通的防火墙设置！(网络连接是双向的)</span></span><br></pre></td></tr></table></figure><p>看到输出的结果，INPUT 的设置被修改了，其他的 NAT table 3 条链的默认策略设置也是一样的方式。<br>例如：<br><code>iptables -t nat -P PREROUTING ACCEPT</code> 就设置了 NAT table 的 PREROUTING 链为可接受。默认策略设置完毕后，来聊一聊关于各规则的数据包基础比对设置。</p><h2 id="数据包的基础比对：IP，网络及接口设备"><a href="#数据包的基础比对：IP，网络及接口设备" class="headerlink" title="数据包的基础比对：IP，网络及接口设备"></a>数据包的基础比对：IP，网络及接口设备</h2><p>开始来进行防火墙规则的数据包比对设置。既然是因特网，那么我们就由最基础的 IP，网络及端口，亦即是 OSI 的第三层谈起，再来谈谈设备网卡的限制等等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">iptables [-AI 链名] [-io 网络接口] [-p 协议] [-s 来源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</span><br><span class="line">选项与参数：</span><br><span class="line">-AI 链名  <span class="comment"># 针对某的链进行规则的 "插入" 或 "累加"</span></span><br><span class="line">    -A   <span class="comment"># 新增加一条规则，该规则增加在原本规则的最后面。</span></span><br><span class="line">         <span class="comment"># 例如原本已经有四条规则，使用 -A 就可以加上第五条规则</span></span><br><span class="line">    -I   <span class="comment"># 插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。</span></span><br><span class="line">         <span class="comment"># 例如原本有四条规则，使用 -I 则该规则变成第一条，而原本 4 条变成 2~5 条</span></span><br><span class="line">    链   <span class="comment"># 有 INPUT、OUTPUT、FORWARD 等，此链名称又与 -io 有关，请看下面</span></span><br><span class="line"></span><br><span class="line">-io 网络接口  <span class="comment"># 设置数据包进出的接口规范</span></span><br><span class="line">    -i  <span class="comment"># 数据包所进入的那个网络接口，例如 eth0、lo 等接口。需与 INPUT 链配合</span></span><br><span class="line">    -o  <span class="comment"># 数据包所传出的那个网络接口，需与 OUTPUT 链配合</span></span><br><span class="line"></span><br><span class="line">-p 协定  <span class="comment"># 设置此规则适用于哪种数据包格式</span></span><br><span class="line">        <span class="comment"># 主要的数据包格式有：tcp、udp、icmp 及 all</span></span><br><span class="line"></span><br><span class="line">-s 来源 IP/网域  <span class="comment"># 设置此规则之数据包的来源项目，可指定单纯的 IP 或包括网域，例如：</span></span><br><span class="line">   IP    <span class="comment"># 192.168.0.100</span></span><br><span class="line">   网络  <span class="comment"># 192.168.0.0/24, 192.168.0.0/255.255.255.0 均可</span></span><br><span class="line">   <span class="comment"># 若规范为 “不许” 时，则加上 “!” 即可，例如：</span></span><br><span class="line">   -s ! 192.168.100.0/24  <span class="comment"># 表示不接受 192.168.100.0/24 发来的数据包</span></span><br><span class="line"></span><br><span class="line">-d 目标 IP/网络  <span class="comment"># 同 -s ，只不过这里指的是目标的 IP 或网络</span></span><br><span class="line"></span><br><span class="line">-j  <span class="comment"># 后面接操作，主要的操作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</span></span><br></pre></td></tr></table></figure><p>iptables 的基本参数就如同上面所示，仅谈到 IP 、网络与设备等的信息， 至于 TCP、UDP 数据包特有的端口 (port number) 与状态（如 SYN 标志）则在后面介绍。先让我们来看看最基础的几个规则，例如开放 lo 这个本机的接口以及某个 IP 来源。</p><blockquote><p>设定 lo 成为受信任的装置，亦即进出 lo 的封包都予以接受</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br></pre></td></tr></table></figure><p>仔细看上面并没有列出 -s、-d 等等的规则，这表示：<strong>不论数据包来自何处或去到哪里，只要是来自 lo 这个接口，就予以接受。</strong>这个概念挺重要的，就是“没有指定的项目，则表示该项目完全接受”。例如这个案例当中，关于 -s、-d 等的参数没有规定时，就代表不论什么值都会被接受。</p><p>这就是所谓的信任设备。假如主机有两张以太网卡，其中一张是对内部的网络，假设该网卡的代号为 eth1， 如果内部网络是可信任的，那么该网卡的进出数据包就通通会被接受，那就可以用 <code>iptables -A INPUT -i eth1 -j ACCEPT</code> 来将该设备设置为信任设备。不过，使用这个命令前要特别注意，因为这样等于该网卡没有任何防备了。</p><blockquote><p>只要是来自内网的 (192.168.100.0/24) 的数据包通通接受</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i eth1 -s 192.168.100.0/24 -j ACCEPT</span><br><span class="line"><span class="comment"># 由于是内网就接受，因此也可以称之为“信任网络”</span></span><br></pre></td></tr></table></figure><blockquote><p>只要是来自 192.168.100.10 就接受，但 192.168.100.230 这个“恶意”来源就丢弃</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i eth1 -s 192.168.100.10 -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth1 -s 192.168.100.230 -j DROP</span><br><span class="line"><span class="comment"># 针对单一 IP 来源，可视为信任主机或者是不信任的恶意来源</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iptables-save</span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Fri Jul 22 16:00:43 2011</span></span><br><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [17:1724]</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -s 192.168.100.0/24 -i eth1 -j ACCEPT</span><br><span class="line">-A INPUT -s 192.168.100.10/32 -i eth1 -j ACCEPT</span><br><span class="line">-A INPUT -s 192.168.100.230/32 -i eth1 -j DROP</span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Fri Jul 22 16:00:43 2011</span></span><br></pre></td></tr></table></figure><p>这就是最简单的防火墙规则的设置与查看方式。不过，在上面的案例中，其实也可以发现到有两条规则可能有问题，那就是上面的特殊字体圈起来的规则顺序。明明已经放行了 192.168.100.0/24，所以 192.168.100.230 的规则就不可能会被用到了！这就是防火墙设置的问题。那该怎么办？重写。那如果想要记录某个规则的记录怎么办？可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.2.200 -j LOG</span><br><span class="line">iptables -L -n</span><br><span class="line">target prot opt <span class="built_in">source</span>         destination</span><br><span class="line">LOG    all  --  192.168.2.200  0.0.0.0/0   LOG flags 0 level 4</span><br></pre></td></tr></table></figure><p>输出结果的最左边出现 LOG。只要有数据包来自 192.168.2.200 这个 IP 时，那么该数据包的相关信息就会被写入到内核日志文件，即 <code>/var/log/messages</code> 这个文件当中。<strong>然后该数据包会继续进行后续的规则比对。</strong>所以说，LOG 这个动作仅在进行记录而已，并不会影响到这个数据包的其他规则比对。接下来我们分别来看看 TCP、UDP 以及 ICMP 数据包的其他规则比对。</p><h2 id="TCP、UDP-的规则比对：针对端口设置"><a href="#TCP、UDP-的规则比对：针对端口设置" class="headerlink" title="TCP、UDP 的规则比对：针对端口设置"></a>TCP、UDP 的规则比对：针对端口设置</h2><p>网络中各种不同的数据包格式，TCP 与 UDP，比较特殊的就是那个端口 (port)，在 TCP 方面则另外有所谓的连接数据包状态，包括最常见的 SYN 主动连接的数据包格式。那么如何针对这两种数据包格式进行防火墙规则的设置呢？可以这样看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables [-AI 链] [-io 网络接口] [-p tcp,udp] \</span><br><span class="line">&gt; [-s 来源IP/网络] [--sport 端口范围] \</span><br><span class="line">&gt; [-d 目标IP/网络] [--dport 端口范围] -j [ACCEPT|DROP|REJECT]</span><br><span class="line">选项与参数：</span><br><span class="line">--sport 端口范围  <span class="comment"># 限制来源的端口号码，端口号码可以是连续的，例如 1024:65535</span></span><br><span class="line">--dport 端口范围  <span class="comment"># 限制目标的端口号码</span></span><br></pre></td></tr></table></figure><p>事实上就是多了 <code>--sport</code> 及 <code>--dport</code> 这两个选项，重点在 port 上面。不过需要特别注意，<strong>因为只有 TCP 与 UDP 数据包具有端口，因此要想使用 <code>--dport</code>、<code>--sport</code> 时，得要加上 <code>-p tcp</code> 或 <code>-p udp</code> 的参数才会成功。</strong>下面让我们来进行几个小测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要连接进入本机 port 21 的数据包都阻挡掉</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 21 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想连到本台主机的网上邻居 (upd port 137,138 tcp port 139,445) 就放行</span></span><br><span class="line">iptables -A INPUT -i eth0 -p udp --dport 137:138 -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 139 -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 445 -j ACCEPT</span><br></pre></td></tr></table></figure><p>我们不但可以利用 UDP 与 TCP 协议所拥有的端口号码来进行某些服务的开放或关闭，还可以综合处理。<br>例如，只要来自 192.168.1.0/24 的 1024:65535 端口的数据包，且想要连接到本机的 ssh port 就予以阻挡，可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.1.0/24 \</span><br><span class="line">&gt; --sport 1024:65534 --dport ssh -j DROP</span><br></pre></td></tr></table></figure><p>如果忘记加上 <code>-p tcp</code> 就使用了 <code>--dport</code> 时，会发生以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[root@www ~]<span class="comment"># iptables -A INPUT -i eth0 --dport 21 -j DROP iptables v1.4.7: unknown option `--dport' Try `iptables -h' or 'iptables --help' for more information.`</span></span><br></pre></td></tr></table></figure><p>你应该会觉得很奇怪，怎么 “–dport” 会是未知的参数 (arg) 呢？这是因为没有加上 <code>-p tcp</code> 或 <code>-p udp</code> 的缘故。这一点很重要。</p><p>除了端口之外，TCP 数据包还有特殊的标志。最常见的就是主动连接的 SYN 标志了。在 iptables 里面还支持 “–syn” 的处理方式，我们以下面的例子来说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将来自任何地方来源 port 1:1023 的主动连接到本机端的 1:1023 连接丢弃</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 1:1023 \</span><br><span class="line">&gt; --dport 1:1023 --syn -j DROP</span><br></pre></td></tr></table></figure><p>一般来说，Client 端启用的 port 都大于 1024，而 Server 端启用的端口都小于 1023。所以我们可以丢弃来自远程的小于 1023 的端口数据的主动连接，但不适用于 FTP 的主动连接中。</p><h2 id="iptables-外挂模块：mac-与-state"><a href="#iptables-外挂模块：mac-与-state" class="headerlink" title="iptables 外挂模块：mac 与 state"></a>iptables 外挂模块：mac 与 state</h2><p>在 kernel 2.2 以前使用 <code>ipchains</code> 管理防火墙时，通常会让系统管理员相当头痛。因为 <code>ipchains</code> 没有所谓的数据包状态模块，因此我们必须要针对数据包的进、出方向进行控制。例如，如果想要连接到远程主机的 port 22 时，必须要针对两条规则来设置：</p><ul><li>本机端的 1024:65535 到远程的 port 22 必须要放行 (OUTPUT 链)。</li><li>远程主机 port 22 到本机的 1024:65535 必须放行 (INPUT 链)。</li></ul><p>这会很麻烦。因为要连接到 10 部主机的 port 22 时，假设 OUTPUT 为默认开启 (ACCEPT)， 那么久需要填写 10 行规则，让那 10 台远程主机的 port 22 可以连接到本地端主机上。如果开启全部的 port 22，则又担心某些恶意主机会主动以 port 22 连接到本地主机。同理，如果要让本地端主机可以连到外部的 port 80 (WWW 服务)，那就更不得了。<strong>因为网络连接是双向的</strong>，一个很重要的概念！</p><p>iptables 可以帮我们免除这个困扰。它可以通过一个状态模块来分析<strong>这个想要进入的数据包是否为刚刚发出去的响应，</strong>如果是刚刚发出去的响应，那么就可以予以接受放行。这样就不用考虑远程主机是否连接进来的问题了。那如何实现呢？看看下面的语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT [-m state] [--state 状态]</span><br><span class="line">选项与参数：</span><br><span class="line">-m  <span class="comment"># 一些 iptables 的外挂模块，主要常见的有：</span></span><br><span class="line">     state  <span class="comment"># 状态模块</span></span><br><span class="line">     mac    <span class="comment"># 网络卡硬件地址 (hardware address)</span></span><br><span class="line">--state  <span class="comment"># 一些封包的状态，主要有：</span></span><br><span class="line">     INVALID     <span class="comment"># 无效的数据包，例如数据破损的数据包状态</span></span><br><span class="line">     ESTABLISHED <span class="comment"># 已经连接成功的连接状态</span></span><br><span class="line">     NEW         <span class="comment"># 想要新建立连接的数据包状态</span></span><br><span class="line">     RELATED     <span class="comment"># 这个最常用！表示这个数据包是与主机发送出去的数据包有关</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要已建立连接或与已发出请求相关数据包就予以通过，不合法的数据报包就丢弃</span></span><br><span class="line">iptables -A INPUT -m state \</span><br><span class="line">&gt; --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -m state --state INVALID -j DROP</span><br></pre></td></tr></table></figure><p>这样，iptables 就会主动分析出该数据包是否为响应状态，若是的话，就直接予以接受。这样不需要针对响应的数据包来撰写个别的防火墙规则了。下面我们继续谈一下 iptables 的另一个外挂， 那就是针对网卡来进行放行与防御：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对局域网络内的 aa:bb:cc:dd:ee:ff 主机开放其连接</span></span><br><span class="line">iptables -A INPUT -m mac --mac-source aa:bb:cc:dd:ee:ff \</span><br><span class="line">&gt; -j ACCEPT</span><br><span class="line">选项与参数：</span><br><span class="line">--mac-source  <span class="comment"># 就是来源主机的 MAC</span></span><br></pre></td></tr></table></figure><p>如果局域网当中有某些网络高手，老是可以通过修改 IP 去尝试通过路由器往外跑，那这时该怎么办？ 难道将整个局域网拒绝？并不需要的，可以通过之前谈到的 ARP 相关概念，去捕捉到那台主机的 MAC，然后通过以上这个机制，将该主机整个 DROP 掉即可。不管他改了什么 IP，除非他知道你是用网卡的 MAC 来管理，否则他是出不去的。</p><p>其实 MAC 也是可以伪装的，可以通过某些软件来修改网卡的 MAC。不过，这里我们是假设 MAC 是无法修改的情况来说明的。此外，MAC 是不能跨路由的，因此上述的案例中才特别说明是在局域网内，而不是指 Internet 外部的来源。</p><h2 id="ICMP-数据包规则的比对：针对是否响应-ping-来设计"><a href="#ICMP-数据包规则的比对：针对是否响应-ping-来设计" class="headerlink" title="ICMP 数据包规则的比对：针对是否响应 ping 来设计"></a>ICMP 数据包规则的比对：针对是否响应 ping 来设计</h2><p>在 ICMP 协议当中我们知道 ICMP 的类型很多，而且很多 ICMP 数据包的类型都是用来进行网络检测的。所以最好不要将所有的 ICMP 数据包都丢弃。如果主机不是作为路由器时，通常我们会把 ICMP type 8 (echo request) 拿掉，这样远程主机就不知道我们是否存在，也不会接受 ping 的响应。ICMP 数据包格式的处理是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT [-p icmp] [--icmp-type 类型] -j ACCEPT</span><br><span class="line">选项与参数：</span><br><span class="line">--icmp-type  <span class="comment"># 后面必须要接 ICMP 的数据包类型，也可以使用代号，</span></span><br><span class="line">              例如 8  代表 <span class="built_in">echo</span> request 的意思</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让 0,3,4,11,12,14,16,18 的 ICMP type 可以进入本机</span></span><br><span class="line">vim somefile</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">icmp_type=<span class="string">"0 3 4 11 12 14 16 18"</span></span><br><span class="line"><span class="keyword">for</span> typeicmp <span class="keyword">in</span> <span class="variable">$icmp_type</span>; <span class="keyword">do</span></span><br><span class="line">   iptables -A INPUT -i eth0 -p icmp --icmp-type <span class="variable">$typeicmp</span> -j ACCEPT</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">sh somefile</span><br></pre></td></tr></table></figure><p>这样就能够开放部分的 ICMP 数据包格式进入本机进行网络检测的工作了。不过，如果主机是作为局域网的路由器，那么建议 ICMP 数据包还是要全部放行才好，因为客户端检测网络时，常常会使用 ping 来测试到路由器的线路是否畅通。所以不要将路由器的 ICMP 关掉，会导致相关应用异常。</p><h2 id="简单的客户端防火墙设计与防火墙规则存储"><a href="#简单的客户端防火墙设计与防火墙规则存储" class="headerlink" title="简单的客户端防火墙设计与防火墙规则存储"></a>简单的客户端防火墙设计与防火墙规则存储</h2><p>经过上述的本机 iptables 语法分析后，接下来我们来想想，如果将 Linux 主机作为客户端且不提供网络服务时，应该如何设计防火墙呢？其实，只要分析一下 CentOS 默认的防火墙规则就会知道，理论上，应该要有的规则如下：</p><ol><li>规则归零：清除所有已经存在的规则 (iptables -F 等)</li><li>默认策略：除了将 INPUT 这个自定义链设为 DROP 外，其他默认为 ACCEPT。</li><li>信任本机：由于 lo 对本机来说是相当重要的，因此 lo 必须设置为信任设备。</li><li>回应数据包：让本机通过主动向外发出请求而响应的数据包可以进入本机 (ESTABLISHED、RELATED)</li><li>信任用户：这是非必要的，可在想要让本地网络的来源使用主机资源时设置。</li></ol><p>这就是最简单的防火墙，通过第 2 步骤可以阻挡所有远程的来源数据包，而通过第 4 步骤可以允许远程主机响应数据包进入主机，再让本机的 lo 这个内部循环设备放行，这样，一台 Client 专用的防火墙规则就配置好了。具体设置时，可以在某个 script 上面这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vim firewall.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin; <span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 清除规则</span></span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 设置策略</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3~5. 制订各项规则</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="comment"># iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 写入防火墙规则配置文件</span></span><br><span class="line">/etc/init.d/iptables save</span><br><span class="line"></span><br><span class="line">sh firewall.sh</span><br><span class="line">iptables: Saving firewall rules to /etc/sysconfig/iptables:[  OK  ]</span><br></pre></td></tr></table></figure><p>其实防火墙也是一个服务，并可以通过 <code>chkconfig --list iptables</code> 或 <code>systemctl -l status iptables</code> 去查看。因此，若要让这次修改的各种设置在下次开机时还保存，那就需要对 <code>/etc/init.d/iptables save</code> 这个指令加参数。 因此，现在将存储的操作写入 firewall.sh 脚本中，比较单纯些。通过以上设置，现在，Linux 主机已经有相当的保护了，只是如果想要作为服务器，或者是作为路由器，那就需要自行加上某些自定义的规则。</p><p><strong>Tips:</strong> 其实，如果你对 Linux 够熟悉的话，直接去修改 <code>/etc/sysconfig/iptables</code> 然后重启 iptables 这个服务，那防火墙规则就会在开机后持续存在了。</p><h2 id="IPv4-的核心管理功能：-proc-sys-net-ipv4"><a href="#IPv4-的核心管理功能：-proc-sys-net-ipv4" class="headerlink" title="IPv4 的核心管理功能：/proc/sys/net/ipv4/"></a>IPv4 的核心管理功能：/proc/sys/net/ipv4/</h2><p>除了 iptables 这个防火墙软件之外，Linux kernel 2.6 还提供了很多内核默认的攻击阻挡机制。由于是内核的网络功能，所以相关的设置数据都是放置在 <code>/proc/sys/net/ipv4/</code> 这个目录当中。 至于该目录下各个文件的详细资料，可以参考内核的说明文件（你得要先安装 kernel-doc 软件）：</p><ul><li>/usr/share/doc/kernel-doc-2.6.32/Documentation/networking/ip-sysctl.txt<br>鸟哥的网站上也放了一份备份：</li><li>http:/linux.vbird.org/linux_server/0250simple_firewall/ip-sysctl.txt<br>有兴趣的话应该要自行去查看。我们下面来介绍几个简单的文件。</li></ul><p><strong>1. /proc/sys/net/ipv4/tcp_syncookies</strong><br>我们在前面谈到所谓的阻断式服务 (DoS) 攻击法当中的一种方式，就是利用 TCP 数据包的 SYN 三次握手原理实现的，这种方式称为 SYN Flooding。那如何预防这种方式的攻击呢？我们可以启用内核的 SYN Cookie 模块。这个 SYN Cookie 模块可以在系统用来启动随机连接的端口 (1024:65535) 即将用完时自动启动。</p><p><strong>当启动 SYN Cookie 时，主机在发送 SYN/ACK 确认数据包前，会要求 Client 端在短时间内回复一个序号，这个序号包含许多原 SYN 数据包内的信息，包括 IP、port 等。若 Client 端可以回复正确的序号，那么主机就确定该数据包为可信的，因此会发送 SYN/ACK 数据包，否则就不理会此数据包。</strong></p><p>通过这一机制可以大大降低无效的 SYN 等待端口，避免 SYN Flooding 的 DoS 攻击。那么如何启动这个模块呢？很简单，这样做即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure><p>但是这个设置值由于违反 TCP 的三次握手（因为主机在发送 SYN/ACK 之前需要先等待 Client 的序号响应），所以可能会造成某些服务的延迟现象，例如 SMTP (Mail Server)。不过总的来说，这个设置值还是不错，<strong>只是不适合用在负载已经很高的服务器内。</strong>因为负载太高的主机有时会让内核误判遭受 SYN Flooding 的攻击。</p><p>如果是为了系统的 TCP 数据包连接优化，则可以参考 tcp_max_syn_backlog、tcp_synack_retries、tcp_abort_on_overflow 这几个设置值的意义。</p><p><strong>2. /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</strong></p><p>阻断式服务常见的是 SYN Flooding，不过，我们知道系统其实可以接受使用 ping 的响应，而 <a href="http://cn.linux.vbird.org/linux_server/0140networkcommand.php#ping" target="_blank" rel="noopener">ping</a> 的数据包数据量可以很大。想象一个状况，如果有个搞破坏的人使用 1000 台主机传送 ping 给你的主机，而且每个 ping 都高达数百 Kbytes 时，你的网络带宽会怎样？要么就是带宽被吃光，要么系统可能会宕机。这种方式分别被称为 ping flooding（不断发 ping）及 ping of death（发送大的 ping 数据包）。</p><p>那如何避免呢？取消 ICMP 类型 8 的 ICMP 数据包回应就是了。我们可以通过防火墙来阻挡，这也是建议的方式。当然也可以让内核自动取消 ping 的响应。不过，<strong>某些局域网络内常见的服务（例如动态 IP 分配 DHCP 协议）会使用 ping 的方式来侦测是否有重复的 IP，所以最好不要取消所有的 ping 响应比较好。</strong></p><p>内核取消 ping 回应的设置值有两个，分别是 <code>/proc/sys/net/ipv4</code> 内的 icmp_echo_ignore_broadcasts（仅有 ping broadcast 地址时才取消 ping 的回应）及 icmp_echo_ignore_all（全部的 ping 都不回应）。建议设置  icmp_echo_ignore_broadcasts。可以这么做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"1"</span> &gt; \</span><br><span class="line">&gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</span><br></pre></td></tr></table></figure><p><strong>3. /proc/sys/net/ipv4/conf/网络接口/*</strong></p><p>Linux 的内核还可以针对不同的网络接口进行不一样的参数设置。网络接口的相关设置放置在 <code>/proc/sys/net/ipv4/conf/</code> 中，每个接口都以接口代号做为其代表，例如 eth0 接口的相关设置数据在 <code>/proc/sys/net/ipv4/conf/eth0/</code> 内。那么网络接口的设置数据有哪些需要注意的呢？ 大概有下面这几个：</p><ul><li><p><strong>rp_filter</strong>：称为逆向路径过滤 (Reverse Path Filtering)，可以通过分析网络接口的路由信息，配合数据包的来源地址，来分析该数据包是否为合理。举例来说，你有两张网卡，eth0 为 192.168.1.10/24，eth1 为 public IP。那么当有一个数据包自称来自 eth1，但是其 IP 来源为 192.168.1.200，那这个数据包就不合理，应予以丢弃。这个设置值建议启动。</p></li><li><p><strong>log_martians</strong>：这个设置数据可以用来启动记录不合法的 IP 来源的功能，举例来说，包括来源为 0.0.0.0、127.x.x.x、及 Class E 的 IP 都是不合法的，因为这些来源的 IP 不应该应用于 Internet。记录的数据默认放置到内核放置的日志文件 <code>/var/log/messages</code>。</p></li><li><p><strong>accept_source_route</strong>：或许某些路由器会启动这个设置值，不过目前的设备很少使用到这种来源路由，可以取消这个设置值。</p></li><li><p><strong>accept_redirects</strong>：当你在同一个实体网络内架设一台路由器，但这个实体网络有两个 IP 网络，例如 192.168.0.0/24、 192.168.1.0/24。此时 192.168.0.100 想要向 192.168.1.100 传送信息时，路由器可能会传送一个 ICMP redirect 数据包告知 192.168.0.100 直接传送数据给 192.168.1.100 即可，而不需通过路由器。因为 192.168.0.100 与 192.168.1.100 确实是在同一个实体线路上（两者可以直接互通），所以路由器会告知来源 IP 使用最短路径去传递数据。但由于那两台主机在不同的 IP 网段，所以还是无法实际传递信息。这个设置也可能会产生一些轻微的安全风险，所以建议关闭。</p></li><li><p><strong>send_redirects</strong>：与上一个类似，只是此值为发送一个 ICMP redirect 数据包。同样建议关闭。</p></li></ul><p>虽然可以使用 <code>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/conf/???/rp_filter</code> 来启动这个项目，不过，比较建议修改系统设置值，即 <code>/etc/sysctl.conf</code> 这个文件。假设我们仅有 eth0 这个以太接口，而且上述的功能要全部启动，那可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line"><span class="comment"># Adding by VBird 2011/01/28</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line">net.ipv4.conf.all.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.eth0.rp_filter = 1</span><br><span class="line">net.ipv4.conf.lo.rp_filter = 1</span><br><span class="line">....(以下省略)....</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://cn.linux.vbird.org/linux_server/0250simple_firewall_3.php" target="_blank" rel="noopener">http://cn.linux.vbird.org/linux_server/0250simple_firewall_3.php</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iptables防火墙数据包过滤软件&quot;&gt;&lt;a href=&quot;#iptables防火墙数据包过滤软件&quot; class=&quot;headerlink&quot; title=&quot;iptables防火墙数据包过滤软件&quot;&gt;&lt;/a&gt;iptables防火墙数据包过滤软件&lt;/h1&gt;&lt;h2 id=&quot;iptables-的表-table-与链-chain&quot;&gt;&lt;a href=&quot;#iptables-的表-table-与链-chain&quot; class=&quot;headerlink&quot; title=&quot;iptables 的表 (table) 与链 (chain)&quot;&gt;&lt;/a&gt;iptables 的表 (table) 与链 (chain)&lt;/h2&gt;
    
    </summary>
    
      <category term="iptables笔记" scheme="http://www.gmlyo.com/categories/iptables%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iptables防火墙数据包过滤软件" scheme="http://www.gmlyo.com/tags/iptables%E9%98%B2%E7%81%AB%E5%A2%99%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%87%E6%BB%A4%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Django 2.x 后生成数据库表时的报错</title>
    <link href="http://www.gmlyo.com/2019/01/11/Django-2.x%E5%90%8E%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%97%B6%E7%9A%84%E6%8A%A5%E9%94%99/"/>
    <id>http://www.gmlyo.com/2019/01/11/Django-2.x后生成数据库表时的报错/</id>
    <published>2019-01-10T18:05:51.000Z</published>
    <updated>2019-01-10T18:25:57.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-2-x-后生成数据库表时的报错"><a href="#Django-2-x-后生成数据库表时的报错" class="headerlink" title="Django 2.x 后生成数据库表时的报错"></a>Django 2.x 后生成数据库表时的报错</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>使用 Ｄjango 2.1.1 的时候发现执行 makemigrations 和 migrate 是会报错，少位置参数 on_delete，查了一下是因为指定外键的方式不对。<br><code>TypeError: __init__() missing 1 required positional argument: &#39;on_delete&#39;</code></p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出版社</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 自增 id 主键</span></span><br><span class="line">    id = models.AutoField(primary_key=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 创建 varchar(64) 唯一的，不为空的字段</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>, null=<span class="keyword">False</span>, unique=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 书</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 自增 id 主键</span></span><br><span class="line">    id = models.AutoField(primary_key=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 创建 varchar(64) 唯一的，不为空的字段</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">64</span>, null=<span class="keyword">False</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 和出版社关联的的外键字段</span></span><br><span class="line">    publisher_id = models.ForeignKey(to=<span class="string">"Publisher"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在创建模型类关联外键时，报如下错误</p></blockquote><p><img src="https://i.loli.net/2019/01/11/5c378a8f568e0.png" alt="20190111020949.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: __init__() missing <span class="number">1</span> required positional argument: <span class="string">'on_delete'</span></span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将</span><br><span class="line">publisher_id = models.ForeignKey(to=<span class="string">"Publisher"</span>)</span><br><span class="line">改成</span><br><span class="line">publisher_id = models.ForeignKey(to=<span class="string">"Publisher"</span>, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><blockquote><p>即在外键值的后面加上 on_delete=models.CASCADE</p></blockquote><blockquote><p>原因：在 Django 2.0 后，定义外键和一对一关系的时候需要加 on_delete 选项，此参数为了避免两个表里的数据不一致问题。不然会报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: __init__() missing <span class="number">1</span> required positional argument: <span class="string">'on_delete'</span></span><br></pre></td></tr></table></figure><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user=models.OneToOneField(User)</span><br><span class="line">owner=models.ForeignKey(UserProfile)</span><br></pre></td></tr></table></figure><blockquote><p>需要改成</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在老版本这个参数（models.CASCADE）是默认值</span></span><br><span class="line">user=models.OneToOneField(User,on_delete=models.CASCADE)</span><br><span class="line"><span class="comment"># 在老版本这个参数（models.CASCADE）是默认值</span></span><br><span class="line">owner=models.ForeignKey(UserProfile,on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">on_delete 有 DO_NOTHING、CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET() 六个可选择的值</span><br><span class="line">DO_NOTHING   <span class="comment"># 什么都不做</span></span><br><span class="line">CASCADE      <span class="comment"># 此值设置，是级联删除</span></span><br><span class="line">PROTECT      <span class="comment"># 此值设置，是会报完整性错误</span></span><br><span class="line">SET_NULL     <span class="comment"># 此值设置，会把外键设置为null，前提是允许为null</span></span><br><span class="line">SET_DEFAULT  <span class="comment"># 此值设置，会把设置为外键的默认值</span></span><br><span class="line">SET()        <span class="comment"># 此值设置，会调用外面的值，可以是一个函数</span></span><br><span class="line"></span><br><span class="line">一般情况下使用 CASCADE 就可以了</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/phyger/p/8035253.html" target="_blank" rel="noopener">https://www.cnblogs.com/phyger/p/8035253.html</a><br><a href="https://blog.csdn.net/m0_38109046/article/details/82660038" target="_blank" rel="noopener">https://blog.csdn.net/m0_38109046/article/details/82660038</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Django-2-x-后生成数据库表时的报错&quot;&gt;&lt;a href=&quot;#Django-2-x-后生成数据库表时的报错&quot; class=&quot;headerlink&quot; title=&quot;Django 2.x 后生成数据库表时的报错&quot;&gt;&lt;/a&gt;Django 2.x 后生成数据库表时的报错&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用 Ｄjango 2.1.1 的时候发现执行 makemigrations 和 migrate 是会报错，少位置参数 on_delete，查了一下是因为指定外键的方式不对。&lt;br&gt;&lt;code&gt;TypeError: __init__() missing 1 required positional argument: &amp;#39;on_delete&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Django笔记" scheme="http://www.gmlyo.com/categories/Django%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Django 2.x 后生成数据库表时的报错" scheme="http://www.gmlyo.com/tags/Django-2-x-%E5%90%8E%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%97%B6%E7%9A%84%E6%8A%A5%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes部署rook+ceph存储系统</title>
    <link href="http://www.gmlyo.com/2019/01/07/Kubernetes%E9%83%A8%E7%BD%B2rook+ceph%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.gmlyo.com/2019/01/07/Kubernetes部署rook+ceph存储系统/</id>
    <published>2019-01-07T05:15:37.000Z</published>
    <updated>2019-01-07T09:17:18.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes部署rook-ceph存储系统"><a href="#Kubernetes部署rook-ceph存储系统" class="headerlink" title="Kubernetes部署rook+ceph存储系统"></a>Kubernetes部署rook+ceph存储系统</h1><a id="more"></a><h2 id="rook简介"><a href="#rook简介" class="headerlink" title="rook简介"></a>rook简介</h2><p>Rook官网：<a href="https://rook.io" target="_blank" rel="noopener">https://rook.io</a></p><h3 id="容器的持久化存储"><a href="#容器的持久化存储" class="headerlink" title="容器的持久化存储"></a>容器的持久化存储</h3><p>容器的持久化存储是保存容器存储状态的重要手段，存储插件会在容器里挂载一个基于网络或者其他机制的远程数据卷，使得在容器里创建的文件，实际上是保存在远程存储服务器上，或者以分布式的方式保存在多个节点上，而与当前宿主机没有任何绑定关系。这样，无论你在其他哪个宿主机上启动新的容器，都可以请求挂载指定的持久化存储卷，从而访问到数据卷里保存的内容。<br>由于 Kubernetes 本身的松耦合设计，绝大多数存储项目，比如 Ceph、GlusterFS、NFS 等，都可以为 Kubernetes 提供持久化存储能力。</p><h3 id="Ceph分布式存储系统"><a href="#Ceph分布式存储系统" class="headerlink" title="Ceph分布式存储系统"></a>Ceph分布式存储系统</h3><p>Ceph是一种高度可扩展的分布式存储解决方案，提供对象、文件和块存储。在每个存储节点上，您将找到Ceph存储对象的文件系统和Ceph OSD（对象存储守护程序）进程。在Ceph集群上，您还可以找到Ceph MON（监控）守护程序，它们确保Ceph集群保持高可用性。</p><h3 id="Rook"><a href="#Rook" class="headerlink" title="Rook"></a>Rook</h3><p>Rook 是一个开源的cloud-native storage编排, 提供平台和框架；为各种存储解决方案提供平台、框架和支持，以便与云原生环境本地集成。<br>Rook 将存储软件转变为自我管理、自我扩展和自我修复的存储服务，它通过自动化部署、引导、配置、置备、扩展、升级、迁移、灾难恢复、监控和资源管理来实现此目的。<br>Rook 使用底层云本机容器管理、调度和编排平台提供的工具来实现它自身的功能。<br>Rook 目前支持Ceph、NFS、Minio Object Store和CockroachDB。</p><p>Rook使用Kubernetes原语使Ceph存储系统能够在Kubernetes上运行。下图说明了Ceph Rook如何与Kubernetes集成：</p><p><img src="https://i.loli.net/2019/01/07/5c33112b3d5d3.png" alt="20190107164302.png"></p><p>随着Rook在Kubernetes集群中运行，Kubernetes应用程序可以挂载由Rook管理的块设备和文件系统，或者可以使用S3 / Swift API提供对象存储。Rook oprerator自动配置存储组件并监控群集，以确保存储处于可用和健康状态。<br>Rook oprerator是一个简单的容器，具有引导和监视存储集群所需的全部功能。oprerator将启动并监控ceph monitor pods和OSDs的守护进程，它提供基本的RADOS存储。oprerator通过初始化运行服务所需的pod和其他组件来管理池，对象存储（S3 / Swift）和文件系统的CRD。<br>oprerator将监视存储后台驻留程序以确保群集正常运行。Ceph mons将在必要时启动或故障转移，并在群集增长或缩小时进行其他调整。oprerator还将监视api服务请求的所需状态更改并应用更改。<br>Rook oprerator还创建了Rook agent。这些agent是在每个Kubernetes节点上部署的pod。每个agent都配置一个Flexvolume插件，该插件与Kubernetes的volume controller集成在一起。处理节点上所需的所有存储操作，例如附加网络存储设备，安装卷和格式化文件系统。</p><p><img src="https://i.loli.net/2019/01/07/5c331183ea477.png" alt="20190107164430.png"></p><p>该rook容器包括所有必需的Ceph守护进程和工具来管理和存储所有数据 - 数据路径没有变化。 rook并没有试图与Ceph保持完全的忠诚度。 许多Ceph概念（如placement groups和crush maps）都是隐藏的，因此您无需担心它们。 相反，Rook为管理员创建了一个简化的用户体验，包括物理资源，池，卷，文件系统和buckets。 同时，可以在需要时使用Ceph工具应用高级配置。<br>Rook在golang中实现。Ceph在C ++中实现，其中数据路径被高度优化。我们相信这种组合可以提供两全其美的效果。</p><h2 id="部署环境准备"><a href="#部署环境准备" class="headerlink" title="部署环境准备"></a>部署环境准备</h2><h3 id="官方参考："><a href="#官方参考：" class="headerlink" title="官方参考："></a>官方参考：</h3><p>root项目地址：<a href="https://github.com/rook/rook" target="_blank" rel="noopener">https://github.com/rook/rook</a><br>rook官方参考文档：<a href="https://rook.github.io/docs/rook/v0.9/ceph-quickstart.html" target="_blank" rel="noopener">https://rook.github.io/docs/rook/v0.9/ceph-quickstart.html</a></p><h3 id="kubernetes集群准备"><a href="#kubernetes集群准备" class="headerlink" title="kubernetes集群准备"></a>kubernetes集群准备</h3><p>kubeadm部署3节点kubernetes1.13.1集群（,master节点x1，node节点x2），集群部署参考：<br><a href="https://blog.csdn.net/networken/article/details/84991940" target="_blank" rel="noopener">https://blog.csdn.net/networken/article/details/84991940</a><br>集群节点信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.92.56 k8s-master</span><br><span class="line">192.168.92.57 k8s-node1</span><br><span class="line">192.168.92.58 k8s-node2</span><br></pre></td></tr></table></figure><p>在集群中至少有三个节点可用，满足ceph高可用要求，这里已配置master节点使其支持运行pod。</p><h3 id="rook使用存储方式"><a href="#rook使用存储方式" class="headerlink" title="rook使用存储方式"></a>rook使用存储方式</h3><p>rook默认使用所有节点的所有资源，rook operator自动在所有节点上启动OSD设备，Rook会用如下标准监控并发现可用设备：</p><ul><li>设备没有分区</li><li>设备没有格式化的文件系统</li></ul><p>Rook不会使用不满足以上标准的设备。另外也可以通过修改配置文件，指定哪些节点或者设备会被使用。</p><h3 id="添加新磁盘"><a href="#添加新磁盘" class="headerlink" title="添加新磁盘"></a>添加新磁盘</h3><p>这里在所有节点添加1块50GB的新磁盘：/dev/sdb，作为OSD盘，提供存储空间，添加完成后扫描磁盘，确保主机能够正常识别到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扫描 SCSI总线并添加 SCSI 设备</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> $(ls /sys/class/scsi_host) ; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"- - -"</span> &gt; /sys/class/scsi_host/<span class="variable">$host</span>/scan; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新扫描 SCSI 总线</span></span><br><span class="line"><span class="keyword">for</span> scsi_device <span class="keyword">in</span> $(ls /sys/class/scsi_device/); <span class="keyword">do</span> <span class="built_in">echo</span> 1 &gt; /sys/class/scsi_device/<span class="variable">$scsi_device</span>/device/rescan; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已添加的磁盘，能够看到sdb说明添加成功</span></span><br><span class="line">lsblk</span><br></pre></td></tr></table></figure><p>本次搭建的基本原理图：</p><p><img src="https://i.loli.net/2019/01/07/5c3316ba01858.png" alt="20190107170635.png"></p><p>无另外说明，以下全部操作都在master节点执行。</p><h2 id="部署Rook-Operator"><a href="#部署Rook-Operator" class="headerlink" title="部署Rook Operator"></a>部署Rook Operator</h2><p>克隆rook github仓库到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/rook/rook.git</span><br><span class="line"><span class="built_in">cd</span> rook/cluster/examples/kubernetes/ceph/</span><br></pre></td></tr></table></figure><p>执行yaml文件部署rook系统组件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ceph]$ kubectl apply -f operator.yaml</span><br><span class="line">namespace/rook-ceph-system created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/cephclusters.ceph.rook.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/cephfilesystems.ceph.rook.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/cephobjectstores.ceph.rook.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/cephobjectstoreusers.ceph.rook.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/cephblockpools.ceph.rook.io created</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/volumes.rook.io created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/rook-ceph-cluster-mgmt created</span><br><span class="line">role.rbac.authorization.k8s.io/rook-ceph-system created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/rook-ceph-global created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/rook-ceph-mgr-cluster created</span><br><span class="line">serviceaccount/rook-ceph-system created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/rook-ceph-system created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/rook-ceph-global created</span><br><span class="line">deployment.apps/rook-ceph-operator created</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure></p><p>如上所示，它会创建如下资源：</p><ol><li>namespace：rook-ceph-system，之后的所有rook相关的pod都会创建在该namespace下面</li><li>CRD：创建五个CRDs，.ceph.rook.io</li><li>role &amp; clusterrole：用户资源控制</li><li>serviceaccount：ServiceAccount资源，给Rook创建的Pod使用</li><li>deployment：rook-ceph-operator，部署rook ceph相关的组件</li></ol><p>部署rook-ceph-operator过程中，会触发以DaemonSet的方式在集群部署Agent和Discoverpods。<br>operator会在集群内的每个主机创建两个pod:rook-discover,rook-ceph-agent：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl get pod -n rook-ceph-system  -o wide</span><br><span class="line">NAME                                  READY   STATUS    RESTARTS   AGE     IP              NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">rook-ceph-agent-49w7t                 1/1     Running   0          7m48s   192.168.92.57   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-agent-dpxkq                 1/1     Running   0          111s    192.168.92.58   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-agent-wb6r8                 1/1     Running   0          7m48s   192.168.92.56   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-operator-85d64cfb99-2c78k   1/1     Running   0          9m3s    10.244.1.2      k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-discover-597sk                   1/1     Running   0          7m48s   10.244.0.4      k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-discover-7h89z                   1/1     Running   0          111s    10.244.2.2      k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-discover-hjdjt                   1/1     Running   0          7m48s   10.244.1.3      k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><h2 id="创建rook-Cluster"><a href="#创建rook-Cluster" class="headerlink" title="创建rook Cluster"></a>创建rook Cluster</h2><p>当检查到Rook operator, agent, and discover pods已经是running状态后，就可以部署roo cluster了。<br>执行yaml文件结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ceph]$ kubectl apply -f cluster.yaml </span><br><span class="line">namespace/rook-ceph created</span><br><span class="line">serviceaccount/rook-ceph-osd created</span><br><span class="line">serviceaccount/rook-ceph-mgr created</span><br><span class="line">role.rbac.authorization.k8s.io/rook-ceph-osd created</span><br><span class="line">role.rbac.authorization.k8s.io/rook-ceph-mgr-system created</span><br><span class="line">role.rbac.authorization.k8s.io/rook-ceph-mgr created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/rook-ceph-cluster-mgmt created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/rook-ceph-osd created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/rook-ceph-mgr created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/rook-ceph-mgr-system created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/rook-ceph-mgr-cluster created</span><br><span class="line">cephcluster.ceph.rook.io/rook-ceph created</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><p>如上所示，它会创建如下资源：</p><ol><li>namespace：rook-ceph，之后的所有Ceph集群相关的pod都会创建在该namespace下</li><li>serviceaccount：ServiceAccount资源，给Ceph集群的Pod使用</li><li>role &amp; rolebinding：用户资源控制</li><li>cluster：rook-ceph，创建的Ceph集群</li></ol><p>Ceph集群部署成功后，可以查看到的pods如下，其中osd数量取决于你的节点数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl get pod -n rook-ceph -o wide</span><br><span class="line">NAME                                     READY   STATUS      RESTARTS   AGE     IP           NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">rook-ceph-mgr<span class="_">-a</span>-8649f78d9b-hlg7t         1/1     Running     0          3h30m   10.244.2.6   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-mon<span class="_">-a</span>-7c7df4b5bb-984x8         1/1     Running     0          3h31m   10.244.0.5   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-mon-b-7b9bc8b6c4-8trmz         1/1     Running     0          3h31m   10.244.1.4   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-mon-c-54b5fb5955-5dgr7         1/1     Running     0          3h30m   10.244.2.5   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-osd-0-b9bb5df49-gt4vs          1/1     Running     0          3h29m   10.244.0.7   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-osd-1-9c6dbf797-2dg8p          1/1     Running     0          3h29m   10.244.2.8   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-osd-2-867ddc447d-xkh7k         1/1     Running     0          3h29m   10.244.1.6   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-osd-prepare-k8s-master-m8tvr   0/2     Completed   0          3h29m   10.244.0.6   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-osd-prepare-k8s-node1-jf7qz    0/2     Completed   1          3h29m   10.244.1.5   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">rook-ceph-osd-prepare-k8s-node2-tcqdl    0/2     Completed   0          3h29m   10.244.2.7   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><p>可以看出部署的Ceph集群有：</p><ol><li>Ceph Monitors：默认启动三个ceph-mon，可以在cluster.yaml里配置</li><li>Ceph Mgr：默认启动一个，可以在cluster.yaml里配置</li><li>Ceph OSDs：根据cluster.yaml里的配置启动，默认在所有的可用节点上启动<br>上述Ceph组件对应kubernetes的kind是deployment：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl -n rook-ceph get deployment</span><br><span class="line">NAME              READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">rook-ceph-mgr<span class="_">-a</span>   1/1     1            1           5h34m</span><br><span class="line">rook-ceph-mon<span class="_">-a</span>   1/1     1            1           5h36m</span><br><span class="line">rook-ceph-mon-b   1/1     1            1           5h35m</span><br><span class="line">rook-ceph-mon-c   1/1     1            1           5h35m</span><br><span class="line">rook-ceph-osd-0   1/1     1            1           5h34m</span><br><span class="line">rook-ceph-osd-1   1/1     1            1           5h34m</span><br><span class="line">rook-ceph-osd-2   1/1     1            1           5h34m</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><h3 id="删除Ceph集群"><a href="#删除Ceph集群" class="headerlink" title="删除Ceph集群"></a>删除Ceph集群</h3><p>如果要删除已创建的Ceph集群，可执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f cluster.yaml</span><br></pre></td></tr></table></figure><p>删除Ceph集群后，在之前部署Ceph组件节点的/var/lib/rook/目录，会遗留下Ceph集群的配置信息。<br>若之后再部署新的Ceph集群，先把之前Ceph集群的这些信息删除，不然启动monitor会失败；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat clean-rook-dir.sh</span><br><span class="line">hosts=(</span><br><span class="line">  k8s-master</span><br><span class="line">  k8s-node1</span><br><span class="line">  k8s-node2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;hosts[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  ssh <span class="variable">$host</span> <span class="string">"rm -rf /var/lib/rook/*"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="配置ceph-dashboard"><a href="#配置ceph-dashboard" class="headerlink" title="配置ceph dashboard"></a>配置ceph dashboard</h2><p>在cluster.yaml文件中默认已经启用了ceph dashboard，查看dashboard的service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl get service -n rook-ceph</span><br><span class="line">NAME                                     TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">rook-ceph-mgr                            ClusterIP   10.107.77.188    &lt;none&gt;        9283/TCP         3h33m</span><br><span class="line">rook-ceph-mgr-dashboard                  ClusterIP   10.96.135.98     &lt;none&gt;        8443/TCP         3h33m</span><br><span class="line">rook-ceph-mon<span class="_">-a</span>                          ClusterIP   10.105.153.93    &lt;none&gt;        6790/TCP         3h35m</span><br><span class="line">rook-ceph-mon-b                          ClusterIP   10.105.107.254   &lt;none&gt;        6790/TCP         3h34m</span><br><span class="line">rook-ceph-mon-c                          ClusterIP   10.104.1.238     &lt;none&gt;        6790/TCP         3h34m</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><p>rook-ceph-mgr-dashboard监听的端口是8443，创建nodeport类型的service以便集群外部访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f rook/cluster/examples/kubernetes/ceph/dashboard-external-https.yaml</span><br></pre></td></tr></table></figure><p>查看一下nodeport暴露的端口，这里是32483端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl get service -n rook-ceph | grep dashboard</span><br><span class="line">rook-ceph-mgr-dashboard                  ClusterIP   10.96.135.98     &lt;none&gt;        8443/TCP         3h37m</span><br><span class="line">rook-ceph-mgr-dashboard-external-https   NodePort    10.97.181.103    &lt;none&gt;        8443:32483/TCP   3h29m</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><p>获取Dashboard的登陆账号和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ MGR_POD=`kubectl get pod -n rook-ceph | grep mgr | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">[centos@k8s-master ~]$ kubectl -n rook-ceph logs <span class="variable">$MGR_POD</span> | grep password</span><br><span class="line">2019-01-03 05:44:00.585 7fced4782700  0 log_channel(audit) <span class="built_in">log</span> [DBG] : from=<span class="string">'client.4151 10.244.1.2:0/3446600469'</span> entity=<span class="string">'client.admin'</span> cmd=[&#123;<span class="string">"username"</span>: <span class="string">"admin"</span>, <span class="string">"prefix"</span>: <span class="string">"dashboard set-login-credentials"</span>, <span class="string">"password"</span>: <span class="string">"8v2AbqHDj6"</span>, <span class="string">"target"</span>: [<span class="string">"mgr"</span>, <span class="string">""</span>], <span class="string">"format"</span>: <span class="string">"json"</span>&#125;]: dispatch</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><p>找到username和password字段，我这里是admin，8v2AbqHDj6<br>打开浏览器输入任意一个Node的IP+nodeport端口，这里使用master节点 ip访问：<br><a href="https://192.168.92.56:32483" target="_blank" rel="noopener">https://192.168.92.56:32483</a></p><p><img src="https://i.loli.net/2019/01/07/5c33173371d46.png" alt="20190107170853.png"></p><p>登录后界面如下：</p><p><img src="https://i.loli.net/2019/01/07/5c33177a63986.png" alt="20190107171004.png"></p><p>查看hosts状态：<br>运行了1个mgr、3个mon和3个osd</p><p><img src="https://i.loli.net/2019/01/07/5c3317cb74250.png" alt="20190107171120.png"></p><p>查看monitors状态：</p><p><img src="https://i.loli.net/2019/01/07/5c3317ff6de9c.png" alt="20190107171219.png"></p><p>查看OSD状态<br>3个osd状态正常，每个容量50GB.</p><p><img src="https://i.loli.net/2019/01/07/5c331844071f9.png" alt="20190107171326.png"></p><h2 id="部署Ceph-toolbox"><a href="#部署Ceph-toolbox" class="headerlink" title="部署Ceph toolbox"></a>部署Ceph toolbox</h2><p>默认启动的Ceph集群，是开启Ceph认证的，这样你登陆Ceph组件所在的Pod里，是没法去获取集群状态，以及执行CLI命令，这时需要部署Ceph toolbox，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f rook/cluster/examples/kubernetes/ceph/ toolbox.yaml</span><br></pre></td></tr></table></figure><p>部署成功后，pod如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ceph]$  kubectl -n rook-ceph get pods -o wide | grep ceph-tools</span><br><span class="line">rook-ceph-tools-76c7d559b6-8w7bk         1/1     Running     0          11s     192.168.92.58   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[centos@k8s-master ceph]$</span><br></pre></td></tr></table></figure><p>然后可以登陆该pod后，执行Ceph CLI命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ceph]$ kubectl -n rook-ceph <span class="built_in">exec</span> -it rook-ceph-tools-76c7d559b6-8w7bk bash</span><br><span class="line">bash: warning: setlocale: LC_CTYPE: cannot change locale (en_US.UTF-8): No such file or directory</span><br><span class="line">bash: warning: setlocale: LC_COLLATE: cannot change locale (en_US.UTF-8): No such file or directory</span><br><span class="line">bash: warning: setlocale: LC_MESSAGES: cannot change locale (en_US.UTF-8): No such file or directory</span><br><span class="line">bash: warning: setlocale: LC_NUMERIC: cannot change locale (en_US.UTF-8): No such file or directory</span><br><span class="line">bash: warning: setlocale: LC_TIME: cannot change locale (en_US.UTF-8): No such file or directory</span><br><span class="line">[root@k8s-node2 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>查看ceph集群状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node2 /]<span class="comment"># ceph status</span></span><br><span class="line">  cluster:</span><br><span class="line">    id:     abddff95-5fa0-47dc-a001-7fb291a42bc6</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum c,b,a</span><br><span class="line">    mgr: a(active)</span><br><span class="line">    osd: 3 osds: 3 up, 3 <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   1 pools, 100 pgs</span><br><span class="line">    objects: 0  objects, 0 B</span><br><span class="line">    usage:   12 GiB used, 129 GiB / 141 GiB avail</span><br><span class="line">    pgs:     100 active+clean</span><br><span class="line"> </span><br><span class="line">[root@k8s-node2 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>查看ceph配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node2 /]<span class="comment"># cd /etc/ceph/</span></span><br><span class="line">[root@k8s-node2 ceph]<span class="comment"># ll</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r--r-- 1 root root 121 Jan  3 11:28 ceph.conf</span><br><span class="line">-rw-r--r-- 1 root root  62 Jan  3 11:28 keyring</span><br><span class="line">-rw-r--r-- 1 root root  92 Sep 24 18:15 rbdmap</span><br><span class="line">[root@k8s-node2 ceph]<span class="comment"># cat ceph.conf </span></span><br><span class="line">[global]</span><br><span class="line">mon_host = 10.104.1.238:6790,10.105.153.93:6790,10.105.107.254:6790</span><br><span class="line"></span><br><span class="line">[client.admin]</span><br><span class="line">keyring = /etc/ceph/keyring</span><br><span class="line">[root@k8s-node2 ceph]<span class="comment"># cat keyring</span></span><br><span class="line">[client.admin]</span><br><span class="line">key = AQBjoC1cXKJ7KBAA3ZnhWyxvyGa8+fnLFK7ykw==</span><br><span class="line">[root@k8s-node2 ceph]<span class="comment"># cat rbdmap </span></span><br><span class="line"><span class="comment"># RbdDevice             Parameters</span></span><br><span class="line"><span class="comment">#poolname/imagename     id=client,keyring=/etc/ceph/ceph.client.keyring</span></span><br><span class="line">[root@k8s-node2 ceph]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="rook提供RBD服务"><a href="#rook提供RBD服务" class="headerlink" title="rook提供RBD服务"></a>rook提供RBD服务</h2><p>rook可以提供以下3类型的存储：<br> Block: Create block storage to be consumed by a pod<br> Object: Create an object store that is accessible inside or outside the Kubernetes cluster<br> Shared File System: Create a file system to be shared across multiple pods<br>在提供（Provisioning）块存储之前，需要先创建StorageClass和存储池。K8S需要这两类资源，才能和Rook交互，进而分配持久卷（PV）。<br>在kubernetes集群里，要提供rbd块设备服务，需要有如下步骤：</p><ol><li>创建rbd-provisioner pod</li><li>创建rbd对应的storageclass</li><li>创建pvc，使用rbd对应的storageclass</li><li>创建pod使用rbd pvc</li></ol><p>通过rook创建Ceph Cluster之后，rook自身提供了rbd-provisioner服务，所以我们不需要再部署其provisioner。<br>备注：代码位置pkg/operator/ceph/provisioner/provisioner.go</p><h3 id="创建pool和StorageClass"><a href="#创建pool和StorageClass" class="headerlink" title="创建pool和StorageClass"></a>创建pool和StorageClass</h3><p>查看storageclass.yaml的配置（默认）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ vim rook/cluster/examples/kubernetes/ceph/storageclass.yaml</span><br><span class="line">apiVersion: ceph.rook.io/v1</span><br><span class="line">kind: CephBlockPool</span><br><span class="line">metadata:</span><br><span class="line">  name: replicapool</span><br><span class="line">  namespace: rook-ceph</span><br><span class="line">spec:</span><br><span class="line">  replicated:</span><br><span class="line">    size: 1</span><br><span class="line">---</span><br><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">   name: rook-ceph-block</span><br><span class="line">provisioner: ceph.rook.io/block</span><br><span class="line">parameters:</span><br><span class="line">  blockPool: replicapool</span><br><span class="line">  <span class="comment"># Specify the namespace of the rook cluster from which to create volumes.</span></span><br><span class="line">  <span class="comment"># If not specified, it will use `rook` as the default namespace of the cluster.</span></span><br><span class="line">  <span class="comment"># This is also the namespace where the cluster will be</span></span><br><span class="line">  clusterNamespace: rook-ceph</span><br><span class="line">  <span class="comment"># Specify the filesystem type of the volume. If not specified, it will use `ext4`.</span></span><br><span class="line">  fstype: xfs</span><br><span class="line">  <span class="comment"># (Optional) Specify an existing Ceph user that will be used for mounting storage with this StorageClass.</span></span><br><span class="line">  <span class="comment">#mountUser: user1</span></span><br><span class="line">  <span class="comment"># (Optional) Specify an existing Kubernetes secret name containing just one key holding the Ceph user secret.</span></span><br><span class="line">  <span class="comment"># The secret must exist in each namespace(s) where the storage will be consumed.</span></span><br><span class="line">  <span class="comment">#mountSecret: ceph-user1-secret</span></span><br></pre></td></tr></table></figure><p>配置文件中包含了一个名为replicapool的存储池，和名为rook-ceph-block的storageClass。</p><p>运行yaml文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f /rook/cluster/examples/kubernetes/ceph/storageclass.yaml</span><br></pre></td></tr></table></figure><p>查看创建的storageclass：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl get storageclass</span><br><span class="line">NAME              PROVISIONER          AGE</span><br><span class="line">rook-ceph-block   ceph.rook.io/block   171m</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure></p><p>登录ceph dashboard查看创建的存储池：</p><p><img src="https://i.loli.net/2019/01/07/5c331875b85d2.png" alt="20190107171417.png"></p><h3 id="使用存储"><a href="#使用存储" class="headerlink" title="使用存储"></a>使用存储</h3><p>以官方wordpress示例为例，创建一个经典的wordpress和mysql应用程序来使用Rook提供的块存储，这两个应用程序都将使用Rook提供的block volumes。<br>查看yaml文件配置，主要看定义的pvc和挂载volume部分，以wordpress.yaml为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ cat rook/cluster/examples/kubernetes/wordpress.yaml </span><br><span class="line">......</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: wp-pv-claim</span><br><span class="line">  labels:</span><br><span class="line">    app: wordpress</span><br><span class="line">spec:</span><br><span class="line">  storageClassName: rook-ceph-block</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 20Gi</span><br><span class="line">---</span><br><span class="line">......</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: wordpress-persistent-storage</span><br><span class="line">          mountPath: /var/www/html</span><br><span class="line">      volumes:</span><br><span class="line">      - name: wordpress-persistent-storage</span><br><span class="line">        persistentVolumeClaim:</span><br><span class="line">          claimName: wp-pv-claim</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><p>yaml文件里定义了一个名为wp-pv-claim的pvc，指定storageClassName为rook-ceph-block，申请的存储空间大小为20Gi。最后一部分创建了一个名为wordpress-persistent-storage的volume，并且指定 claimName为pvc的名称，最后将volume挂载到pod的/var/lib/mysql目录下。<br>启动mysql和wordpress：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f rook/cluster/examples/kubernetes/mysql.yaml</span><br><span class="line">kubectl apply -f rook/cluster/examples/kubernetes/wordpress.yaml</span><br></pre></td></tr></table></figure><p>这2个应用都会创建一个块存储卷，并且挂载到各自的pod中，查看声明的pvc和pv：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl get pvc</span><br><span class="line">NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS      AGE</span><br><span class="line">mysql-pv-claim   Bound    pvc-5bfbe28e-0fc9-11e9-b90d-000c291c25f3   20Gi       RWO            rook-ceph-block   32m</span><br><span class="line">wp-pv-claim      Bound    pvc-5f56c6d6-0fc9-11e9-b90d-000c291c25f3   20Gi       RWO            rook-ceph-block   32m</span><br><span class="line">[centos@k8s-master ~]$ kubectl get pv</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                    STORAGECLASS      REASON   AGE</span><br><span class="line">pvc-5bfbe28e-0fc9-11e9-b90d-000c291c25f3   20Gi       RWO            Delete           Bound    default/mysql-pv-claim   rook-ceph-block            32m</span><br><span class="line">pvc-5f56c6d6-0fc9-11e9-b90d-000c291c25f3   20Gi       RWO            Delete           Bound    default/wp-pv-claim      rook-ceph-block            32m</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><p>注意：这里的pv会自动创建，当提交了包含 StorageClass 字段的 PVC 之后，Kubernetes 就会根据这个 StorageClass 创建出对应的 PV，这是用到的是Dynamic Provisioning机制来动态创建pv，PV 支持 Static 静态请求，和动态创建两种方式。<br>在Ceph集群端检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ceph]$ kubectl -n rook-ceph <span class="built_in">exec</span> -it rook-ceph-tools-76c7d559b6-8w7bk bash</span><br><span class="line">......</span><br><span class="line">[root@k8s-node2 /]<span class="comment"># rbd info -p replicapool pvc-5bfbe28e-0fc9-11e9-b90d-000c291c25f3 </span></span><br><span class="line">rbd image <span class="string">'pvc-5bfbe28e-0fc9-11e9-b90d-000c291c25f3'</span>:</span><br><span class="line">        size 20 GiB <span class="keyword">in</span> 5120 objects</span><br><span class="line">        order 22 (4 MiB objects)</span><br><span class="line">        id: 88156b8b4567</span><br><span class="line">        block_name_prefix: rbd_data.88156b8b4567</span><br><span class="line">        format: 2</span><br><span class="line">        features: layering</span><br><span class="line">        op_features: </span><br><span class="line">        flags: </span><br><span class="line">        create_timestamp: Fri Jan  4 02:35:12 2019</span><br><span class="line">[root@k8s-node2 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>登陆 pod 检查 rbd 设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl get pod -o wide</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE    IP            NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">wordpress-7b6c4c79bb-t5pst         1/1     Running   0          135m   10.244.1.16   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">wordpress-mysql-6887bf844f-9pmg8   1/1     Running   0          135m   10.244.2.14   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">[centos@k8s-master ~]$ </span><br><span class="line"></span><br><span class="line">[centos@k8s-master ~]$ kubectl <span class="built_in">exec</span> -it wordpress-7b6c4c79bb-t5pst bash</span><br><span class="line">root@wordpress-7b6c4c79bb-t5pst:/var/www/html<span class="comment">#</span></span><br><span class="line">root@wordpress-7b6c4c79bb-t5pst:/var/www/html<span class="comment">#  mount | grep rbd</span></span><br><span class="line">/dev/rbd0 on /var/www/html <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,sunit=8192,swidth=8192,noquota)</span><br><span class="line">root@wordpress-7b6c4c79bb-t5pst:/var/www/html<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">......</span><br><span class="line">/dev/rbd0                 20G   59M   20G   1% /var/www/html</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>登录 ceph dashboard 查看创建的 images</p><p><img src="https://i.loli.net/2019/01/07/5c3318af28906.png" alt="20190107171515.png"></p><p>一旦 Wordpress 和 mysql pods 处于运行状态，获取 Wordpress 应用程序的集群IP并使用浏览器访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[centos@k8s-master ~]$ kubectl get svc wordpress</span><br><span class="line">NAME        TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">wordpress   LoadBalancer   10.98.178.189   &lt;pending&gt;     80:30001/TCP   136m</span><br><span class="line">[centos@k8s-master ~]$</span><br></pre></td></tr></table></figure><p>访问Wordpress：</p><p><img src="https://i.loli.net/2019/01/07/5c3318e232c65.png" alt="20190107171606.png"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/networken/article/details/85772418" target="_blank" rel="noopener">https://blog.csdn.net/networken/article/details/85772418</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kubernetes部署rook-ceph存储系统&quot;&gt;&lt;a href=&quot;#Kubernetes部署rook-ceph存储系统&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes部署rook+ceph存储系统&quot;&gt;&lt;/a&gt;Kubernetes部署rook+ceph存储系统&lt;/h1&gt;
    
    </summary>
    
      <category term="Kubernetes笔记" scheme="http://www.gmlyo.com/categories/Kubernetes%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Kubernetes部署rook+ceph存储系统" scheme="http://www.gmlyo.com/tags/Kubernetes%E9%83%A8%E7%BD%B2rook-ceph%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 使用 Tomcat APR 模式</title>
    <link href="http://www.gmlyo.com/2019/01/02/SpringBoot%E4%BD%BF%E7%94%A8TomcatAPR%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.gmlyo.com/2019/01/02/SpringBoot使用TomcatAPR模式/</id>
    <published>2019-01-02T03:19:20.000Z</published>
    <updated>2019-01-02T04:12:03.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-使用-Tomcat-APR-模式"><a href="#SpringBoot-使用-Tomcat-APR-模式" class="headerlink" title="SpringBoot 使用 Tomcat APR 模式"></a>SpringBoot 使用 Tomcat APR 模式</h1><a id="more"></a><blockquote><p>SpringBoot 内置的是 Tomcat Embed 容器，就是把 Tomcat 打包成一个 jar包库 来使用，直接运行 Application 就可以启动 Web服务器。本质没有区别，默认独立的 Tomcat 性能高于 SpringBoot 内置的 Tomcat。因为独立的 Tomcat 很多都配置了 APR 模式特性，大多数比较的时候 SpringBoot 内置的 Tomcat 并没有开启这个模式。可以选择自己启动这个特性。</p></blockquote><blockquote><p>从 GitHub 上的讨论看，如果需要 TLS 支持，使用 APR 是比较好的。否则没必要使用 APR，未来 APR 在 Tomcat 10 中可能会被移除。<br><a href="https://github.com/spring-projects/spring-boot/pull/10079" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/pull/10079</a></p></blockquote><h2 id="在-Tomcat-中提供了三种方式：BIO、NIO、APR。"><a href="#在-Tomcat-中提供了三种方式：BIO、NIO、APR。" class="headerlink" title="在 Tomcat 中提供了三种方式：BIO、NIO、APR。"></a>在 Tomcat 中提供了三种方式：BIO、NIO、APR。</h2><h3 id="BIO-模式"><a href="#BIO-模式" class="headerlink" title="BIO 模式"></a>BIO 模式</h3><blockquote><p>采用 Java IO 技术，单线程处理单请求（Tomcat7以下默认）<br>Tomcat 7 以下的版本都是 BIO，就是一个请求是一个独立的线程。不能适用高并发的场景。阻塞式 I/O，采用传统的 java I/O 进行操作，该模式下每个请求都会创建一个线程，适用于并发量小的场景</p></blockquote><h3 id="NIO-模式"><a href="#NIO-模式" class="headerlink" title="NIO 模式"></a>NIO 模式</h3><blockquote><p>采用 Java NIO 技术，少量线程处理大量请求（Tomcat8以上默认）<br>Tomcat 8 以上的版本，默认都是 NIO。同步非阻塞，比传统 BIO 能更好的支持大并发，Tomcat 8.0 后默认采用该模式</p></blockquote><h3 id="APR-模式"><a href="#APR-模式" class="headerlink" title="APR 模式"></a>APR 模式</h3><blockquote><p>APR(Apache Portable Runtime)<br>采用 JNI 技术，从操作层面解决 I/O 阻塞问题，适合高并发场景<br>APR 的整体模式还是非阻塞 I/O，实现的线程模型也是按照 NIO 的标准模型实现的，<br>APR 是一种基于 JNI 形式调用http服务器的核心动态链接库来处理的文件和网络读写模式（文件读取和网络传输操作）。需要预先编译安装 APR库，现在很多高版本的 Tomcat 默认都走它了。在 Tomcat 中配置，很好配置，直接修改 protocol 就可以了。但是在 SpringBoot 中，配置是在 Java 代码中写的。<br>从官方文档 <a href="http://apr.apache.org/docs/apr/1.6/modules.html" target="_blank" rel="noopener">http://apr.apache.org/docs/apr/1.6/modules.html</a><br>可以看到 APR 根据不同操作系统，分别用 C 重写了大部分IO和系统线程操作模块，<br>这就是为什么 APR 在不改动代码的情况下能够提升。</p></blockquote><h2 id="SpringBoot-开启-APR-模式"><a href="#SpringBoot-开启-APR-模式" class="headerlink" title="SpringBoot 开启 APR 模式"></a>SpringBoot 开启 APR 模式</h2><blockquote><p>在 SpringBoot 中内嵌的 Tomcat 默认启动开启的是 NIO 模式，这里如果我们要在 Linux 内核的系统上使用 APR 模式，那么需要安装一些 lib库，可以通过 rpm -q | grep apr 来查看是否安装了 apr，如果安装了则不再需要安装。</p></blockquote><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install apr-devel gcc gcc-devel openssl openssl-devel expat-devel</span><br></pre></td></tr></table></figure><h2 id="OpenSSL-安装"><a href="#OpenSSL-安装" class="headerlink" title="OpenSSL 安装"></a>OpenSSL 安装</h2><blockquote><p>OpenSSL 需要版本大于 1.0.2，如果不使用 https openssl 也可以不安装，就是在启动的时候会报 OpenSSL 的错误，直接忽视就可以了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OpenSSL 下载地址</span></span><br><span class="line">https://www.openssl.org/<span class="built_in">source</span>/</span><br><span class="line"></span><br><span class="line">wget -c https://www.openssl.org/<span class="built_in">source</span>/openssl-1.1.1a.tar.gz</span><br></pre></td></tr></table></figure><h3 id="安装-OpenSSL"><a href="#安装-OpenSSL" class="headerlink" title="安装 OpenSSL"></a>安装 OpenSSL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf openssl-1.1.1a.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssl-1.1.1a/</span><br><span class="line">./config --prefix=/usr/<span class="built_in">local</span>/openssl</span><br><span class="line">./config -t</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="将-openssl-的-lib-加入系统-ldconfig-中"><a href="#将-openssl-的-lib-加入系统-ldconfig-中" class="headerlink" title="将 openssl 的 lib 加入系统 ldconfig 中"></a>将 openssl 的 lib 加入系统 ldconfig 中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ld.so.conf.d/openssl.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/openssl/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载一下</span></span><br><span class="line">ldconfig -v</span><br><span class="line">ldconfig -v | grep libssl</span><br></pre></td></tr></table></figure><h3 id="查看-OpenSSL-版本"><a href="#查看-OpenSSL-版本" class="headerlink" title="查看 OpenSSL 版本"></a>查看 OpenSSL 版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/openssl/</span><br><span class="line">./bin/openssl version -a</span><br><span class="line">OpenSSL 1.1.1a  20 Nov 2018</span><br><span class="line">built on: Wed Jan  2 02:19:47 2019 UTC</span><br><span class="line">platform: linux-x86_64</span><br><span class="line">options:  bn(64,64) rc4(16x,int) des(int) idea(int) blowfish(ptr) </span><br><span class="line">compiler: gcc -fPIC -pthread -m64 -Wa,--noexecstack -Wall -O3 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DNDEBUG</span><br><span class="line">OPENSSLDIR: <span class="string">"/usr/local/openssl/ssl"</span></span><br><span class="line">ENGINESDIR: <span class="string">"/usr/local/openssl/lib/engines-1.1"</span></span><br><span class="line">Seeding <span class="built_in">source</span>: os-specific</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果遇到以下错误</span></span><br><span class="line">openssl: error <span class="keyword">while</span> loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory</span><br><span class="line">openssl: error <span class="keyword">while</span> loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能是由于 OpenSSL 库的位置不正确造成的</span></span><br><span class="line"><span class="comment"># 做一下软链接，就好了</span></span><br><span class="line">ln -svnf /usr/<span class="built_in">local</span>/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1</span><br><span class="line">ln -svnf /usr/<span class="built_in">local</span>/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile.d/openssl.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> OPENSSL_HOME=/usr/<span class="built_in">local</span>/openssl</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$OPENSSL_HOME</span>/bin</span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> profile</span><br><span class="line">openssl version -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或把原来的命令备份一下，做个软链接</span></span><br><span class="line">ll -h /usr/bin/openssl</span><br><span class="line">mv /usr/bin/openssl&#123;,_bak&#125;</span><br><span class="line">mv /usr/include/openssl&#123;,openssl_bak&#125;</span><br><span class="line">ln -svnf /usr/<span class="built_in">local</span>/openssl/bin/openssl /usr/bin/openssl</span><br><span class="line">ln -svnf /usr/<span class="built_in">local</span>/openssl/include/openssl /usr/include/openssl</span><br></pre></td></tr></table></figure><h2 id="APR-安装"><a href="#APR-安装" class="headerlink" title="APR 安装"></a>APR 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># APR 下载地址</span></span><br><span class="line">http://apr.apache.org/download.cgi</span><br></pre></td></tr></table></figure><h3 id="安装-apr"><a href="#安装-apr" class="headerlink" title="安装 apr"></a>安装 apr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/tools/</span><br><span class="line">tar -zxvf apr-1.6.5.tar.gz</span><br><span class="line"><span class="built_in">cd</span> apr-1.6.5/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否符合安装条件并配置安装参数，检查是否缺失类库，一般来说如果安装的不是精简版系统都是能顺利通过的</span></span><br><span class="line">./configure \</span><br><span class="line">--prefix=/usr/<span class="built_in">local</span>/apr</span><br><span class="line"><span class="comment"># 报错信息</span></span><br><span class="line">config.status: executing libtool commands</span><br><span class="line">rm: cannot remove <span class="string">'libtoolT'</span>: No such file or directory</span><br><span class="line">config.status: executing default commands</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方法</span></span><br><span class="line"><span class="comment"># 编辑 configure 文件</span></span><br><span class="line"><span class="built_in">cd</span> apr-1.6.5/</span><br><span class="line">vim configure</span><br><span class="line">把 <span class="variable">$RM</span> <span class="string">"<span class="variable">$cfgfile</span>"</span> 这行代码注释掉</span><br><span class="line">或 把 <span class="variable">$RM</span> <span class="string">"<span class="variable">$cfgfile</span>"</span> 这行删除掉</span><br><span class="line">或 写成 <span class="variable">$RM</span> -f <span class="string">"<span class="variable">$cfgfile</span>"</span></span><br><span class="line">重新再运行 ./configure 就可以了</span><br><span class="line"></span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br><span class="line"><span class="comment"># 如果不设置安装路径，系统默认安装路径为 /usr/apr/lib</span></span><br></pre></td></tr></table></figure><h3 id="安装-apr-util"><a href="#安装-apr-util" class="headerlink" title="安装 apr-util"></a>安装 apr-util</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/tools/</span><br><span class="line">tar -zxvf apr-util-1.6.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> apr-util-1.6.1/</span><br><span class="line"><span class="comment"># 安装 apr-util 需要配置 apr路径 和 jvm路径，否则会报错找不到apr</span></span><br><span class="line">./configure \</span><br><span class="line">--prefix=/usr/<span class="built_in">local</span>/apr-utils \</span><br><span class="line">--with-apr=/usr/<span class="built_in">local</span>/apr</span><br><span class="line"><span class="comment"># --with-java-home=/data/jdk1.8.0_192</span></span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="安装-apr-iconv"><a href="#安装-apr-iconv" class="headerlink" title="安装 apr-iconv"></a>安装 apr-iconv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 expat 开发库</span></span><br><span class="line">yum -y install expat-devel</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /data/tools/</span><br><span class="line">tar -xvf apr-iconv-1.2.2.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> apr-iconv-1.2.2/</span><br><span class="line">./configure \</span><br><span class="line">--prefix=/usr/<span class="built_in">local</span>/apr-iconv \</span><br><span class="line">--with-apr=/usr/<span class="built_in">local</span>/apr</span><br><span class="line"><span class="comment"># --with-java-home=/data/jdk1.8.0_192</span></span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="安装-tomcat-native"><a href="#安装-tomcat-native" class="headerlink" title="安装 tomcat native"></a>安装 tomcat native</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 libtool 依赖库</span></span><br><span class="line">yum -y install libtool libtool-devel</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /data/tools/</span><br><span class="line">tar -zxvf apache-tomcat-8.5.37.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> apache-tomcat-8.5.37/bin/</span><br><span class="line">tar -zxvf tomcat-native.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> tomcat-native-1.2.19-src/native/</span><br><span class="line">./configure \</span><br><span class="line">--with-apr=/usr/<span class="built_in">local</span>/apr \</span><br><span class="line">--with-java-home=/data/jdk1.8.0_192 \</span><br><span class="line">--with-ssl=/usr/<span class="built_in">local</span>/openssl \</span><br><span class="line">--with-ssl=yes</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="配置-Apr"><a href="#配置-Apr" class="headerlink" title="配置 Apr"></a>配置 Apr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/profile</span></span><br><span class="line">vim /etc/profile.d/apr.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/apr/lib</span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="新增-APRConfig-类"><a href="#新增-APRConfig-类" class="headerlink" title="新增 APRConfig 类"></a>新增 APRConfig 类</h2><blockquote><p>网上大部分讲解配置tomcat apr的文章，都只是讲了如何在独立 Tomcat 服务上如何配置 apr，<br>只需要修改 server.xml 中的 connnector 的 protocol 就可以了，<br>对于 SpringBoot 会稍微复杂些，需要增加一个 apr 配置类在启动的时候修改 Embed 的 tomcat connector 网络接入协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">packagecom.ochain.data2chain.gateway.config;</span><br><span class="line"></span><br><span class="line">importorg.apache.catalina.LifecycleListener;</span><br><span class="line">importorg.apache.catalina.core.AprLifecycleListener;</span><br><span class="line">importorg.springframework.beans.factory.annotation.Value;</span><br><span class="line">importorg.springframework.boot.context.embedded.EmbeddedServletContainerFactory;</span><br><span class="line">importorg.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;</span><br><span class="line">importorg.springframework.context.annotation.Bean;</span><br><span class="line">importorg.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APRConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;tomcat.apr:false&#125;"</span>)</span><br><span class="line">    privateboolean enabled;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EmbeddedServletContainerFactory <span class="title">servletContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TomcatEmbeddedServletContainerFactory container = <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">        <span class="keyword">if</span>(enabled) &#123;</span><br><span class="line">            LifecycleListener arpLifecycle = <span class="keyword">new</span> AprLifecycleListener();</span><br><span class="line">            container.setProtocol(<span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span>);</span><br><span class="line">            container.addContextLifecycleListeners(arpLifecycle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.catalina.core.AprLifecycleListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APRConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// https://docs.spring.io/spring-boot/docs/1.5.6.RELEASE/reference/htmlsingle/#howto-discover-build-in-options-for-external-properties</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EmbeddedServletContainerFactory <span class="title">servletContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TomcatEmbeddedServletContainerFactory tomcat = <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">        tomcat.setProtocol(<span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span>);</span><br><span class="line">        tomcat.addContextLifecycleListeners(<span class="keyword">new</span> AprLifecycleListener());</span><br><span class="line">        <span class="keyword">return</span> tomcat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置完启动，有可能会报错"><a href="#配置完启动，有可能会报错" class="headerlink" title="配置完启动，有可能会报错"></a>配置完启动，有可能会报错</h2><h3 id="错误问题"><a href="#错误问题" class="headerlink" title="错误问题"></a>错误问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-01-02 00:45:55,891 [main] ERROR org.apache.catalina.core.StandardService:181 - Failed to start connector [Connector[org.apache.coyote.http11.Http11AprProtocol-8080]]</span><br><span class="line">org.apache.catalina.LifecycleException: Failed to initialize component [Connector[org.apache.coyote.http11.Http11AprProtocol-8080]]</span><br></pre></td></tr></table></figure><blockquote><p>需要在启动 SpringBoot 的服务器上安装 tomcat-native 和 apr 的模块</p></blockquote><h3 id="启动-SpringBoot-系统找不到-apr-的-lib-库"><a href="#启动-SpringBoot-系统找不到-apr-的-lib-库" class="headerlink" title="启动 SpringBoot 系统找不到 apr 的 lib 库"></a>启动 SpringBoot 系统找不到 apr 的 lib 库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.context.embedded.tomcat.ConnectorStartFailedException: Connector configured tolisten onport 8080 failed tostart</span><br><span class="line">...</span><br><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TOSTART</span><br><span class="line">***************************</span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">The Tomcat connector configured tolisten onport 8080 failed tostart. Theport may already be inuse orthe connector may be misconfigured.</span><br></pre></td></tr></table></figure><h3 id="打开-debug-后查看系统日志发现真正的原因是系统找不到-apr-的-lib库"><a href="#打开-debug-后查看系统日志发现真正的原因是系统找不到-apr-的-lib库" class="headerlink" title="打开 debug 后查看系统日志发现真正的原因是系统找不到 apr 的 lib库"></a>打开 debug 后查看系统日志发现真正的原因是系统找不到 apr 的 lib库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.catalina.LifecycleException: The configured protocol [org.apache.coyote.http11.Http11AprProtocol] requires the APR/native library <span class="built_in">which</span> is not available</span><br></pre></td></tr></table></figure><blockquote><p>解决方法<br>在启动命令行中添加指定 apr库路径</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.library.path=/usr/<span class="built_in">local</span>/apr/lib -jar xxxx-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h3 id="启动-SpringBoot"><a href="#启动-SpringBoot" class="headerlink" title="启动 SpringBoot"></a>启动 SpringBoot</h3><blockquote><p>启动成功后看到日志中输出以下内容，则表示 apr 模式启动成功</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-01-02 15:31:19,032 - Initializing ProtocolHandler [<span class="string">"http-apr-8080"</span>]</span><br><span class="line">2019-01-02 15:31:19,051 - Starting ProtocolHandler [<span class="string">"http-apr-8080"</span>]</span><br><span class="line">2019-01-02 15:31:19,080 - Tomcat started on port(s): 8080(http)</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.jianshu.com/p/f716726ba340" target="_blank" rel="noopener">https://www.jianshu.com/p/f716726ba340</a><br><a href="https://www.cnblogs.com/yueli/p/9668088.html" target="_blank" rel="noopener">https://www.cnblogs.com/yueli/p/9668088.html</a><br><a href="http://www.cnblogs.com/xing901022/p/9145914.html" target="_blank" rel="noopener">http://www.cnblogs.com/xing901022/p/9145914.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot-使用-Tomcat-APR-模式&quot;&gt;&lt;a href=&quot;#SpringBoot-使用-Tomcat-APR-模式&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 使用 Tomcat APR 模式&quot;&gt;&lt;/a&gt;SpringBoot 使用 Tomcat APR 模式&lt;/h1&gt;
    
    </summary>
    
      <category term="SpringBoot笔记" scheme="http://www.gmlyo.com/categories/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SpringBoot 使用 Tomcat APR 模式" scheme="http://www.gmlyo.com/tags/SpringBoot-%E4%BD%BF%E7%94%A8-Tomcat-APR-%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Next 解决 Busuanzi 统计浏览失效</title>
    <link href="http://www.gmlyo.com/2018/12/02/Next-%E8%A7%A3%E5%86%B3-Busuanzi-%E7%BB%9F%E8%AE%A1%E6%B5%8F%E8%A7%88%E5%A4%B1%E6%95%88/"/>
    <id>http://www.gmlyo.com/2018/12/02/Next-解决-Busuanzi-统计浏览失效/</id>
    <published>2018-12-01T17:43:32.000Z</published>
    <updated>2018-12-01T17:46:30.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Next-解决-Busuanzi-统计浏览失效"><a href="#Hexo-Next-解决-Busuanzi-统计浏览失效" class="headerlink" title="Hexo Next 解决 Busuanzi 统计浏览失效"></a>Hexo Next 解决 Busuanzi 统计浏览失效</h1><a id="more"></a><p>由于 busuanzi（不蒜子）的网址更新，导致了使用 Hexo Next 主题时统计浏览数失效。</p><p>不蒜子官网<br><a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a></p><p>解决方法<br>到 <code>hexo</code> 的 <code>themes</code> 目录下<br>进入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next/layout/_third-party/analytics/</span><br></pre></td></tr></table></figure><p>打开 <code>busuanzi-counter.swig</code><br>将<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span></span><br></pre></td></tr></table></figure></p><p>修改为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span></span><br></pre></td></tr></table></figure></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/ddydavie/article/details/83020549" target="_blank" rel="noopener">https://blog.csdn.net/ddydavie/article/details/83020549</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo-Next-解决-Busuanzi-统计浏览失效&quot;&gt;&lt;a href=&quot;#Hexo-Next-解决-Busuanzi-统计浏览失效&quot; class=&quot;headerlink&quot; title=&quot;Hexo Next 解决 Busuanzi 统计浏览失效&quot;&gt;&lt;/a&gt;Hexo Next 解决 Busuanzi 统计浏览失效&lt;/h1&gt;
    
    </summary>
    
      <category term="Next笔记" scheme="http://www.gmlyo.com/categories/Next%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Next 解决 Busuanzi 统计浏览失效" scheme="http://www.gmlyo.com/tags/Next-%E8%A7%A3%E5%86%B3-Busuanzi-%E7%BB%9F%E8%AE%A1%E6%B5%8F%E8%A7%88%E5%A4%B1%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>日志统计常用技巧</title>
    <link href="http://www.gmlyo.com/2018/10/29/%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.gmlyo.com/2018/10/29/日志统计常用技巧/</id>
    <published>2018-10-29T13:33:34.000Z</published>
    <updated>2018-10-29T13:42:37.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志统计常用技巧"><a href="#日志统计常用技巧" class="headerlink" title="日志统计常用技巧"></a>日志统计常用技巧</h1><a id="more"></a><h2 id="按时间截取"><a href="#按时间截取" class="headerlink" title="按时间截取"></a>按时间截取</h2><blockquote><p>截取指定时间段日志</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/^2018-10-29 14:30/,/^2018-10-29 14:32/p'</span> server.log | more</span><br></pre></td></tr></table></figure><h2 id="按标识截取"><a href="#按标识截取" class="headerlink" title="按标识截取"></a>按标识截取</h2><blockquote><p>截取特定标识日志的内容（仅特定标识日志行、或标识附近日志行）<br>过滤包含特定标识（忽略大小写）的日志、并显示前后 10 行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -i -A 10 -B 10 <span class="string">"error"</span> access.log | more</span><br><span class="line">grep -i -A 10 -B 10 <span class="string">"error"</span> access.log &gt; access_error.txt</span><br><span class="line"></span><br><span class="line">grep -i -C 10 <span class="string">"error"</span> access.log | more</span><br><span class="line">grep -i -C 10 <span class="string">"error"</span> access.log &gt; access_error.txt</span><br></pre></td></tr></table></figure><h2 id="按指定列截取"><a href="#按指定列截取" class="headerlink" title="按指定列截取"></a>按指定列截取</h2><blockquote><p>截取第7列为 ‘/test’ 的行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk <span class="string">'if($7=="/test"&#123;print $0&#125;'</span> | more</span><br></pre></td></tr></table></figure><h2 id="日志统计"><a href="#日志统计" class="headerlink" title="日志统计"></a>日志统计</h2><blockquote><p>分时访问量统计<br>对日志中的时间列进行拆分，根据时间格式取 YYYY-mm-DD HH:MM 部分、进行排序、汇总，即可获得每分钟的访问量统计。</p></blockquote><h3 id="按分钟汇总统计访问量"><a href="#按分钟汇总统计访问量" class="headerlink" title="按分钟汇总统计访问量"></a>按分钟汇总统计访问量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | grep <span class="string">"^2012-"</span> | awk -F\: <span class="string">'&#123;print $1" "$2":"$3&#125;'</span> | sort | uniq -c | more</span><br></pre></td></tr></table></figure><h3 id="按小时汇总统计访问量"><a href="#按小时汇总统计访问量" class="headerlink" title="按小时汇总统计访问量"></a>按小时汇总统计访问量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | grep <span class="string">"^2012-"</span> | awk -F\: <span class="string">'&#123;print $1" "$2"&#125;'</span> | sort | uniq -c | more</span><br></pre></td></tr></table></figure><h2 id="日志中的-IP-地址"><a href="#日志中的-IP-地址" class="headerlink" title="日志中的 IP 地址"></a>日志中的 IP 地址</h2><blockquote><p>Web服务器日志(Nginx)中，通常第一列为客户端IP地址，取该段值进行排序、汇总，即可得到IP:访问次数的统计。</p></blockquote><h3 id="从日志中统计-IP-访问次数"><a href="#从日志中统计-IP-访问次数" class="headerlink" title="从日志中统计 IP 访问次数"></a>从日志中统计 IP 访问次数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk <span class="string">'&#123;print $1&#125;'</span> | sort | uniq -c | more</span><br></pre></td></tr></table></figure><h3 id="统计来访唯一-IP-数"><a href="#统计来访唯一-IP-数" class="headerlink" title="统计来访唯一 IP 数"></a>统计来访唯一 IP 数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk <span class="string">'&#123;print $1&#125;'</span> | sort | uniq | wc -l</span><br></pre></td></tr></table></figure><h2 id="网络连接状态"><a href="#网络连接状态" class="headerlink" title="网络连接状态"></a>网络连接状态</h2><p>netstat 命令可获取系统当前的侦听、连接状态，包括协议、源IP:端口、目标IP:端口、连接状态信息，取关注的列进行排序、汇总，即可获得连接数、状态等统计。</p><h3 id="TCP连接数"><a href="#TCP连接数" class="headerlink" title="TCP连接数"></a>TCP连接数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat -antp | grep ^tcp | awk <span class="string">'&#123;print $5&#125;'</span> | awk -F\: <span class="string">'&#123;print $1&#125;'</span> | sort | uniq -c | sort -nr</span><br><span class="line">      5 0.0.0.0</span><br><span class="line">      2 192.217.199.215</span><br><span class="line">      1 91.189.89.144</span><br><span class="line">      1 172.16.17.4</span><br><span class="line">      1 172.16.17.3</span><br><span class="line">      1 172.16.17.27</span><br></pre></td></tr></table></figure><h3 id="TCP-连接状态"><a href="#TCP-连接状态" class="headerlink" title="TCP 连接状态"></a>TCP 连接状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -antp | grep ^tcp | awk <span class="string">'&#123;print $6&#125;'</span> | sort | uniq -c | sort -nr </span><br><span class="line">     17 ESTABLISHED</span><br><span class="line">      8 LISTEN</span><br><span class="line">      1 CLOSE_WAIT</span><br></pre></td></tr></table></figure><blockquote><p>使用 awk 的正则匹配进行过滤，减少前面的 grep 指令<br>不过 grep 的过滤处理速度似乎比 awk 的正则匹配速度更快，因此对大日志分析时可能还是先用 grep 过滤效率更高</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">time cat netstat.txt | awk <span class="string">'/^tcp/ &#123;print $6&#125;'</span> | sort | uniq -c | sort -nr</span><br><span class="line">   2713 TIME_WAIT</span><br><span class="line">    203 ESTABLISHED</span><br><span class="line">     29 FIN_WAIT1</span><br><span class="line">     18 LISTEN</span><br><span class="line">     17 FIN_WAIT2</span><br><span class="line"></span><br><span class="line">real    0m0.017s</span><br><span class="line">user    0m0.014s</span><br><span class="line">sys 0m0.002s</span><br><span class="line"></span><br><span class="line">time cat netstat.txt | grep ^tcp | awk <span class="string">'&#123;print $6&#125;'</span> | sort | uniq -c | sort -nr</span><br><span class="line">   2713 TIME_WAIT</span><br><span class="line">    203 ESTABLISHED</span><br><span class="line">     29 FIN_WAIT1</span><br><span class="line">     18 LISTEN</span><br><span class="line">     17 FIN_WAIT2</span><br><span class="line"></span><br><span class="line">real    0m0.008s</span><br><span class="line">user    0m0.005s</span><br><span class="line">sys 0m0.001s</span><br></pre></td></tr></table></figure><h3 id="其他-awk-匹配方式"><a href="#其他-awk-匹配方式" class="headerlink" title="其他 awk 匹配方式"></a>其他 awk 匹配方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat netstat.txt | awk <span class="string">'&#123;if($1=="tcp")print $6&#125;'</span> | sort | uniq -c | sort -nr</span><br><span class="line">   2713 TIME_WAIT</span><br><span class="line">    203 ESTABLISHED</span><br><span class="line">     29 FIN_WAIT1</span><br><span class="line">     18 LISTEN</span><br><span class="line">     17 FIN_WAIT2</span><br><span class="line"></span><br><span class="line">cat netstat.txt | awk <span class="string">'$1=="tcp" &#123;print $6&#125;'</span> | sort | uniq -c | sort -nr</span><br><span class="line">   2713 TIME_WAIT</span><br><span class="line">    203 ESTABLISHED</span><br><span class="line">     29 FIN_WAIT1</span><br><span class="line">     18 LISTEN</span><br><span class="line">     17 FIN_WAIT2</span><br></pre></td></tr></table></figure><h3 id="多条件匹配"><a href="#多条件匹配" class="headerlink" title="多条件匹配"></a>多条件匹配</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cat netstat.txt | awk <span class="string">'/^tcp|^udp/ &#123;print $1"-"$6&#125;'</span> | sort | uniq -c | sort -nr</span><br><span class="line">   2713 tcp-TIME_WAIT</span><br><span class="line">    203 tcp-ESTABLISHED</span><br><span class="line">     29 tcp-FIN_WAIT1</span><br><span class="line">     18 tcp-LISTEN</span><br><span class="line">     17 tcp-FIN_WAIT2</span><br><span class="line">      4 udp-32366/rpcbind</span><br><span class="line">      4 udp--</span><br><span class="line">      3 udp-32526/rpc.statd</span><br><span class="line">      2 udp-19339/rpc.mountd</span><br><span class="line">      1 udp-ESTABLISHED</span><br><span class="line">      1 udp-38143/gmond</span><br><span class="line">      1 udp-19335/rpc.rquotad</span><br><span class="line">      1 udp-1282/portreserve</span><br><span class="line"></span><br><span class="line">cat netstat.txt | awk <span class="string">'&#123;if($1~"^tcp" || $1~"^udp")print $1"-"$6&#125;'</span> | sort | uniq -c | sort -nr</span><br><span class="line">   2713 tcp-TIME_WAIT</span><br><span class="line">    203 tcp-ESTABLISHED</span><br><span class="line">     29 tcp-FIN_WAIT1</span><br><span class="line">     18 tcp-LISTEN</span><br><span class="line">     17 tcp-FIN_WAIT2</span><br><span class="line">      4 udp-32366/rpcbind</span><br><span class="line">      4 udp--</span><br><span class="line">      3 udp-32526/rpc.statd</span><br><span class="line">      2 udp-19339/rpc.mountd</span><br><span class="line">      1 udp-ESTABLISHED</span><br><span class="line">      1 udp-38143/gmond</span><br><span class="line">      1 udp-19335/rpc.rquotad</span><br><span class="line">      1 udp-1282/portreserve</span><br><span class="line"></span><br><span class="line">cat netstat.txt | awk <span class="string">'&#123;if($1=="tcp" &amp;&amp; $6!~"ESTABLISHED")print $6&#125;'</span> | sort | uniq -c | sort -nr</span><br><span class="line">   2713 TIME_WAIT</span><br><span class="line">     29 FIN_WAIT1</span><br><span class="line">     18 LISTEN</span><br><span class="line">     17 FIN_WAIT2</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例一</strong></p><blockquote><p>扫描 gz 压缩文件，从中寻找带有 dianping_reply 的行，将改行按照[进行拆分，然后直接使用if条件进行判断，比较，最终输出想要的结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat access.log.tar.gz | grep <span class="string">'dianping_reply.log'</span> | awk <span class="string">'&#123;split($4,array,"[");if(array[2]&gt;="29/May/2016:00:00:26" &amp;&amp; array[2]&lt;="29/May/2016:00:01:14")&#123;print $0&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>命令解释<br><code>zcat</code>   直接读取压缩文件的内容<br><code>grep</code>   过滤特定字符的行<br><code>awk</code>    用于执行命令<br><code>split</code>  用于切分字符串</p><p><strong>示例二</strong></p><blockquote><p>过滤 <code>22/Feb/2017-18:52:59</code> 之前的日志</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test.log</span><br><span class="line">[22/Feb/2017-18:51:58]    api.momo.com    /api/feed    HTTP/1.1      121.0.0.1      android1.2</span><br><span class="line">[22/Feb/2017-18:51:59]    api.momo.com    /api/follow    HTTP/1.1      121.0.0.2    iphone1.1</span><br><span class="line">[22/Feb/2017-18:52:58]    api.momo.com    /api/user    HTTP/1.1      121.0.0.3    iphone1.1</span><br><span class="line">[22/Feb/2017-18:52:41]    api.momo.com    /api/feed    HTTP/1.1      121.0.0.4    android1.2</span><br><span class="line">[22/Feb/2017-18:56:30]    api.momo.com    /api/follow    HTTP/1.1      121.0.0.2    android1.2</span><br><span class="line">[22/Feb/2017-18:51:21]    api.momo.com    /api/user    HTTP/1.1      121.0.0.3    iphone1.1</span><br><span class="line">[22/Feb/2017-18:59:58]    api.momo.com    /api/user    HTTP/1.1      121.0.0.3    android1.2</span><br><span class="line">[22/Feb/2017-18:51:21]    api.momo.com    /api/feed    HTTP/1.1      121.0.0.1    iphone1.1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.log | awk <span class="string">'&#123;split($1,array,"[");split(array[2],array2,"]");if(array2[1] &gt;= "22/Feb/2017-18:52:59")&#123;print($0)&#125;&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://xstarcd.github.io/wiki/shell/logview_tips.html" target="_blank" rel="noopener">http://xstarcd.github.io/wiki/shell/logview_tips.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;日志统计常用技巧&quot;&gt;&lt;a href=&quot;#日志统计常用技巧&quot; class=&quot;headerlink&quot; title=&quot;日志统计常用技巧&quot;&gt;&lt;/a&gt;日志统计常用技巧&lt;/h1&gt;
    
    </summary>
    
      <category term="Shell笔记" scheme="http://www.gmlyo.com/categories/Shell%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="日志统计常用技巧" scheme="http://www.gmlyo.com/tags/%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Shell 按时间截取日志</title>
    <link href="http://www.gmlyo.com/2018/10/29/Shell%E6%8C%89%E6%97%B6%E9%97%B4%E6%88%AA%E5%8F%96%E6%97%A5%E5%BF%97/"/>
    <id>http://www.gmlyo.com/2018/10/29/Shell按时间截取日志/</id>
    <published>2018-10-29T03:24:28.000Z</published>
    <updated>2018-12-01T17:40:14.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell-按时间截取日志"><a href="#Shell-按时间截取日志" class="headerlink" title="Shell 按时间截取日志"></a>Shell 按时间截取日志</h1><p>截取查看某时间段内的日志</p><a id="more"></a><h2 id="sed-截取"><a href="#sed-截取" class="headerlink" title="sed 截取"></a>sed 截取</h2><blockquote><p>精确到 <code>时分秒</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/2018-10-22|10:23:44/,/2018-10-22|11:23:44/'</span> access.log &gt; 10-11_access.log</span><br></pre></td></tr></table></figure><blockquote><p>精确到小时</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/2018-10-22|10/,/2018-10-22|11/'</span> access.log &gt; 10-11_access.log</span><br></pre></td></tr></table></figure><blockquote><p><code>sed -n &#39;/开始时间/,/结束时间/&#39; 被截取日志原文件 &gt; 截取后日志新文件</code><br><code>$p</code> 显示到最后一行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看某时间段到当前的 messages 系统日志</span></span><br><span class="line">sed -n <span class="string">'/May 20 17/,$p'</span> /var/<span class="built_in">log</span>/messages | less</span><br><span class="line"></span><br><span class="line">sed -n <span class="string">'/2018-10-29 09:00:00/,$p'</span> access.log &gt; /tmp/access.log</span><br></pre></td></tr></table></figure><blockquote><p>sed 截取 10:00:00 到 现在的 catalina.out 日志内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/2018-04-11 10:[0-9][0-9]:[0-9][0-9]/,$p'</span> catalina.out | less</span><br></pre></td></tr></table></figure><blockquote><p>sed 截取 2018-04-11 这天 到 现在的 catalina.out 日志内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/2018-04-11 [0-9][0-9]:[0-9][0-9]:[0-9][0-9]/,$p'</span> catalina.out | less</span><br></pre></td></tr></table></figure><blockquote><p>sed 截取 2018-03-14 09:00:00 2018-03-14 12:00:00 的日志</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">'/2018-03-14 09:[0][0]:[0][0]/,/2018-03-14 12:[0][0]:[0][0]/p'</span> catalina.out &gt; /tmp/catalina.log</span><br></pre></td></tr></table></figure><hr><h2 id="grep-截取"><a href="#grep-截取" class="headerlink" title="grep 截取"></a>grep 截取</h2><blockquote><p>egrep 截取 13:38 到 14:00 之间的日志内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep <span class="string">'13:3[8-9]:[0-9][0-9]|13:[4-5][0-9]:[0-9][0-9]'</span> catalina.out | less</span><br></pre></td></tr></table></figure><blockquote><p>egrep 截取 2018-04-11 到 2018-04-12 之间的日志内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep <span class="string">'2018-04-11 [0-9][0-9]:[0-9][0-9]:[0-9][0-9]|2018-04-12 [0-9][0-9]:[0-9][0-9]:[0-9][0-9]'</span> catalina.out | less</span><br></pre></td></tr></table></figure><hr><p><strong>截取 Nginx 访问日志</strong></p><blockquote><p>查看 21/Jul/2014:14:37:50 到 21/Jul/2014:14:38:00 时间段内 access.log 的访问日志</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk <span class="string">'$4 &gt;="[21/Jul/2014:14:37:50" &amp;&amp; $4 &lt;="[21/Jul/2014:14:38:00"'</span></span><br></pre></td></tr></table></figure><h2 id="时间转换在线工具地址"><a href="#时间转换在线工具地址" class="headerlink" title="时间转换在线工具地址"></a>时间转换在线工具地址</h2><p><a href="https://tool.lu/timestamp/" target="_blank" rel="noopener">https://tool.lu/timestamp/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Shell-按时间截取日志&quot;&gt;&lt;a href=&quot;#Shell-按时间截取日志&quot; class=&quot;headerlink&quot; title=&quot;Shell 按时间截取日志&quot;&gt;&lt;/a&gt;Shell 按时间截取日志&lt;/h1&gt;&lt;p&gt;截取查看某时间段内的日志&lt;/p&gt;
    
    </summary>
    
      <category term="Shell笔记" scheme="http://www.gmlyo.com/categories/Shell%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Shell 按时间截取日志" scheme="http://www.gmlyo.com/tags/Shell-%E6%8C%89%E6%97%B6%E9%97%B4%E6%88%AA%E5%8F%96%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换</title>
    <link href="http://www.gmlyo.com/2018/10/24/Python%E8%AF%A6%E8%A7%A3time%E6%A8%A1%E5%9D%97%E4%B8%ADUTC%E4%B8%96%E7%95%8C%E6%97%B6%E9%97%B4%E3%80%81%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%89%E8%80%85%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.gmlyo.com/2018/10/24/Python详解time模块中UTC世界时间、时间戳、字符串三者的转换/</id>
    <published>2018-10-24T05:57:02.000Z</published>
    <updated>2018-10-24T05:57:04.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-详解time模块中-UTC世界时间、时间戳、字符串三者的转换"><a href="#Python-详解time模块中-UTC世界时间、时间戳、字符串三者的转换" class="headerlink" title="Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换"></a>Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换</h1><a id="more"></a><h2 id="本地时间-转换-为时间戳"><a href="#本地时间-转换-为时间戳" class="headerlink" title="本地时间 转换 为时间戳"></a>本地时间 转换 为时间戳</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">date_=datetime.datetime(<span class="number">2018</span>,<span class="number">6</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">55</span>,<span class="number">00</span>)</span><br><span class="line">timestamp2=time.mktime(date_.timetuple())   <span class="comment"># date_.timetuple() 将datetime 格式的转化为 time 模块的 tuple 格式</span></span><br><span class="line">print(timestamp2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳转换为本地时间</span></span><br><span class="line"></span><br><span class="line">ltime=time.localtime(<span class="number">1529112900</span>)  <span class="comment">#time.struct_time(tm_year=2018, tm_mon=6, tm_mday=16, tm_hour=9, tm_min=35, tm_sec=0, tm_wday=5, tm_yday=167, tm_isdst=0)</span></span><br><span class="line">timeStr=time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, ltime)</span><br><span class="line">print(timeStr)</span><br></pre></td></tr></table></figure><h2 id="UTCS-时间转换为时间戳-2018-07-13T16-00-00Z"><a href="#UTCS-时间转换为时间戳-2018-07-13T16-00-00Z" class="headerlink" title="UTCS 时间转换为时间戳 2018-07-13T16:00:00Z"></a>UTCS 时间转换为时间戳 2018-07-13T16:00:00Z</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">utc_to_local</span><span class="params">(utc_time_str, utc_format=<span class="string">'%Y-%m-%dT%H:%M:%SZ'</span>)</span>:</span></span><br><span class="line">    local_tz = pytz.timezone(<span class="string">'Asia/Chongqing'</span>)      <span class="comment"># 定义本地时区</span></span><br><span class="line">    local_format = <span class="string">"%Y-%m-%d %H:%M:%S"</span>              <span class="comment"># 定义本地时间format</span></span><br><span class="line"></span><br><span class="line">    utc_dt = datetime.datetime.strptime(utc_time_str, utc_format)       <span class="comment"># 讲世界时间的格式转化为 datetime.datetime 格式</span></span><br><span class="line">    local_dt = utc_dt.replace(tzinfo=pytz.utc).astimezone(local_tz)     <span class="comment"># 想将 datetime 格式添加上世界时区，然后 astimezone 切换时区：世界时区 ==&gt; 本地时区</span></span><br><span class="line">    <span class="comment"># time_str = local_dt.strftime(local_format)                         # 将 datetime 格式转化为 str—format 格式</span></span><br><span class="line">    <span class="comment"># return int(time.mktime(time.strptime(time_str, local_format)))     # 运用 mktime 方法将 date—tuple 格式的时间转化为时间戳; time.strptime() 可以得到 tuple 的时间格式</span></span><br><span class="line">    <span class="keyword">return</span> int(time.mktime(local_dt.timetuple()))                       <span class="comment"># 返回当地时间戳</span></span><br></pre></td></tr></table></figure><h2 id="本地时间转换为-UTC-传入的本地时间戳-1531411200"><a href="#本地时间转换为-UTC-传入的本地时间戳-1531411200" class="headerlink" title="本地时间转换为 UTC  传入的本地时间戳 1531411200"></a>本地时间转换为 UTC  传入的本地时间戳 1531411200</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local_to_utc</span><span class="params">(local_ts, utc_format=<span class="string">'%Y-%m-%dT%H:%MZ'</span>)</span>:</span></span><br><span class="line">    local_tz = pytz.timezone(<span class="string">'Asia/Chongqing'</span>)    <span class="comment"># 定义本地时区</span></span><br><span class="line">    local_format = <span class="string">"%Y-%m-%d %H:%M:%S"</span>               <span class="comment"># 定义本地时间 format</span></span><br><span class="line"></span><br><span class="line">    time_str = time.strftime(local_format, time.localtime(local_ts))    <span class="comment"># 首先将本地时间戳转化为时间元组，用 strftime 格式化成字符串</span></span><br><span class="line">    dt = datetime.datetime.strptime(time_str, local_format)             <span class="comment"># 将字符串用 strptime 转为为 datetime 中 datetime 格式</span></span><br><span class="line">    local_dt = local_tz.localize(dt, is_dst=<span class="keyword">None</span>)                       <span class="comment"># 给时间添加时区，等价于 dt.replace(tzinfo=pytz.timezone('Asia/Chongqing'))</span></span><br><span class="line">    utc_dt = local_dt.astimezone(pytz.utc)                              <span class="comment"># astimezone 切换时区</span></span><br><span class="line">    <span class="keyword">return</span> utc_dt.strftime(utc_format)                                  <span class="comment"># 返回世界时间格式</span></span><br><span class="line"></span><br><span class="line">print(utc_to_local(<span class="string">'2018-07-13T16:00:00Z'</span>, utc_format=<span class="string">'%Y-%m-%dT%H:%M:%SZ'</span>))</span><br><span class="line">print(local_to_utc(<span class="number">1531411200</span>, utc_format=<span class="string">'%Y-%m-%dT%H:%MZ'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1529412900.0</span></span><br><span class="line"><span class="string">2018-06-16 09:35:00</span></span><br><span class="line"><span class="string">1531497600</span></span><br><span class="line"><span class="string">2018-07-12T16:00Z</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/brucewong0516/article/details/81100242" target="_blank" rel="noopener">https://blog.csdn.net/brucewong0516/article/details/81100242</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-详解time模块中-UTC世界时间、时间戳、字符串三者的转换&quot;&gt;&lt;a href=&quot;#Python-详解time模块中-UTC世界时间、时间戳、字符串三者的转换&quot; class=&quot;headerlink&quot; title=&quot;Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换&quot;&gt;&lt;/a&gt;Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换&lt;/h1&gt;
    
    </summary>
    
      <category term="Python笔记" scheme="http://www.gmlyo.com/categories/Python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换" scheme="http://www.gmlyo.com/tags/Python-%E8%AF%A6%E8%A7%A3time%E6%A8%A1%E5%9D%97%E4%B8%AD-UTC%E4%B8%96%E7%95%8C%E6%97%B6%E9%97%B4%E3%80%81%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%89%E8%80%85%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python 软件开发的目录规范</title>
    <link href="http://www.gmlyo.com/2018/09/24/Python%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/"/>
    <id>http://www.gmlyo.com/2018/09/24/Python软件开发的目录规范/</id>
    <published>2018-09-23T17:12:04.000Z</published>
    <updated>2018-09-25T03:19:19.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-软件开发的目录规范"><a href="#Python-软件开发的目录规范" class="headerlink" title="Python 软件开发的目录规范"></a>Python 软件开发的目录规范</h1><a id="more"></a><h2 id="目录规范"><a href="#目录规范" class="headerlink" title="目录规范"></a>目录规范</h2><p><strong>项目目录规范</strong><br><img src="http://pa2bdkuiw.bkt.clouddn.com/%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83.png" alt="目录规范"></p><p><code>bin</code> 存放执行文件，整个程序的入口文件，比如启动功能<br><code>conf</code> 配置文件<br><code>lib</code> 存放自定义的共享库，经常使用的一些功能<br><code>core</code> 存放整个代码程序的核心逻辑<br><code>db</code> 存放数据库相关的<br><code>log</code> 日志相关的<br><code>Readme</code> 记录整个项目的描述信息</p><p><strong>项目文件规范</strong><br><img src="http://pa2bdkuiw.bkt.clouddn.com/%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%E6%96%87%E4%BB%B6.png" alt="目录规范文件"></p><blockquote><p><code>src.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'注册。。。'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'支付。。。'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'转账。。。'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'提现。。。'</span>)</span><br><span class="line"></span><br><span class="line">func_dic = &#123;</span><br><span class="line">    <span class="string">'1'</span>: register,</span><br><span class="line">    <span class="string">'2'</span>: pay,</span><br><span class="line">    <span class="string">'3'</span>: transfer,</span><br><span class="line">    <span class="string">'4'</span>: withdraw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心功能，和用户交互</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">"""</span></span><br><span class="line"><span class="string">        1 注册</span></span><br><span class="line"><span class="string">        2 支付</span></span><br><span class="line"><span class="string">        3 转账</span></span><br><span class="line"><span class="string">        4 提现</span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line"></span><br><span class="line">        choice = input(<span class="string">'&gt;&gt;&gt;: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> choice <span class="keyword">in</span> func_dic:</span><br><span class="line">            func_dic[choice]()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'输入错误指令'</span>)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="获取项目根路径"><a href="#获取项目根路径" class="headerlink" title="获取项目根路径"></a>获取项目根路径</h2><blockquote><p>强调：只有被导入的模块才能使用 <code>.</code> 或 <code>..</code> 的语法<br>编辑 <code>start.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">r'E:\Project\core'</span>)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这样写会有问题，在程序给别人使用时，别人的路径不可能和程序开发者的目录路径一样</p></blockquote><p><strong>改进</strong></p><blockquote><p><code>__file__</code> 表示当前文件的绝对路径<br><code>abspath()</code> 规范路径格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(__file__)</span><br><span class="line">print(os.path.abspath(__file__))</span><br><span class="line"><span class="comment"># sys.path.append(r'E:\Project\core')</span></span><br><span class="line"><span class="comment"># os.path.dirname()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">E:/Project/bin/start.py</span><br><span class="line">E:\Project\bin\start.py</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">print(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">E:\Project\bin</span><br><span class="line">E:\Project</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> core <span class="keyword">import</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    src.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br></pre></td></tr></table></figure><h2 id="获取-db-目录文件的路径"><a href="#获取-db-目录文件的路径" class="headerlink" title="获取 db 目录文件的路径"></a>获取 <code>db</code> 目录文件的路径</h2><blockquote><p>编辑 <code>setting.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">DB_PATH = <span class="string">'%s\%s\%s'</span> % (BASE_DIR, <span class="string">'db'</span>, <span class="string">'db.txt'</span>)</span><br><span class="line"></span><br><span class="line">print(DB_PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">E:\Project\db\db.txt</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这种拼接方式有缺陷，如果是 Linux 系统，<code>\</code> 右斜杠就不能用了</p></blockquote><h3 id="解决跨平台路径格式的问题"><a href="#解决跨平台路径格式的问题" class="headerlink" title="解决跨平台路径格式的问题"></a>解决跨平台路径格式的问题</h3><blockquote><p>使用 <code>os.path.join</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">DB_PATH = os.path.join(BASE_DIR, <span class="string">'db'</span>, <span class="string">'db.txt'</span>)</span><br><span class="line"></span><br><span class="line">print(DB_PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">E:\Project\db\db.txt</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Linux 系统输出格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">DB_PATH = os.path.join(BASE_DIR, <span class="string">'db'</span>, <span class="string">'db.txt'</span>)</span><br><span class="line"></span><br><span class="line">print(DB_PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">/data/Project/db/db.txt</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="获取-log-目录路径"><a href="#获取-log-目录路径" class="headerlink" title="获取 log 目录路径"></a>获取 <code>log</code> 目录路径</h3><blockquote><p>编辑 <code>settings.py</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOG_PATH = os.path.join(BASE_DIR, <span class="string">'log'</span>, <span class="string">'access.log'</span>)</span><br><span class="line"></span><br><span class="line">print(LOG_PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">E:\Project\log\access.log</span><br></pre></td></tr></table></figure><h2 id="项目目录规范示例"><a href="#项目目录规范示例" class="headerlink" title="项目目录规范示例"></a>项目目录规范示例</h2><h3 id="项目名-core-src-py"><a href="#项目名-core-src-py" class="headerlink" title="项目名/core/src.py"></a>项目名/core/src.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> lib <span class="keyword">import</span> common</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'注册。。。'</span>)</span><br><span class="line">    uname = input(<span class="string">'用户名：'</span>).strip()</span><br><span class="line">    pwd = input(<span class="string">'密码：'</span>).strip()</span><br><span class="line">    <span class="keyword">with</span> open(settings.DB_PATH, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">'%s:%s\n'</span> % (uname, pwd))</span><br><span class="line"></span><br><span class="line">    common.logger(uname)</span><br><span class="line">    print(<span class="string">'注册成功'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'支付。。。'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'转账。。。'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'提现。。。'</span>)</span><br><span class="line"></span><br><span class="line">func_dic = &#123;</span><br><span class="line">    <span class="string">'1'</span>: register,</span><br><span class="line">    <span class="string">'2'</span>: pay,</span><br><span class="line">    <span class="string">'3'</span>: transfer,</span><br><span class="line">    <span class="string">'4'</span>: withdraw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心功能，和用户交互</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">"""</span></span><br><span class="line"><span class="string">        1 注册</span></span><br><span class="line"><span class="string">        2 支付</span></span><br><span class="line"><span class="string">        3 转账</span></span><br><span class="line"><span class="string">        4 提现</span></span><br><span class="line"><span class="string">        按 q 退出</span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line"></span><br><span class="line">        choice = input(<span class="string">'请选择相应的操作: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">'q'</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> choice <span class="keyword">not</span> <span class="keyword">in</span> func_dic:</span><br><span class="line">            print(<span class="string">'输入错误指令，请重新输入'</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        func_dic[choice]()</span><br></pre></td></tr></table></figure><h3 id="项目名-conf-settings-py"><a href="#项目名-conf-settings-py" class="headerlink" title="项目名/conf/settings.py"></a>项目名/conf/settings.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">DB_PATH = os.path.join(BASE_DIR, <span class="string">'db'</span>, <span class="string">'db.txt'</span>)</span><br><span class="line">LOG_PATH = os.path.join(BASE_DIR, <span class="string">'log'</span>, <span class="string">'access.log'</span>)</span><br></pre></td></tr></table></figure><h3 id="项目名-lib-common-py"><a href="#项目名-lib-common-py" class="headerlink" title="项目名/lib/common.py"></a>项目名/lib/common.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(time.strftime('%Y-%m-%d %X'))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(settings.LOG_PATH, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">'%s, %s, 注册成功\n'</span> % (time.strftime(<span class="string">'%Y-%m-%d %X'</span>, time.localtime()), msg))</span><br></pre></td></tr></table></figure><h3 id="项目名-bin-start-py"><a href="#项目名-bin-start-py" class="headerlink" title="项目名/bin/start.py"></a>项目名/bin/start.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> core <span class="keyword">import</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    src.run()</span><br></pre></td></tr></table></figure><h3 id="运行-start-py"><a href="#运行-start-py" class="headerlink" title="运行 start.py"></a>运行 start.py</h3><p><img src="http://pa2bdkuiw.bkt.clouddn.com/20180925111840.png" alt="运行start"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat db.txt</span><br><span class="line">egon:<span class="number">123</span></span><br><span class="line"></span><br><span class="line">tail access.log</span><br><span class="line"><span class="number">2018</span><span class="number">-09</span><span class="number">-24</span> <span class="number">01</span>:<span class="number">08</span>:<span class="number">11</span>, egon, 注册成功</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-软件开发的目录规范&quot;&gt;&lt;a href=&quot;#Python-软件开发的目录规范&quot; class=&quot;headerlink&quot; title=&quot;Python 软件开发的目录规范&quot;&gt;&lt;/a&gt;Python 软件开发的目录规范&lt;/h1&gt;
    
    </summary>
    
      <category term="Python笔记" scheme="http://www.gmlyo.com/categories/Python%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python 软件开发的目录规范" scheme="http://www.gmlyo.com/tags/Python-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
</feed>
