<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ActiveMQ安装与配置]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F27%2FActiveMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ActiveMQ安装与配置 操作系统 CentOS7建议 ActiveMQ 集群 和 Zookeeper 集群部署在同一台服务器上，否则随着时间的增加，ActiveMQ 集群容易出现假死的情况。 JMS 支持的消息传递模型 JMS 支持两种消息传递模型：队列（Queue）和 主题（Topic）。 点对点传递模型 点对点（point-to-point，简称PTP）Queue消息传递模型。通过该消息传递模型，一个应用程序（即消息生产者）可以向另外一个应用程序（即消息消费者）发送消息。 在此传递模型中，消息目的地类型是队列（即 Destination 接口实现类实例由 Session 接口实现类实例通过调用其 createQueue 方法并传入队列名称而创建）。 消息首先被传送至消息服务器端特定的队列中，然后从此对列中将消息传送至对此队列进行监听的某个消费者。同一个队列可以关联多个消息生产者和消息消费者，但一条消息仅能传递给一个消息消费者。 如果多个消息消费者正在监听队列上的消息，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。 如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。这种消息传递模型是传统意义上的懒模型或轮询模型。 在此模型中，消息不是自动推动给消息消费者的，而是要由消息消费者从队列中请求获得。 发布/订阅传递模型 发布/订阅（publish/subscribe，简称 pub/sub）Topic 消息传递模型。 通过该消息传递模型，应用程序能够将一条消息发送给多个消息消费者。在此传送模型中，消息目的地类型是主题（即 Destination 接口实现类实例由 Session 接口实现类实例通过调用其 createTopic 方法并传入主题名称而创建）。 消息首先由消息生产者发布至消息服务器中特定的主题中，然后由消息服务器将消息传送至所有已订阅此主题的消费者。 主题目标也支持长期订阅。长期订阅表示消费者已注册了主题目标，但在消息到达目标时该消费者可以处于非活动状态。 当消费者再次处于活动状态时，将会接收该消息。如果消费者均没有注册某个主题目标，该主题只保留注册了长期订阅的非活动消费者的消息。 与 PTP 消息传递模型不同，pub/sub 消息传递模型允许多个主题订阅者接收同一条消息。JMS 一直保留消息，直至所有主题订阅者都接收到消息为止。 pub/sub 消息传递模型基本上是一个推模型。在该模型中，消息会自动广播，消息消费者无须通过主动请求或轮询主题的方法来获得新的消息。 具体区别对比如下 类型 Topic Queue 概要 Publish Subscribe messaging 发布订阅消息 Point-to-Point 点对点 有无状态 Topic 数据默认不落地，是无状态的。 Queue 数据默认会在 mq 服务器上以文件形式保存，比如Active MQ 一般保存在 $AMQ_HOME/data/kr-store/data 下面。也可以配置成 DB 存储。 完整性保障 并不保证 publisher 发布的每条数据，Subscriber 都能接受到。 Queue 保证每条数据都能被 receiver 接收。 消息是否会丢失 一般来说 publisher 发布消息到某一个 topic 时，只有正在监听该 topic 地址的 sub 能够接收到消息；如果没有 sub 在监听，该 topic 就丢失了。 Sender 发送消息到目标 Queue，receiver 可以异步接收这个 Queue 上的消息。Queue 上的消息如果暂时没有 receiver 来取，也不会丢失。 消息发布接收策略 一对多的消息发布接收策略，监听同一个 topic 地址的多个 sub 都能收到 publisher 发送的消息。Sub 接收完通知 mq 服务器。 一对一的消息发布接收策略，一个 sender 发送的消息，只能有一个 receiver 接收。receiver 接收完后，通知 mq 服务器已接收，mq 服务器对 queue 里的消息采取删除或其他操作。 该段引用连接http://blog.csdn.net/lspj201007186/article/details/70176427 初始化环境在此我们安装的是 ActiveMQ 5.14.5，ActiveMQ 5.14.5 使用的是 jdk1.7。ActiveMQ 5.15.0 使用的是 jdk1.8。 安装 jdk1.7cd /data/tools/wget -c http://mirrors.linuxeye.com/jdk/jdk-7u80-linux-x64.tar.gztar -zxvf jdk-7u80-linux-x64.tar.gz -C /data/chown -R root:root /data/jdk1.7.0_80 添加环境变量123456vim /etc/profileexport JAVA_HOME=/data/jdk1.7.0_80export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binsource /etc/profilejava -version 关闭 防火墙 和 selinux，同步服务器时间123456ntpdate -u cn.ntp.org.cnsed -i ‘/SELINUX/s/enforcing/disabled/’ /etc/selinux/configsetenforce 0systemctl disable firewalld.servicesystemctl stop firewalld.serviceshutdown -r now 安装 ActiveMQ ActiveMQ 官网http://activemq.apache.org/ 下载 ActiveMQhttp://activemq.apache.org/download.htmlhttp://archive.apache.org/dist/activemq/ 下载 ActiveMQ5.14.51234mkdir -pv /data/app/activemqcd /data/tools/wget -c http://mirrors.hust.edu.cn/apache/activemq/5.14.5/apache-activemq-5.14.5-bin.tar.gztar -zxvf apache-activemq-5.14.5-bin.tar.gz -C /data/app/activemq –strip-components 1 查看 ActiveMQ 目录结构1ll -h 文件名/目录名 详解 activemq-all-5.14.5.jar ActiveMQ 所有 jar bin ActiveMQ 启动命令的二进制执行文件及一些命令脚本 conf ActiveMQ 配置目录，包含最基本的 ActiveMQ 配置文件 data ActiveMQ 数据目录，默认为空。包含 ActiveMQ 的进程文件、数据文件、日志文件。该目录也是 ActiveMQ 消息持久化的目录 docs 用户使用帮助相关文件 examples 操作 ActiveMQ 相关实例 lib ActiveMQ 需要的类库 webapps ActiveMQ 控制台应用目录 webapps-demo ActiveMQ 使用实例目录 LICENSE ActiveMQ 所有包使用的 Apache 开源消息协议 NOTICE ActiveMQ 版权信息 README 用户使用引导文件，包括一些文档及 URL 启动 ActiveMQ12/data/app/activemq/bin/activemq starttail -f /data/app/activemq/data/activemq.log ActiveMQ 启动方式 普通启动 1/data/app/activemq/bin/activemq start 后台启动并指定日志文件 1nohup /data/app/activemq/bin/activemq start &gt; /data/app/activemq/logs/smlog 2&gt;&amp;1 &amp; ActiveMQ 管理控制台 ActiveMQ 默认的管理后台端口是 8161，默认管理用户名和密码均是 admin。ActiveMQ 默认的管理后台端口，可以在 ActiveMQ 的配置文件 jetty.xml 中查看到12vim /data/app/activemq/conf/jetty.xml +110&lt;property name=”port” value=”8161″/&gt; ActiveMQ 默认管理用户名和密码均是 admin，如果要修改默认用户名和密码的话，可以通过修改 jetty-realm.properties 文件来达到目的123vim /data/app/activemq/conf/jetty-realm.propertiesadmin: password@123, adminuser: user@123, user 注意：ActiveMQ 用户名和密码的格式是1username: password, rolename 登陆管理控制台http://x.x.x.x:8161/admin 管理控制台介绍在 ActiveMQ 的管理控制台，关注比较多的是 Queues队列 和 Topics主题。Queues队列 选项 字段 详解 Number Of Pending Messages 表示还有多少条消息没有被消费，实际上是表示消息的积压程度。 Number Of Consumers 表示在该队列上还有多少消费者在等待接受消息。其实就是消费者的数量。 Messages Enqueued 表示生产了多少条消息。 Messages Dequeued 表示消费了多少条消息。 Topics主题 选项 字段 详解 Number Of Consumers 表示在该队列上还有多少消费者在等待接受消息。 Messages Enqueued 表示生产了多少条消息。 Messages Dequeued 表示消费了多少条消息。]]></content>
      <categories>
        <category>ActiveMQ笔记</category>
      </categories>
      <tags>
        <tag>ActiveMQ安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os模块]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F21%2Fos%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os 模块 os 模块是与操作系统交互的一个接口 模块方法 注释 os.getcwd() 获取当前工作目录，即当前 python 脚本工作的目录路径 os.chdir(&quot;dirname&quot;) 改变当前脚本工作目录；相当于 shell 下 cd os.curdir 返回当前目录: (&#39;.&#39;) os.pardir 获取当前目录的父目录字符串名：(&#39;..&#39;) os.makedirs(&#39;dirname1/dirname2&#39;) 可生成多层递归目录 os.removedirs(&#39;dirname1&#39;) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(&#39;dirname&#39;) 生成单级目录；相当于 shell 中 mkdir dirname os.rmdir(&#39;dirname&#39;) 删除单级空目录，若目录不为空则无法删除，报错；相当于 shell 中 rmdir dirname os.listdir(&#39;dirname&#39;) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录 os.stat(&#39;path/filename&#39;) 获取文件/目录信息 os.sep 输出操作系统特定的路径分隔符，Windows下为&quot;\\&quot;，Linux下为&quot;/&quot; os.linesep 输出当前平台使用的行终止符，Windows下为&quot;\t\n&quot;，Linux下为&quot;\n&quot; os.pathsep 输出用于分割文件路径的字符串，Windows下为;，Linux下为: os.name 输出字符串指示当前使用平台。Windows-&gt;&#39;nt&#39;，Linux-&gt;&#39;posix&#39; os.system(&quot;bash command&quot;) 运行shell命令，直接显示 os.environ 获取系统环境变量 os.path.abspath(path) 返回 path 规范化的绝对路径 os.path.split(path) 将 path 分割成目录和文件名二元组返回 os.path.dirname(path) 返回 path 的目录。其实就是 os.path.split(path) 的第一个元素 os.path.basename(path) 返回 path 最后的文件名。如何 path 以 / 或 \ 结尾，那么就会返回空值。即 os.path.split(path) 的第二个元素 os.path.exists(path) 如果 path 存在，返回 True；如果 path 不存在，返回 False os.path.isabs(path) 如果 path 是绝对路径，返回 True os.path.isfile(path) 如果 path 是一个存在的文件，返回 True。否则返回 False os.path.isdir(path) 如果 path 是一个存在的目录，则返回 True。否则返回 False os.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回 path 所指向的文件或者目录的最后存取时间 os.path.getmtime(path) 返回 path 所指向的文件或者目录的最后修改时间 os.path.getsize(path) 返回 path 的大小 列出指定目录下的所有文件和子目录 包括隐藏文件，并以列表方式打印 12345import osprint(os.listdir(r'.'))# 输出结果['01 时间模块.py', '02 random模块.py', '03 os模块.py', '今日内容.txt'] 获取 文件/目录 信息12345678910import osprint(os.stat('今日内容.txt'))# 输出结果os.stat_result(st_mode=33206, st_ino=4503599627409980, st_dev=239211959, st_nlink=1, st_uid=0, st_gid=0, st_size=280, st_atime=1526694304, st_mtime=1526694304, st_ctime=1526694102)# 获取文件大小，以 bytes 为单位print(os.stat('今日内容.txt').st_size)# 输出结果280 获取 文件 大小信息12345import osprint(os.path.getsize(r'E:\PycharmProjects\SH_s1\day07\今日内容.txt'))# 输出结果280 os.system(&quot;bash command&quot;) 方法 运行shell命令，直接显示 123456789import osos.system('tasklist') # 输出 Windows 下当前所有进程列表# os.system() 只是单纯的执行命令，并不能把命令执行后的结果做进一步的处理res = os.system('tasklist')print('res----&gt;', res) # res变量只是命令的执行成功与否的执行状态# 输出结果res----&gt; 0 os.environ 方法 获取系统环境变量 123456789全局的用于在程序任何地方都需要用到它的结果的时候import osos.environ['login'] = 'yes'print(os.environ['login'])# 输出结果yes os.path.split(path) 方法 将 path 分割成 目录 和 文件名 二元组返回 12345678910print(os.path.split('/a/b/c/d.txt'))# 输出结果('/a/b/c', 'd.txt')print(os.path.split('/a/b/c/d.txt')[0])print(os.path.split('/a/b/c/d.txt')[1])# 输出结果/a/b/cd.txt os.path.dirname(path) 方法 返回 path 的 目录其实就是 os.path.split(path) 的第一个元素 123print(os.path.dirname('a/b/c/d.txt'))# 输出结果a/b/c os.path.basename(path) 方法 返回 path 最后的 文件名如何 path 以 / 或 \ 结尾，那么就会返回空值即 os.path.split(path) 的第二个元素 123print(os.path.basename('a/b/c/d.txt'))# 输出结果d.txt os.path.join(path1[, path2[, …]]) 方法 用于拼接路径将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 123print(os.path.join('a', 'b', 'c', 'd.txt'))# 输出结果a\b\c\d.txt 123print(os.path.join('a', 'b', 'D:\\', 'c', 'd.txt'))# 输出结果D:\c\d.txt 123print(os.path.join('a', 'b', 'd', 'c', '/', 'd.txt'))# 输出结果/d.txt os.path.normcase(path) 方法 只用于 Windows 系统，规范 Windows 目录在 Windows 平台上会将路径中所有字符转换为小写，将路径中的左斜杠转换为 Windows 中的右斜杠在 Linux 和 Mac 平台上，该函数会原样返回 path 123print(os.path.normcase('c:/windOws\\system32\\'))# 输出结果c:\windows\system32\ os.path.normpath(path) 方法 用于规范路径如 (..) 点点 (/) 斜杠 123456789101112print(os.path.normpath('c:\\windOws/a/b/../system32\\'))# 输出结果c:\windOws\a\system32print(os.path.normpath('c://windows\\System32\\../Temp/'))# 输出结果c:\windows\Tempa = '/Users/jieli/test1/\\\a1/\\\\aa.py/../..'print(os.path.normpath(a))# 输出结果/Users/jieli/test1 os 路径处理 常用路径处理方法 123os.path.dirname(os.path.dirname(os.path.abspath(__file__)))os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) OpenStack 中获取路径方式 1234567891011121314151617181920OpenStack 获取路径方式res = os.path.join( os.path.abspath(__file__), '..', '..')print(res)print(os.path.normpath(res))# 输出结果E:\PycharmProjects\SH_s1\day07\03 os模块.py\..\..E:\PycharmProjects\SH_s1# 合并一下print(os.path.normpath( os.path.join( os.path.abspath(__file__), '..', '..' ))) 12345678910import osimport os,syspossible_topdir = os.path.normpath(os.path.join( os.path.abspath(__file__), os.pardir, # 上一级 os.pardir, os.pardir))sys.path.insert(0, possible_topdir) 参考文档http://www.cnblogs.com/linhaifeng/articles/6384466.html#_label3]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>os模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调整Linux的网络栈Buffer_Size来提升网络性能]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F20%2F%E8%B0%83%E6%95%B4Linux%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A0%88Buffer_Size%E6%9D%A5%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[调整 Linux 的网络栈 Buffer Size 来提升网络性能 有两台位于不同数据中心的服务器，都用来处理很多并行的大文件传输。但是处理大文件，网络性能非常差。并且涉及到一个大文件，会导致性能降级。怎样通过调整 Linux下面的 TCP 来解决这个问题？ 默认，Linux 的 stack 是没有为广域网之间的大文件高速传输而配置的，这样做是为了节约内存资源。为了使连接的系统服务之间能有更加高速的网络处理更多的网络包，你可以很容易的通过增加网络 buffer size 来调整 Linux 网络 stack。 默认的 Linux buffer size 的最大值是非常小的，tcp 的内存是基于系统的内存自动计算的，你能通过键入以下命令找到实际的值 1cat /proc/sys/net/ipv4/tcp_mem 默认的和最大的接收数据包内存大小 12cat /proc/sys/net/core/rmem_defaultcat /proc/sys/net/core/rmem_max 默认的和最大的发送数据包内存的大小 12cat /proc/sys/net/core/wmem_defaultcat /proc/sys/net/core/wmem_max 最大的内存 buffers 的选项 1cat /proc/sys/net/core/optmem_max 调整值 为所有的协议队列设置操作系统层面的最大的发送 buffer size(wmem) 和 接收 buffer size (rmem)为 12MB。换句话说，设置内存数量，分配给每一个为了传送文件而打开或者是创建的 tcp socket。 警告！在大多数的 Linux 中 rmem_max 和 wmem_max 被分配的值为 128k，在一个低延迟的网络环境中，或者是 apps 比如 DNS、Web Server，这或许是足够的。尽管如此，如果延迟太大，默认的值可能就太小了，所以请记录以下在你的服务器上用来提高内存使用方法的设置。 12echo 'net.core.wmem_max=12582912' &gt;&gt; /etc/sysctl.confecho 'net.core.rmem_max=12582912' &gt;&gt; /etc/sysctl.conf 还需要设置 minimum size, initial size, and maximum size in bytes 12echo 'net.ipv4.tcp_rmem= 10240 87380 12582912' &gt;&gt; /etc/sysctl.confecho 'net.ipv4.tcp_wmem= 10240 87380 12582912' &gt;&gt; /etc/sysctl.conf 打开 window scaling，这是一个用来扩展传输窗口的选项 1echo 'net.ipv4.tcp_window_scaling = 1' &gt;&gt; /etc/sysctl.conf 确保定义在 RFC1323 中的 timestamps 打开 1echo 'net.ipv4.tcp_timestamps = 1' &gt;&gt; /etc/sysctl.conf 确保 select acknowledgments 1echo 'net.ipv4.tcp_sack = 1' &gt;&gt; /etc/sysctl.conf 这个 “select acknowledgments” 不知道该如何翻译，翻译为“选择确认？” 当连接关闭的时候，TCP 默认缓存了很多连接指标在 route cache 中，以至于在不久的将来，连接建立的时候，可以用这些值来设置初始化条件。通常，这提升了整体的性能，但是，有时候会引起性能下降， 如果设置的话，TCP 在关闭的时候不缓存这些指标。 1echo 'net.ipv4.tcp_no_metrics_save = 1' &gt;&gt; /etc/sysctl.conf 当 interface 接收到的数据包数量比内核处理速度的快的时候， 设置 input 队列最大的 packets 数量值。 1echo 'net.core.netdev_max_backlog = 5000' &gt;&gt; /etc/sysctl.conf 现在重载这些改变，使其生效 1sysctl -p 使用 tcpdump 命令查看 通过 eth0 数据包流量的变化 1tcpdump -ni eth0 参考文档https://segmentfault.com/a/1190000000473365 推荐阅读 请参考内核文档/networking/ip-sysctl.txt获取更加多的信息 请查看 sysctl 的 man 手册]]></content>
      <categories>
        <category>Linux内核优化笔记</category>
      </categories>
      <tags>
        <tag>调整Linux的网络栈Buffer_Size来提升网络性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat中Connector常用配置]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F15%2FTomcat%E4%B8%ADConnector%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Tomcat 中 Connector 常用配置 模式 描述 BIO 阻塞式 I/O，采用传统的 java I/O 进行操作，该模式下每个请求都会创建一个线程，适用于并发量小的场景 NIO 同步非阻塞，比传统 BIO 能更好的支持大并发，Tomcat 8.0 后默认采用该模式 APR Tomcat 以JNI形式调用http服务器的核心动态链接库来处理文件读取或网络传输操作，需要编译安装 APR 库 AIO 异步非阻塞，Tomcat 8.0 后支持 配置方法：在 tomcat/conf/ 下 server.xml 12345`&lt;Connector port="8080" protocol="HTTP/1.1"/&gt;`BIO: protocol="org.apache.coyote.http11.Http11Protocol"NIO: protocol="org.apache.coyote.http11.Http11NioProtocol"AIO: protocol="org.apache.coyote.http11.Http11Nio2Protocol"APR: protocol="org.apache.coyote.http11.Http11AprProtocol" BIO（blocking I/O） 阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作（即 java.io 包及其子包）。默认的模式，性能最差，没有经过任何优化处理和支持。 NIO（non-blocking I/O） Java SE 1.4 及后续版本提供的一种新的 I/O 操作方式（即 java.nio 包及其子包）。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API。拥有比传统 I/O 操作（BIO）更好的并发运行性能。要让 Tomcat 以 NIO 模式来运行，修改配置文件：tomcat/conf/server.xml 修改以下内容123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 修改 protocol 的值为 org.apache.coyote.http11.Http11NioProtocol1234&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; 重启 Tomcat 后生效 在 Tomcat 6.0 之后，提供了 NIO 的方式，可以有效的提升性能，特别是在大量长连接/数据上传+下载等 Web 应用中此时 portocal=”org.apache.coyote.http11.Http11NioProtocol”Tomcat 支持：BIO，NIO，NIO2，APR 四种 I/O 模式，Tomcat 8.5 之前 默认为 BIO Tomcat 8.5 and 9.0 have completely dropped the BIO connector.Tomcat 8.5 和 9.0 完全删除了 BIO 连接器默认 NIO 模式 对于互联网应用，我们应该在 NIO、NIO2 之间做选择，因为它能够有效的提升性能（主要是并发能力）其中 NIO2 即为 AIO，需要 JDK 1.7+、Linux 2.6+ 才能支持。BIO：JDK 1.5+，tomcat 5.x+NIO：JDK 1.6+，tomcat 6.x+NIO2：JDK 1.7+，tomcat 7.x+为了保守起见，我们暂且基于 NIO 模式 查看 Tomcat Connector 运行模式方法一：在 http://x.x.x.x:8080/manager/status 中查看服务器状态 方法二：根据 Tomcat 启动日志信息判断BIO12INFO: Initializing ProtocolHandler ["http-bio-8080"]Aug 04, 2015 10:20:35 PM org.apache.coyote.AbstractProtocol init NIO12INFO: Initializing ProtocolHandler ["http-nio-8080"]Aug 04, 2015 10:27:58 PM org.apache.coyote.AbstractProtocol init APR12INFO: Initializing ProtocolHandler ["http-apr-8080"]Aug 04, 2015 10:33:45 PM org.apache.coyote.AbstractProtocol init 整合Tomcat apr 设置环境变量方法一：在 tomcat/bin/catalina.sh 中增加1行在 echo “Using CATALINA_BASE: $CATALINA_BASE” 的上一行添加CATALINA_OPTS=”-Djava.library.path=/data/apr/lib” 方法二：在 /etc/profile 中加入1export CATALINA_OPTS=-Djava.library.path=/usr/local/apr/lib 使配置生效1source /etc/profile 修改配置文件1234567vim tomcat/conf/server.xml &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;# 修改 `protocol` 的值为 `org.apache.coyote.http11.Http11NioProtocol`&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; 重启 Tomcat，启动日志出现以下内容证明此时以 APR 模式启动 参考文档：https://blog.csdn.net/fd2025/article/details/80007435]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat中Connector常用配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回到页首按钮显示百分比]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F11%2F%E5%9B%9E%E5%88%B0%E9%A1%B5%E9%A6%96%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E7%99%BE%E5%88%86%E6%AF%94%2F</url>
    <content type="text"><![CDATA[回到页首按钮显示百分比 Back-to-top 按钮显示百分比 编辑配置文件 Next主题配置文件 /hexo/themes/next/_config.yml 12# Scroll percent label in b2t button. scrollpercent: false 将 scrollpercen: 的值改为 true 即可]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>回到页首按钮显示百分比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加在线联系]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FHexo%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[Hexo添加在线联系 当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。 配置方法 首先到 DaoVoice 上注册一个账号，注册完成后会得到一个 app_idhttp://dashboard.daovoice.io 获取 appid 的步骤 在 DaoVoice 的应用设置 -&gt; 安装到网站中的找到自己的 app_id然后在主题 /next/layout/_partials/head.swig 文件中最后添加代码 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 主题配置文件中添加配置 在主题配置文件 /next/_config.yml 中添加相应的配置 123# Online contactdaovoice: truedaovoice_app_id: 这里输入前面获取的app_id 调整位置 最后聊天图标的位置可能和一些东西重叠这个使用可以在控制面板中应用设置 -&gt; 聊天设置里面设置相对右边和底部的位置 参考文档https://www.ezlippi.com/blog/2018/01/next-chat.htmlhttps://meta.tn/a/c40f12eb1b892bbb8cda053c03c688e3f20e4f642164080ef463cd4a7bc3b042http://www.niww.me/2018/03/02/hexo-daovoice/]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加在线联系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题背景]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FNext%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Next主题背景个性化DIY 整理了一下博客，加个背景图片（BackGroundImage）调整一下视觉感官，背景图片 是动态变化的，每次刷新都会更新一张图 一个图片网站 分享一个非常 Nice 的图片网站，感觉这个国外的图片社区网站真的秒杀一众图片网站啊，不仅图片质量高，免费，而且还提供了随机拉取图片的服务 API，太赞，对于想实现动态背景，简直是福音https://source.unsplash.com/ 添加背景图片 修改 \themes\next\source\css\_custom\custom.styl 文件这个是 Next 故意留给用户自己个性化定制一些样式的文件，添加以下代码 123456body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; URL 括号中直接添加图片的地址链接，也可以置换成你所喜欢的任意图片。repeat、attachment、position 就是调整图片的位置，不重复出现、不滚动等。]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next主题背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加看板娘]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2F%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98%2F</url>
    <content type="text"><![CDATA[添加看板娘 实现效果 用 Git Bash Here 在站点根目录执行如下代码 12cd D:\hexo\npm install hexo-helper-live2d --save 然后打开 /themes/next/layout/_layout.swig 将下面代码放到 &lt;/body&gt; 之前{ { live2d() } }注意：由于官方更新了包，所以画删除线的不用做了 然后在这里可以看到一些已有的模型，记下想要的模型名字，使用安装命令https://huaji8.top/post/live2d-plugin-2.0/ 1npm install "模型的包名" 模型的包名 12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 以 hijiki 为例12345678910$ npm install "live2d-widget-model-hijiki" --savenpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)+ live2d-widget-model-hijiki@1.0.5added 1 package and audited 3800 packages in 8.046sfound 2 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for details$ npm install live2d-widget-model-tororo --save 在 配置文件 末尾添加代码 安装完成后，还需要在一些小小的修改在 _config.yml（Hexo站点 或 Next主题 皆可）中，加入以下内容 /blog/_config.yml或/blog/next/themes/_config.yml 123456789101112131415## 看板娘live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki display: position: right width: 150 height: 300 mobile: show: true # false 手机端不显示 详细配置1234567891011121314151617181920live2d: enable: true # 是否开启 scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url model: use: live2d-widget-model-wanko # 调用模型名，必须要先下载 display: position: right # 在博客的左边还是右边显示 width: 150 # 边框宽度 height: 300 # 边框高度 mobile: show: true # 是否在手机上显示 # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 根据需要可修改use:后的包名；调整长度和宽度；选择是否停用插件等。 参考文档https://wangyuyang.me/2018/04/06/对基于HEXO的NexT主题的美化/https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.mdhttps://alvabill.ml/hexo搭建个人博客-NexT主题优化/]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>添加看板娘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome自带的长截屏功能]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FChrome%E8%87%AA%E5%B8%A6%E7%9A%84%E9%95%BF%E6%88%AA%E5%B1%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Chrome自带的长截屏功能 在 Google Chrome 里面，打开开发人员工具 按F12或网站上任意空白处右键 – 选择 “检查” 或者“审查元素” 快捷键 Ctrl + Shift + P，会看到右边的审查元素出现了一个输入框输入 screenshot 然后回车保存图片]]></content>
      <categories>
        <category>Chrome笔记</category>
      </categories>
      <tags>
        <tag>Chrome自带的长截屏功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chevereto图床]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FChevereto%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[Chevereto图床 Chevereto 是一款采用 PHP 语言开发的网络相册脚本程序，支持多语言，提供中文语言包的下载的开源在线图片存储分享服务系统，支持本地上传和在线获取两种图像上传方式，并集成了 TinyURL 网址缩短服务。Chevereto 这套程序可以像 Discuz 或 WordPress 一样随意架设在任何空间上。而它的功能除了一般图片空间单纯的从电脑上传图片外，也支援利用网址也可以上传，最屌的是还有 TinyURL 的缩短网址的功能可以使用，因此这套 Chevereto 可以说是比市面上的图片空间好太多了。他是把图片上传到空间的，相信一般大家都一定会使用免费空间，在此建议大家在挑主机时尽可能使用 cPanel 的空间，因为可以使用 cPanel 特有的 「Cron Jobs」 来备份你上传的图片。 Chevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirements Clevereto 错误 404 解决方法 如果 Web服务 是 Nginx，基本第一步安装好后再次打开网站会出现 404 错误。因为 Chevereto 默认提供基于 Apache 环境的伪静态规则 需要设置以下 Rewrite 伪静态规则123456789101112131415location / &#123; if (-f $request_filename/index.html)&#123; rewrite (.*) $1/index.html break; &#125; if (-f $request_filename/index.php)&#123; rewrite (.*) $1/index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125; try_files $uri $uri/ /api.php;&#125;location /admin &#123; try_files $uri /admin/index.php?$args;&#125; 官方推荐配置123456789101112131415161718192021222324252627282930# Disable access to .ht* fileslocation ~ /\.ht &#123; deny all;&#125;# Disable access to sensitive files in app pathlocation ~ /(app|content|lib)/.*\.(po|php|lock|sql)$ &#123; deny all;&#125;# Disable log on not found images + image replacement# Image not found replacementlocation ~* (jpe?g|png|gif) &#123; log_not_found off; error_page 404 /content/images/system/default/404.gif;&#125;# Enable CORS header (avoids font rendering issues)location ~ \.(ttf|ttc|otf|eot|woff|woff2|font.css|css|js)$ &#123; add_header Access-Control-Allow-Origin "*";&#125;# Force serve upload path as static contentlocation ~ /images &#123;&#125;# Pretty URLs# Route dynamic request to index.phplocation / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 参考文档 https://www.zhujibiji.com/2017/11/install-chevere-to-build-your-image-sharing-website/https://lala.im/2478.html]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>Chevereto图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图床的选择]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2F%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%BA%8A%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[关于图床的选择为什么要使用图床？ Hexo 文章中的图片，我们可以放到本地，然后一起部署到 Github 中，这样完全没有问题。然而 github pages 空间毕竟有限（貌似只有 300M）,另外图片的管理太混乱了，一些原创的图片可能被盗链。 很多技术人写作都用的是 MarkDown 轻量级标记语言进行博客写作，这种写作让我们不用像使用 Word 那样那么麻烦地调整排版和格式，只需专心写作并且照样完成排版的一种方式。但是，基本所有支持 MarkDown 本地写作工具都只能采用导入本地图片引用的方式，对于一篇需要大量图片阐述的文章以及该文章上传至网络图片丢失，这不得不是个很糟糕的问题。那么有什么比较好的解决方式吗？很多人采用的图片寄存于网络，用服务厂商作为图片存储的地方，大家都叫为 「图床」 。 那么像 CSDN 博客、简书平台不是都可以吗？是的，它们平台写文章的时候都可以导入图片然后得到一个图片网络地址。但是，图片数量多，一张一张上传，这不是贼烦嘛！那么有专门可以作 「图床」 功能的服务商吗？有的，比如七牛云。 网上谷歌搜下还是能搜到很多图床网站的，先随便列举一些 公共图床SM.MS https://sm.ms/SM.MS 是由 V2EX @Showfom 自建的，无外链限制，无流量限制的图床，支持 HTTPS，速度不错，已经运行两年多了。 极简图床 https://jiantuku.com/#/ 路过图床 https://imgchr.com/ Imgur https://imgur.com/Imgur 是一家国外老牌的图片存储服务商，国外速度很快，口碑不错，支持 HTTPS。但是国内速度很不稳定，所以追求国内速度的同学慎用。 Qchan图床http://tuchuang.org/ 微博图床 微博图床，可以自定义支持七牛，界面简洁美观，支持 Chrome 插件，注册后还可以同步上传历史。 自建图床 目前自建图床方案有两种 是利用云服务商提供的存储服务来作为图床，通过 API 来管理图片 是在 VPS 上安装开源的图片或文件管理程序，只要能提供外链，基本都可以作为图床来用。 建图床（云服务） 七牛云，又拍云，阿里云OSS 自建图床（开源方案） 如果你有 VPS，并且网络速度 OK 的话，自建图床也是一个不错的选择。 Lychee https://github.com/electerious/LycheeLychee 是一个开源免费的基于 PHP 的图片管理系统，支持 Docker 部署，可以直接当做图床来用，Lychee 还支持很多扩展。 树洞外链 https://yun.aoaoao.me/https://github.com/HFO4/shudong-share树洞外链 是一款免费开源的 PHP 外链网盘系统，界面简洁友好，支持七牛、本地、远程、阿里云OSS、又拍云五种储存方式，支持多用户系统，多上传方案策略。 Chevereto https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirementsChevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。 使用图床的目的是希望文章的图片资源能有更好的加载速度和稳定的显示效果。]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>关于图床的选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之堆溢出处理]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java 虚拟机之堆溢出处理在 Java 程序的运行过程中，如果堆空间不足，则有可能抛出内存溢出错误 (Out Of Memory)，简称为 OOM。 如下文字显示了典型的堆内存溢出 1Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:20) 一旦发生这类问题，系统就会被迫退出。如果发生在生产环境，可能会引起严重的业务中断。为了能够不断改善系统，避免或减少这类错误的发生，需要在发生错误时，获得尽可能多的现场信息，以帮助研发人员排查现场问题。 Java 虚拟机提供了参数 -XX:+HeapDumpOnOutOfMemoryError，使用该参数，可以在内存溢出时导出整个堆信息。和它配合使用的还有 -XX:HeapDumpPath，可以指定导出堆的存放路径。 使用如下参数执行上述代码 1-Xms5m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/app/tomcat/logs/P02.dump 显然 20M 堆空间不足以容纳 25M 内存，系统比如发生内存溢出，在发生错误后，控制台输出如下 1java.lang.OutOfMemoryError: Java heap space Dumping heap to /data/app/tomcat/logs/P02.dump... Heap dump file created [23067302 bytes in 0.160 secs] Exception in thread “main” java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:19) 可以看到，虚拟机将当前的堆导出，并保存到 /data/app/tomcat/logs/P02.dump 文件下启动最小空间 5M，配了 20M 最大空间 ，发生了 内存溢出错误，dump 路径为 /data/app/tomcat/logs/P02.dump 使用 MAT 等工具打开该文件进行分析，可以很容易地找到这些 byte 数组和保存它们的 Vector 对象实例]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java虚拟机之堆溢出处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编译安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FPython%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一般情况下，Linux 都会预装 Python，但是这个预装的 Python 版本一般都比较低，很多 Python 的新特性都没有，必须重新安装新一点的版本Python下载地址https://www.python.org/https://www.python.org/ftp/python/https://www.python.org/ftp/python/2.7.15/https://www.python.org/ftp/python/3.6.5/ 查看 Python 版本1234567python -V# CentOS 6.xPython 2.6.6# CentOS 7.xpython 2.7.5 做好链接，保留旧版本 pythoncd /usr/bin/cp /usr/bin/python /usr/bin/python_bak 如果发现 yum 不能用了，解决 yum 无法使用的问题因为 yum 依赖系统默认安装的 python 版本, 处理如下：vim /usr/bin/yum#!/usr/bin/python修改为-&gt; #!/usr/bin/python2.6 或 #!/usr/bin/env python2.6import systry: import yumexcept ImportError:……省略…… 这里不更改 原 Python 版本 安装依赖1yum -y install readline readline-devel sqlite sqlite-devel zlib zlib-devel openssl openssl-devel bzip2 bzip2-devel bzip2-libs 缺少 readline 支持的 IPythonWARNING: IPython History requires SQLite, your history will not be savedWARNING: Readline services not available or not loaded.WARNING: The auto-indent feature requires the readline library 下载 Python12wget -c https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xzwget -c https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tar.xz 安装 Python安装 Python 2.7.15123456tar -xvf Python-2.7.15.tgzcd Python-2.7.15/./configure \--prefix=/data/python2.7.15 --enable-optimizationsmake -j 4make install 安装 Python 3.6.5123456tar -xvf Python-3.6.5.tgzcd Python-3.6.5/./configure \--prefix=/data/python3.6.5 --enable-optimizationsmake -j 4make install 添加 Python 环境变量1234vim /etc/profileexport PATH=$PATH:/data/python2.7.15/binexport PATH=$PATH:/data/python3.6.5/binsource /etc/profile 或 12echo -e '\nexport PATH=$PATH:/data/python2.7.15/bin' &gt;&gt; /etc/profileecho -e 'export PATH=$PATH:/data/python3.6.5/bin' &gt;&gt; /etc/profile PS：如果安装 easy_intall 时报 zlib 没有安装，Linux下直接 yum -y install zlib zlib-devel，然后重新编译 Python2.7.15 继续就可以了cp /usr/bin/python /usr/bin/python_bakln -svnf /data/python2.7.15/bin/python2.7 /usr/bin/python setuptools 安装 下载地址https://pypi.python.org/pypi/setuptoolshttps://pypi.python.org/simple/setuptools/ 1234tar -zxvf setuptools-39.2.0.tar.gzcd setuptools-39.2.0python3 setup.py buildpython3 setup.py install IPython 是一个 python 的交互式 Shell，比默认的 Python Shell 好用一点，支持变量自动补全，自动缩进，支持 Bash Shell 命令，内置了许多很有用的功能和函数安装 IPythonIPython 下载地址https://pypi.org/project/ipython/ 1234tar -zxvf ipython-6.4.0.tar.gzcd ipython-6.4.0/python3 setup.py buildpython3 setup.py install 安装 pip pip 下载地址https://pypi.org/project/pip/ 1234tar -xvf pip-10.0.1.tar.gzcd pip-10.0.1/python3 setup.py buildpython3 setup.py install pip 安装 python 第三方库1234pip3 install requestspip3 install pyapi-gitlabpip3 install readlinepip3 install rlcompleter2]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志切割]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志切割 12345678910111213141516vim logcut.sh#!/bin/bashday=$(date +"%Y-%m-%d")yesterday=$(date -d "yesterday" +%Y-%m-%d)logsdir=(/data/app/*/logs)for logdir in $&#123;logsdir[@]&#125;do for logfile in $(ls $&#123;logdir[@]&#125; | egrep "stdout.log|catalina.out") do cp $logdir/$logfile $logdir/$&#123;logfile%.log&#125;.$&#123;day&#125;.log cp $logs/$file $logs/$&#123;file%.out&#125;.$&#123;day&#125;.out cat /dev/null &gt; $logdir/$logfile donedone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志切割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志压缩]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志压缩打包 压缩 7 天前日志每个月 1 号，创建上个月的目录，年-月 2018-04将 gz 压缩文件拷贝到 年-月 2018-04 目录中 1234567891011121314151617181920vim compresslog.sh#!/bin/bashday=$(date +"%d")month=$(date +"%Y-%d")lastmonth=$(date +"%Y-%m" -d "last month")lastweek=$(date +"%Y-%m-%d" -d "last week")logsdir=(/data/app/*/logs)for logs in $&#123;logsdir[@]&#125;do find $logs/ -mtime +7 -regextype posix-extended -regex ".*\.(log|out|txt)" -exec gzip &#123;&#125; \;done[ $day == 01 ] &amp;&amp; cd $&#123;logsdir[@]&#125; &amp;&amp; mkdir -pv $lastmonthfor logdir in $&#123;logsdir[@]&#125;do [ -d $logdir/$lastmonth ] || mkdir -pv $logdir/$lastmonth mv $logdir/*gz $logdir/$lastmonthdone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM 磁盘扩展]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FLVM%E7%A3%81%E7%9B%98%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[LVM 磁盘扩展 查看磁盘空间1df -h 查看 LV 信息1lvs 查看 VG 信息1vgs 创建 PV1pvcreate /dev/vdb 扩展已有的 VG 容量1vgextend vgdata /dev/vdb Couldn&#39;t&#39; create temporary archive name.因为磁盘实在太小了或已经没有空间了，无法执行，删除一些数据就好了 12vgextend vgdata /dev/sdaVolume group "vgdata" successfully extended 查看 VG 信息1vgs 扩展已有 LV 容量12lvextend -L +99.99G -n /dev/vgdata/lvdatalvextend -L +1020M -n /dev/vgdata/lvdata -L # 指定逻辑卷的大小，单位为 kKmMgGtT 字节，也就是 Size-l # 指定逻辑卷的大小，单位为 PE 数 重新加载逻辑卷12345# 加载 ext 文件系统resize2fs /dev/vgdata/lvdata# 加载 xfs 文件系统xfs_growfs /dev/vgdata/lvdata]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>LVM 磁盘扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建LVM]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FLVM%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[创建 LVM LVM 创建过程创建PV -&gt; 创建VG -&gt; 创建LV -&gt; 格式化LV -&gt; mount挂载 常用命令pvcreate 设备名vgcreate 卷组名 物理卷lvcreate -L 大小 -n 逻辑卷名 卷组名 LVM 常用命令表 功能 管理物理卷 管理卷组 管理逻辑卷 Scan 扫描 pvscan vgscan lvscan Create 创建 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Extend 扩展 vgextend lvextend Reduce 减少 vgreduce lvreduce 安装 LVM1yum -y install lvm2 创建 PV12pvcreate /dev/vdbPhysical volume "/dev/vdb" successfully created 创建 VG12vgcreate vgdata /dev/vdbVolume group "vgdata" successfully created 创建 LV12345lvcreate -L 49.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created.lvcreate -L 99.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created. 文件系统格式化12345# 格式化 ext 文件系统mkfs.ext4 /dev/vgdata/lvdata# 格式化 xfs 文件系统mkfs.xfs /dev/vgdata/lvdata 挂载逻辑卷到目录12mkdir -pv /datamount /dev/vgdata/lvdata /data 编辑 /etc/fstab1234vim /etc/fstab...省略.../dev/mapper/vgdata-lvdata /data xfs defaults 0 0...省略... ###]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>创建LVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加文章结束标记]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FNext%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[添加文章结束标记 编辑 /hexo/themes/next/layout/_macro/post.swig 文件在 if theme.wechat_subscriber.enabled and not is_index 上面添加如下代码 代码片段123456&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt;&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125; &lt;div&gt; &#123;% include 'wechat-subscriber.swig' %&#125; &lt;/div&gt;&#123;% endif %&#125; 显示效果1————— The End —————]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加文章结束标记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加音乐]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[Next 添加音乐 去网易云音乐搜索喜欢的音乐，点击生成外链播放器，复制代码直接放到博文末尾即可height 设为 0 可隐藏播放器，但仍然可以播放音乐auto 设成 0 可手动播放，默认是 1 自动播放 编辑 /hexo/themes/next/layout/_custom/sidebar.swig 文件里，播放器会显示在站点预览中或编辑 /hexo/themes/next/layout/_macro/sidebar.swig 文件里 123# 将代码粘贴到一个合适的位置&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2188265841&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加分类及标签]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FHexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Hexo添加分类及标签创建 分类 选项 生成 分类 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page categories 成功后会提示 1INFO Created: ~/hexo/source/categories/index.md 根据上面的路径，找到 index.md 这个文件，打开后默认内容是这样的 1234---title: 文章分类date: 2018-06-06 22:49:07--- 添加 type: &quot;categories&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "categories"--- 给文章添加 “categories” 属性 打开需要添加分类的文章，为其添加 categories 属性下方的 categories: Hexo笔记 表示添加这篇文章到 Hexo笔记 这个分类注意：hexo 一篇文章只能属于一个分类，也就是说如果在 - Hexo笔记 下方添加 - xxxhexo 不会产生两个分类，而是把分类嵌套（即该文章属于 - Hexo笔记 下的 - xxx 分类） 123456---title: Hexo添加分类及标签date: 2018-06-06 22:44:41categories: - Hexo笔记--- 至此，成功给文章添加分类，点击首页的 分类 可以看到该分类下的所有文章当然，只有添加了 categories: xxx 的文章才会被收录到首页的 分类 中 创建标签选项 生成 标签 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page tags 成功后会提示 1INFO Created: ~/hexo/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的 1234---title: 标签date: 2018-06-06 22:49:07--- 添加 type: &quot;tags&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "tags"--- 给文章添加tags属性打开需要添加标签的文章，为其添加 tags 属性下方的tags:Hexo添加分类及标签- 表格- 表单验证就是这篇文章的标签了 12345678910---title: Hexo添加分类及标签date: 2018-06-06 22:49:07categories: - Hexo笔记tags:- Hexo添加分类及标签- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的标签可以看到该标签下的所有文章当然，只有添加了 tags: xxx 的文章才会被收录到首页的标签中细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的所以我们可以打开 \hexo\scaffolds/post.md 文件，在 tages:上面加入categories:1234567vim /hexo/scaffolds/post.md---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 保存后执行hexo new &quot;文章名&quot;命令生成的文件，页面里就有categories:项了\hexo\scaffolds\ 目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加分类及标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置网站的图标Favicon]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FHexo%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%AB%99%E7%9A%84%E5%9B%BE%E6%A0%87Favicon%2F</url>
    <content type="text"><![CDATA[Hexo 设置网站的图标 Favicon ico图标使用 32x32去别的网站下载或 PS 制作，并将图标名称改为 favicon.ico然后把图标放在 \next\themes\next\source\images\ 目录下也可以放在 hexo\source\images 目录下，这个目录没有可以自己手动创建 修改 next主题配置文件，\next\themes\next\_config.yml 文件12345678favicon: small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo设置网站的图标Favicon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加访问量]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Next添加访问量 使用 Next 主题自带的不蒜子统计，仅限于在文章页面显示阅读量，不在首页显示 修改 themes\next\ _config.yml 文件123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数(UV) site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量(PV) site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 总访问量 (PV) 总访问量独立访客 (UV) 访问人数网站的浏览次数为 PV网站的访客数为 UVPV 计算方式，单个用户连续点击 N 篇文章，记录 N 次访问量UV 计算方式，单个用户连续点击 N 篇文章，只记录 1 次访客数可以根据需要添加相应的统计功能 查看底部显示效果]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加访问量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next修改小型代码块颜色]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E4%BF%AE%E6%94%B9%E5%B0%8F%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%9D%97%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Next 修改小型代码块颜色 修改 \themes\next\source\css\ _variables\base.styl 文件可以加入自定义颜色，如下中已经给出了许多种颜色 12345678910111213// Colors// colors for use across theme.// --------------------------------------------------$whitesmoke = #f5f5f5$gainsboro = #eee$gray-lighter = #ddd...$blue = #0684bd$blue-deep = #262a30$orange = #fc6423 修改 $code-background 与 $code-foreground 的值 以下的各个参数自己根据需求进行设置即可 1234567// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 13px$code-foreground = $black-light //设置成自己喜欢的颜色即可$code-background = $gainsboro //设置成自己喜欢的颜色即可$code-border-radius = 4px 在 \themes\next\source\css\ _variables\base.styl 文件内还有很多的参数，可以酌情进行修改]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next修改小型代码块颜色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next头像圆形旋转]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E5%A4%B4%E5%83%8F%E5%9C%86%E5%BD%A2%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[头像变成圆形，鼠标停留在上面发生旋转效果 介绍一下实现头像圆形，鼠标经过旋转或者一直让旋转效果修改 Hexo 目录下 \themes\next\source\css\_common\components\sidebar\sidebar-author.styl 文件 头像圆形修改 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转修改 修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 方法二：修改 themes/next/source/css/_common/components/sidebar/sidebar-author.styl 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 头像循环旋转效果修改 修改 sidebar-author.styl 文件，添加如下代码 12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next头像圆形旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置首页隐藏指定文章]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Next设置首页隐藏指定文章 修改 next 主题文件夹下的 layout 中的 index.swig 文件定位修改 post_template.render(post, true) 1234567891011\themes\next\layout\index.swig...省略...&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.visible !== 'hide' %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt;...省略... 其中修改的是为文章的首页显示添加判断条件 在新的 post 中添加 visible 字段来控制是否首页显示 例如：当前这篇文章 12345title: Next设置首页隐藏指定文章date: 2018-06-06 01:08:59categories: Next笔记tags: Next设置首页隐藏指定文章visible: hide 这里如果加上 hide 则该文章就不会在文章首页显示，如果留空则表示默认显示]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置首页隐藏指定文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks 安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FShadowsocks%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Shadowsocks 安装 123456yum -y install python-pippip install --upgrade pippip install shadowsockswhich ssserverpip install M2Cryptopip install gevent 123456789101112131415161718vim /etc/systemd/system/shadowsocks.service[Unit]Description=Shadowsocks[Service]Type=simpleTimeoutStartSec=0PIDFile=/data/shadowsocks/var/run/ssserver.pidExecStart=/usr/bin/ssserver -c /data/shadowsocks/conf/shadowsocks.json -d start \ --pid-file /data/shadowsocks/var/run/ssserver.pid \ --log-file /data/shadowsocks/logs/ssserver.logRestart=on-abortRestartSec=10sPrivateTmp=true[Install]WantedBy=multi-user.targettail -f /data/shadowsocks/logs/ssserver.log 123456789101112131415mkdir -pv /data/shadowsocks/&#123;conf,logs,var/run&#125;cd /data/shadowsocks/vim shadowsocks.json&#123; "server":"149.28.231.171", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "8888":"gmlyo", "8889":"glmyo" &#125;, "timeout":300, "method":"aes-256-cfb", "fast_open":false&#125; 1234567systemctl daemon-reloadsystemctl start shadowsockssystemctl -l status shadowsockssystemctl enable shadowsockssystemctl stop shadowsockssystemctl restart shadowsocksjournalctl -fu shadowsocks 12345678910systemctl status firewalldfirewall-cmd --list-allfirewall-cmd --list-servicesfirewall-cmd --get-servicesfirewall-cmd --zone=public --add-port=8888/tcp --permanentfirewall-cmd --zone=public --add-port=8889/tcp --permanentfirewall-cmd --reloadfirewall-cmd --zone=public --query-port=1985/tcpfirewall-cmd --zone=public --list-ports]]></content>
      <categories>
        <category>Shadowsocks笔记</category>
      </categories>
      <tags>
        <tag>Shadowsocks 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat_APR_安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F05%2FTomcat_APR_%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Tomcat APR 安装 APR(Apache portable Run-time libraries) 可移植运行时库，是 Apache HTTP 服务的支持库，提供了一组映射到下层操作系统的 API。Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高 Tomcat 对静态文件的处理性能。改善 Tomcat 对静态文件的处理性能，同时如果使用了 HTTPS 方式传输的话，也可以提升 SSL 的处理性能。默认情况下，Tomcat 是用 BIO 的方式来实现网络通信的，性能非常低。Tomcat apr 也是在 Tomcat 上运行高并发应用的首选模式。APR 使用 JNI 的方式来读取文件以及进行网络传输，从操作系统级别来解决异步的 I/O 问题，大幅度的提高性能。如果操作系统不支持某个特定的功能，APR 将提供一个模拟的实现，这样程序员使用 APR 编写真正可在不同平台上移植的程序 安装依赖12345Tomcat 和 JDKyum install -y apr-develyum install -y gcc gcc-develyum install -y openssl openssl-develyum install -y expat-devel 下载 apr 下载地址：https://apr.apache.org/download.cgi 1234cd /data/tools/wget -c http://mirrors.shu.edu.cn/apache//apr/apr-1.6.3.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-util-1.6.1.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-iconv-1.2.2.tar.gz 安装 apr1234567891011121314151617181920212223# 解压并进入解压目录cd /data/tools/tar -zxvf apr-1.6.3.tar.gzcd apr-1.6.3/# 配置，安装在 /data/ 目录下./configure --prefix=/data/apr# 报错信息config.status: executing libtool commandsrm: cannot remove 'libtoolT': No such file or directoryconfig.status: executing default commands# 解决方法# 编辑 configure 文件cd apr-1.6.3/vim configure把 $RM "$cfgfile" 这行代码注释掉或 把 $RM "$cfgfile" 这行删除掉或 写成 $RM -f "$cfgfile"重新再运行 ./configure 就可以了# 编译安装make -j 4make install 安装 apr-iconv1234567891011# 解压并进入解压目录cd /data/tools/tar -zxvf apr-iconv-1.2.2.tar.gzcd apr-iconv-1.2.2/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-iconv \--with-apr=/data/apr# 编译安装make -j 4make install 安装 apr-util123456789101112131415161718192021222324252627# 解压并进入解压目录cd /data/tools/tar -zxvf apr-util-1.6.1.tar.gzcd apr-util-1.6.1/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-util \--with-apr=/data/apr \--with-apr-iconv=/data/apr-iconv/bin/apriconv# 编译安装make -j 4# 报错信息xml/apr_xml.c:35:19: fatal error: expat.h: No such file or directory #include &lt;expat.h&gt; ^compilation terminated.make[1]: *** [xml/apr_xml.lo] Error 1make[1]: Leaving directory `/data/tools/apr-util-1.6.1'make: *** [all-recursive] Error 1# 解决办法# 缺少 expat 开发库，安装 expat 库yum install -y expat-devel# 重新执行make -j 4make install 配置 Tomcat 使用 apr 库 什么是 tomcat-native ？tomcat-native 库为 Tomcat 提供了本地实现tomcat-native 依赖于三个组件：APR，OpenSSL，JDK 大致就是通过 tomcat-native 库，使 tomcat 运行时通过 APR 更多的调用本地 API，达到提升性能的目的。由于依赖关系，安装时，先安装 APR，OpenSSL，然后再安装 tomcat-native，最后配置 tomcat 启动时依赖的库路径。 安装配置 Tomcat native 具体的安装步骤其实在 tomcat 自带的 tomcat-native.tar.gz 文件中就有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 进入 Tomcat bin 目录cd /data/app/tomcat/bin/# 解压 tomcat-native.tar.gz 后进入解压目录tar -zxvf tomcat-native.tar.gz# cd tomcat-native-1.2.8-src/native/ # Tomcat7cd tomcat-native-1.1.33-src/jni/native/# 配置 指定 JDK 的目录并加入 SSL./configure \--prefix=/data/apr \--with-apr=/data/apr/bin/apr-1-config \--with-java-home=/data/jdk1.8.0_172 \--with-ssl=yes# 编译安装make -j 4make installwarning: remember to run 'libtool --finish /usr/local/apr/lib'libtool --finish /data/apr/lib-bash: libtool: command not foundyum -y install libtool libtool-devellibtool --finish /data/apr/lib###################################################################################################cd tomcat-native-1.2.16-src/native//data/apr/build-1/libtool --mode=install /bin/install -c -m 755 libtcnative-1.la /data/apr/liblibtool: install: /bin/install -c -m 755 .libs/libtcnative-1.so.0.2.16 /data/apr/lib/libtcnative-1.so.0.2.16libtool: install: (cd /data/apr/lib &amp;&amp; &#123; ln -s -f libtcnative-1.so.0.2.16 libtcnative-1.so.0 || &#123; rm -f libtcnative-1.so.0 &amp;&amp; ln -s libtcnative-1.so.0.2.16 libtcnative-1.so.0; &#125;; &#125;)libtool: install: (cd /data/apr/lib &amp;&amp; &#123; ln -s -f libtcnative-1.so.0.2.16 libtcnative-1.so || &#123; rm -f libtcnative-1.so &amp;&amp; ln -s libtcnative-1.so.0.2.16 libtcnative-1.so; &#125;; &#125;)libtool: install: /bin/install -c -m 755 .libs/libtcnative-1.lai /data/apr/lib/libtcnative-1.lalibtool: install: /bin/install -c -m 755 .libs/libtcnative-1.a /data/apr/lib/libtcnative-1.alibtool: install: chmod 644 /data/apr/lib/libtcnative-1.alibtool: install: ranlib /data/apr/lib/libtcnative-1.alibtool: finish: PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/data/jdk1.8.0_144/bin:/data/jdk1.8.0_144/jre/bin:/root/bin:/sbin" ldconfig -n /data/apr/lib----------------------------------------------------------------------Libraries have been installed in: /data/apr/libIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the '-LLIBDIR'flag during linking and do at least one of the following: - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the 'LD_RUN_PATH' environment variable during linking - use the '-Wl,-rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to '/etc/ld.so.conf'See any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------# 将 apr 加载到 ldconfig 中vim /etc/ld.so.conf.d/apr.conf/data/apr/lib/data/apr-util/lib/data/apr-iconv/lib# 重新加载以下 ldconfigldconfig -v | grep apr/data/apr/lib: libapr-1.so.0 -&gt; libapr-1.so.0.6.3/data/apr-util/lib: libaprutil-1.so.0 -&gt; libaprutil-1.so.0.6.1/data/apr-iconv/lib: libapriconv-1.so.0 -&gt; libapriconv-1.so.0.2.2 CentOS 6.x 安装配置 Tomcat native CentOS 6.x 会出现以下这类问题 1234checking OpenSSL library version &gt;= 1.0.2... Found OPENSSL_VERSION_NUMBER 0x1000105f (OpenSSL 1.0.1e 11 Feb 2013)Require OPENSSL_VERSION_NUMBER 0x1000200f or greater (1.0.2)configure: error: Your version of OpenSSL is not compatible with this version of tcnative OpenSSL 版本与 tcnative 版本不兼容CentOS 7.2 或以上版本不会出现这类问题需要手工安装 OpenSSL 1.0.2 或以上版本 123456789101112# 下载 OpenSSLwget -c https://www.openssl.org/source/openssl-1.0.2o.tar.gz或wget -c https://www.openssl.org/source/openssl-1.1.0h.tar.gz# 安装 OpenSSLtar -xvf openssl-1.1.0h.tar.gzcd openssl-1.1.0h./config --prefix=/usr/local/openssl./config -tmake -j 4make install 123456789101112131415161718192021222324252627282930# 将 openssl 的 lib 加入系统 ldconfig 中vim /etc/ld.so.conf.d/openssl.conf/usr/local/openssl/lib# 加载一下ldconfig -vldconfig -v | grep libssl# 查看 OpenSSL 版本/usr/local/openssl/bin/openssl version -a# 如果遇到以下错误openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directoryopenssl: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory# 是由于 OpenSSL 库的位置不正确造成的# 做一下软链接，就好了ln -svnf /usr/local/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1ln -svnf /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1# 配置环境变量vim /etc/profile.d/openssl.sh#!/bin/bashexport PATH=$PATH:/usr/local/openssl/binopenssl version -a# 或把原来的命令备份一下，做个软链接ll -h /usr/bin/opensslcp /usr/bin/openssl&#123;,_bak&#125;ln -svnf /usr/local/openssl/bin/openssl /usr/bin/openssl 有 两 种方式配置 Tomcat 使用 apr 库方式一：配置 Tomcat Native 环境变量 在 Linux 系统中，只要 $LD_LIBRARY_PATH 变量值所在路径包含 Tomcat 本地库默认就使用 org.apache.coyote.http11.Http11AprProtocol 12345vim /etc/profile.d/apr.sh#!/bin/bashexport LD_LIBRARY_PATH=/data/apr/libsource /etc/profile 方式二：将 apr 库路径参数添加到 Tomcat 系统变量中（推荐） 编辑 $CATALINA_HOME/bin/setenv.sh 文件（如果文件不存在，新建文件） 1export CATALINA_OPTS="$CATALINA_OPTS -Djava.library.path=/data/apr/lib" 修改 $TOMCAT_HOME/conf/server.xml 12345&lt;Connector port="8000" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443"protocal 修改为 org.apache.coyote.http11.Http11AprProtocol，重启 tomcat 测试 启动 Tomcat，若在控制台或日志出现类似如下示例信息则表示 APR 配置成功 1INFO: Loaded APR based Apache Tomcat Native library 1.1.33. 检查是否安装成功如果看到下面的启动日志，表示成功 123456Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["http-apr-8080"]Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["ajp-apr-8009"]Sep 17, 2017 1:59:19 PM org.apache.catalina.startup.Catalina startINFO: Server startup in 31002 ms]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat_APR_安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不通过inventory文件，指定host运行Ansible]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F05%2F%E4%B8%8D%E9%80%9A%E8%BF%87inventory%E6%96%87%E4%BB%B6%EF%BC%8C%E6%8C%87%E5%AE%9Ahost%E8%BF%90%E8%A1%8CAnsible%2F</url>
    <content type="text"><![CDATA[如何不通过 inventory 文件，直接指定 host 运行 Ansible？ 使用过 ansible 的都知道，不管是运行 Ad-Hoc 还是 playbook，都需要指定一个 inventory 文件，或者使用默认的 inventory 文件。但是现在有一个主机，它尚未在 inventory 文件中配置，那么我们该如何用 ansible 对其进行操作呢？ 一般我们执行都是这样的 12345ansible 192.168.35.215 -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125; 这时需要在 inventory 文件 /etc/ansible/hosts 中配置 192.168.35.215 信息 12[NgxProxy]192.168.35.215 如果没有在 inventory 文件中配置该主机信息，又想用 ansible 对其进行操作就需要用到逗号 , 字符，使用方法如下 123456# Host and IP addressansible all -i example.com,ansible all -i 93.184.216.119,# Requires 'hosts: all' in your playbookansible-playbook -i example.com, playbook.yml 需要注意的是，需要指定范围为 all 12345ansible all -i 192.168.35.215, -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;]]></content>
      <categories>
        <category>Ansible笔记</category>
      </categories>
      <tags>
        <tag>如何不通过 inventory 文件，直接指定 host 运行 Ansible？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客生成一个站点地图]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[给博客生成一个站点地图 安装 hexo-generator-seo-friendly-sitemap1npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件 _config.yml 中添加12sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客生成一个站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客添加feed]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[给博客添加 feed 安装 hexo-generator-feed1npm install hexo-generator-feed --save 配置到站点配置文件 _config.yml12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 最后，在你 next 主题下的 _config.yml 下，添加 RSS 订阅链接即可1rss: /atom.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客添加feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora快捷键]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FTypora%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Typora常用快捷键 功能 快捷键 新建界面窗口 Ctrl + Shift + N 新建文件 Ctrl + N 打开文件 Ctrl + O 序列表 输入-之后输入空格 序列表 输入数字+“.”之后输入空格 务列表 -[空格]空格 文字 标题 Ctrl + 数字 表格 Ctrl + t 成目录 [TOC]按回车 选中一整行 Ctrl + l 选中单词 Ctrl + d 选中相同格式的文字 Ctrl + e 跳转到文章开头 Ctrl + home 跳转到文章结尾 Ctrl + end 搜索 Ctrl + f 替换 Ctrl + h 引用 输入&gt; 后输入空格 代码块 Ctrl + Alt + f 加粗 Ctrl + b 斜体 Ctrl + i 字体 Ctrl + 数字 下划线 Ctrl + u 删除线 Alt + Shift + 5 插入图片 直接拖动到指定位置即可或Ctrl + Shift + i 插入链接 Ctrl + k]]></content>
      <categories>
        <category>Typora笔记</category>
      </categories>
      <tags>
        <tag>Typora快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安全加固心得]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNginx%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Nginx安全加固心得 Nginx 发展多年，自身的安全漏洞比较少，发现软件漏洞，一般利用软件包管理器升级一下就好了。本文侧重讲述的不是 Nginx 自身的安全，而是利用 Nginx 来加固 Web应用，干一些应用防火墙（WAF）干的活。在做安全加固的时候，我们一定要头脑清晰，手里拿着刀，一刀一刀的切，将我们不想要的流量干掉，除去隐患。 屏蔽 IP 假设我们的网站只是一个国内小站，有着公司业务，不是靠广告生存的那种，那么可以用 Geoip 模块封杀掉除中国和美国外的所有IP。这样可以过滤大部分来自国外的恶意扫描或者无用访问。不用担心封杀了网络蜘蛛。主流的网络蜘蛛（百度/谷歌/必应/搜狗）已经包含在了我们的IP范围内了。如果是公网的登录后台，更应该屏蔽彻底一点。 123if ( $geoip_country_code !~ ^(CN|US)$ ) &#123; return 403;&#125; （很多人担心geoip库不够准确，诚然，中国城市级别的IP段会有误差，但是国家级别的IP段一般是没有问题的，并且geoip库可以随时在线更新） 封杀各种 user-agent user-agent 也即浏览器标识，每个正常的web请求都包含用户的浏览器信息，除非经过伪装，恶意扫描工具一般都会在user-agent里留下某些特征字眼，比如 scan，nmap 等。我们可以用正则匹配这些字眼，从而达到过滤的目的，请根据需要调整。 123456if ($http_user_agent ~* "java|python|perl|ruby|curl|bash|echo|uname|base64|decode|md5sum|select|concat|httprequest|httpclient|nmap|scan" ) &#123; return 403;&#125;if ($http_user_agent ~* "" ) &#123; return 403;&#125; 这里分析得不够细致，具体的非法 user-agent 还得慢慢从日志中逐个提取。通过上面两个大招，相信你的日志里很快就会有大量的 403 记录。，我们接着干。如果网站提供公共 api，注意与开发者约定好 UA，防止撞墙 封杀特定的 URL 特定的文件扩展名，比如 .bak 123location ~* \.(bak|save|sh|sql|mdb|svn|git|old)$ &#123; rewrite ^/(.*)$ $host permanent;&#125; 知名程序，比如 phpmyadmin 123location /(admin|phpadmin|status) &#123; deny all; &#125; 封杀特定的 http 方法和行为，比如 123456if ($request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 405;&#125;if ($http_range ~ "\d&#123;9,&#125;") &#123; return 444;&#125; 强制网站使用域名访问，可以逃过IP扫描，比如123if ( $host !~* 'abc.com' ) &#123; return 403;&#125; url 参数过滤敏感字，比如1234567if ($query_string ~* "union.*select.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; if ($query_string ~* "concat.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; 强制要求referer123if ($http_referer = "" ) ｛ return 403;｝ 如果不想用403，也可以rewrite一个url，比如一个400页面 123456&lt;html&gt; &lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor="white"&gt; &lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx/1.2.0&lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 小结 可以将上述规则结合起来使用，同时匹配多条规则时才会封杀，下面是一个来自老外的稍微复杂一点的例子： 123456789101112131415set $add 1; location /index.php &#123; limit_except GET POST &#123; deny all; &#125; set $ban ""; if ($http_referer = "" ) &#123;set $ban $ban$add;&#125; if ($request_method = POST ) &#123;set $ban $ban$add;&#125; if ($query_string = "action=login" )&#123;set $ban $ban$add;&#125; if ($ban = 111 ) &#123; access_log /var/log/[133]nginx/ban IP; return 404; &#125; proxy_pass http://127.0.0.1:8000; #here is a patch &#125; 其它方法 封杀IP 定时做日志分析，手动将恶意IP加入 iptables 拒绝名单，推荐使用 ipset 模块。 12yum install -y ipset ipset-serviceipset create badip hash:net maxelem 65535iptables -I INPUT -m set --match-set badip src -p tcp --dport 80 -j DROP/etc/init.d/iptables saveipset add badip 1.1.1.2ipset add badip 2.2.2.0/24/etc/init.d/ipset save ipset 还支持 timeout，类似 redis 的 TTL，timeout 之后会自动删除，比较人性化。比如下面的例子就是 timeout 默认 3600 秒，支持自定义 timeout 12ipset destroy badipipset create badip hash:net maxelem 65535 timeout 3600ipset add badip 1.1.1.1ipset add badip 2.2.2.0/24 timeout 60ipset add badip 3.3.3.0/24 timeout 7200 在日志分析的自动化程度比较高，准确率比较好的情况下，可以考虑通过条件触发 ipset。 限速 适当限制客户端的请求带宽，请求频率，请求连接数，这里不展开论述。根据具体需求，阀值应当稍稍宽泛一点。特别要注意办公室/网吧场景的用户，他们的特点是多人使用同一个网络出口。 目录只读 如果没有上传需求，完全可以把网站根目录弄成只读的，加固安全。做了一点小动作，给网站根目录搞了一个只读的挂载点。这里假设网站根目录为 /var/www/html 1234mkdir -pv /datamkdir -pv /var/www/htmlmount --bind /data /var/www/htmlmount -o remount,ro --bind /data /var/www/html 网站内容实际位于/data，网站内容更新就往/data里更新，目录/var/www/html无法执行任何写操作，否则会报错“Read-only file system”，极大程度上可以防止提权篡改。 overlayfs 这种方法跟上面的方法类似，但是有所区别假设网站根目录/var/www/html有一个目录upload是要求可读写的，其他只读即可，那么仔细看下面的操作 123456mkdir -pv /data/lowermkdir -pv /data/uppermkdir -pv /data/workermv /var/www/html/upload /data/upper/mv /var/www/html/* /data/lower/mount -t overlayfs overlay -o lower=/data/lower,upper=/data/upper,workdir=/data/worker /var/www/html 这样就完美实现了读写分离，底层目录只读，上层目录可写。如果程序被篡改，上层目录 /data/upper 除了 upload 内容之外，还会生成其他文件。overlayfs 因为特殊的机制，建议使用 Linux 内核4.0+，否则比较消耗硬盘的 inode。 定时总结和丰富过滤规则]]></content>
      <categories>
        <category>Nginx笔记</category>
      </categories>
      <tags>
        <tag>Nginx安全加固心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置阅读全文]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FNext%E8%AE%BE%E7%BD%AE%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[如何设置「阅读全文」？ 在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。NexT 提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在 主题配置文件 中添加： 123auto_excerpt: enable: true # 改成 true length: 150 # 默认展示的高度 默认截取的长度为 150 字符，可以根据需要自行设定建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外，这种方式也可以让 Hexo 中的插件更好的识别。 需要注意的是，点击「阅读全文」之后，文章会自动定位到 所在位置，想要修改成从头阅读需要修改 主题配置文件 _config.yml 文件： 12# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: false]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置阅读全文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next开启站内搜索]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FNext%E5%BC%80%E5%90%AF%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[Next 如何开启站内搜索？ NexT 主题支持集成 Swiftype、微搜索、Local Search 和 Algolia,Swiftype 和 Algolia 都只有一段时间的试用期，可以采用 Hexo 提供的Local Search，原理是通过 hexo-generator-search 插件在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 Local Search 由 flashlab 贡献 安装步骤安装 hexo-generator-search 在站点的根目录下执行以下命令 1npm install hexo-generator-search --save 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令1npm install hexo-generator-searchdb --save 启用搜索 编辑 站点配置 文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置 文件，启用本地搜索功能 123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next开启站内搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kickstart自动应答文件]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FKickstart%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Kickstart 自动应答文件 Cobbler vim /var/lib/cobbler/kickstarts/centos7.5-ks.cfg1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Cobbler for Kickstart Configurator for CentOS 7 by clsninstallurl --url=$treetextlang en_US.UTF-8keyboard uszerombrbootloader --location=mbr --driveorder=sda --append="crashkernel=auto rhgb quiet"#Network information$SNIPPET('network_config')#network --bootproto=dhcp --device=eth0 --onboot=yes --noipv6 --hostname=CentOS7timezone --utc Asia/Shanghaiauthconfig --enableshadow --passalgo=sha512rootpw --iscrypted $default_password_cryptedclearpart --all --initlabel# Disk partitioning informationpart pv.374 --fstype="lvmpv" --ondisk=sda --size=2052part pv.671 --fstype="lvmpv" --ondisk=sda --size=20484part pv.639 --fstype="lvmpv" --ondisk=sda --size=1 --growpart /boot --fstype="xfs" --ondisk=sda --size=500volgroup vgswap --pesize=4096 pv.374volgroup vgroot --pesize=4096 pv.671volgroup vgdata --pesize=4096 pv.639logvol / --fstype="xfs" --size=20480 --name=lvroot --vgname=vgrootlogvol swap --fstype="swap" --size=2048 --name=lvswap --vgname=vgswaplogvol /data --fstype="xfs" --size=1 --grow --name=lvdata --vgname=vgdatafirstboot --disableselinux --disabledfirewall --disabledlogging --level=inforeboot%pre$SNIPPET('log_ks_pre')$SNIPPET('kickstart_start')$SNIPPET('pre_install_network_config')# Enable installation monitoring$SNIPPET('pre_anamon')%end%packages@^minimal@compat-libraries@core@debugging@developmentbash-completionchronydos2unixkexec-toolslrzsznmapsysstattelnettreevimwgetnet-tools%end%postsystemctl disable postfix.service%end]]></content>
      <categories>
        <category>Cobbler笔记</category>
      </categories>
      <tags>
        <tag>Kickstart自动应答文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Hexo 简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 安装 进入 D:\Blog\gmlyo\ 自定义目录，右键鼠标，点击 Git Bash Here，输入 npm 命令即可安装 12345678910111213141516右击 Git Bash Herecd /d/Blog/gmlyo/npm install hexo -g 或 npm install hexo-cli -ghexo init 或 hexo init blog; cd blog/# 第一句是安装 hexo# 第二句是安装 hexo 部署到 git page 的 deployer# 两个都需要安装# Hexo 初始化配置（有点漫长的等待。。。）npm initHexo 初始化完成后，Hexo 将会在指定文件夹中新建所需要的文件hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # 或 hexo generatehexo s # 或 hexo server 可以在打开浏览器访问 http://localhost:4000/ 查看 查看 hexo 版本信息12345678910111213141516171819# 查看 hexo 版本信息hexo -vhexo: 3.7.1hexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64http_parser: 2.8.0node: 10.3.0v8: 6.6.346.32-node.9uv: 1.20.3zlib: 1.2.11ares: 1.14.0modules: 64nghttp2: 1.29.0napi: 3openssl: 1.1.0hicu: 61.1unicode: 10.0cldr: 33.0tz: 2018c 常用 Hexo 命令123456# 生成静态文件，会在当前目录下生成一个新的叫做 public 的文件夹hexo generate (hexo g)# 启动本地 Web 服务，用于博客的预览hexo server (hexo s)# 部署播客到远端（比如github, heroku等平台）hexo deploy (hexo d) 其他常用命令12hexo new "postName" # 新建文章hexo new page "pageName" # 新建页面 常用简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 常用组合12hexo d -g # 生成部署hexo s -g # 生成预览]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 绑定自定义域名]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[如何将自己购买的域名连接到 Github Pages？ 12345678在 source 目录下新建 CNAME 文件，在首行添加网站域名如：www.gmlyo.com注意前面没有 https://，http:// 等信息，然后重新重新生成并部署站点hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # hexo generadehexo d # hexo deploy或hexo d -g 设置域名解析1234561、先添加一个CNAME，主机记录写@，后面记录值写上你的 xxx.github.io2、再添加一个CNAME，主机记录写www，后面记录值也是 xxx.github.io这样别人用 www 和不用 www 都能访问你的网站其实 www 的方式，会先解析成 https://xxx.github.io，然后根据 CNAME 再变成 http://www.gmlyo.com，即中间是经过一次转换的。注：除了使用 CNAME 记录也有人使用 A 记录，后面的记录值是写 Github Page 里面的 IP 地址，但有时候 IP 地址会更改，导致最后解析不正确，所以还是推荐用 CNAME 别名记录要好些，不建议用 IP。3、等待10分钟左右，域名生效后刷新浏览器，使用自定义域名访问网站即可 Hexo 部署后，CNAME 会被自动删除，如何解决？123将需要上传至 Github 的文件放在 source 目录下如：CNAME, README.md, favicon.ico, images 目录等将这些都放在 source 目录下，每次上传就不会消失了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 绑定自定义域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 删除文章]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hexo 如何删除文章？ 1234567891011删除文章的过程很简单，先删除本地文件，然后通过生成和部署命令将远程仓库中的文件也一并删除。以最开始默认形成的 hello-world.md 这篇文章为例首先进入 D:\Blog\gmlyo\source\_posts\ 文件夹中找到 hello-world.md 文件，在本地直接执行删除。然后依次执行hexo cleanhexo ghexo d再去主页查看就会发现博客上面已经什么都没有了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 删除文章</tag>
      </tags>
  </entry>
</search>
