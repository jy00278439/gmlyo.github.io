<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Chrome自带的长截屏功能]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FChrome%E8%87%AA%E5%B8%A6%E7%9A%84%E9%95%BF%E6%88%AA%E5%B1%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Chrome自带的长截屏功能 在 Google Chrome 里面，打开开发人员工具 按F12或网站上任意空白处右键 – 选择 “检查” 或者“审查元素” 快捷键 Ctrl + Shift + P，会看到右边的审查元素出现了一个输入框输入 screenshot 然后回车保存图片]]></content>
      <categories>
        <category>Chrome笔记</category>
      </categories>
      <tags>
        <tag>Chrome自带的长截屏功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chevereto图床]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FChevereto%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[Chevereto图床 Chevereto 是一款采用 PHP 语言开发的网络相册脚本程序，支持多语言，提供中文语言包的下载的开源在线图片存储分享服务系统，支持本地上传和在线获取两种图像上传方式，并集成了 TinyURL 网址缩短服务。Chevereto 这套程序可以像 Discuz 或 WordPress 一样随意架设在任何空间上。而它的功能除了一般图片空间单纯的从电脑上传图片外，也支援利用网址也可以上传，最屌的是还有 TinyURL 的缩短网址的功能可以使用，因此这套 Chevereto 可以说是比市面上的图片空间好太多了。他是把图片上传到空间的，相信一般大家都一定会使用免费空间，在此建议大家在挑主机时尽可能使用 cPanel 的空间，因为可以使用 cPanel 特有的 「Cron Jobs」 来备份你上传的图片。 Chevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirements Clevereto 错误 404 解决方法 如果 Web服务 是 Nginx，基本第一步安装好后再次打开网站会出现 404 错误。因为 Chevereto 默认提供基于 Apache 环境的伪静态规则 需要设置以下 Rewrite 伪静态规则123456789101112131415location / &#123; if (-f $request_filename/index.html)&#123; rewrite (.*) $1/index.html break; &#125; if (-f $request_filename/index.php)&#123; rewrite (.*) $1/index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125; try_files $uri $uri/ /api.php;&#125;location /admin &#123; try_files $uri /admin/index.php?$args;&#125; 官方推荐配置123456789101112131415161718192021222324252627282930# Disable access to .ht* fileslocation ~ /\.ht &#123; deny all;&#125;# Disable access to sensitive files in app pathlocation ~ /(app|content|lib)/.*\.(po|php|lock|sql)$ &#123; deny all;&#125;# Disable log on not found images + image replacement# Image not found replacementlocation ~* (jpe?g|png|gif) &#123; log_not_found off; error_page 404 /content/images/system/default/404.gif;&#125;# Enable CORS header (avoids font rendering issues)location ~ \.(ttf|ttc|otf|eot|woff|woff2|font.css|css|js)$ &#123; add_header Access-Control-Allow-Origin "*";&#125;# Force serve upload path as static contentlocation ~ /images &#123;&#125;# Pretty URLs# Route dynamic request to index.phplocation / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 参考文档 https://www.zhujibiji.com/2017/11/install-chevere-to-build-your-image-sharing-website/https://lala.im/2478.html]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>Chevereto图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图床的选择]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2F%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%BA%8A%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[关于图床的选择为什么要使用图床？ Hexo 文章中的图片，我们可以放到本地，然后一起部署到 Github 中，这样完全没有问题。然而 github pages 空间毕竟有限（貌似只有 300M）,另外图片的管理太混乱了，一些原创的图片可能被盗链。 很多技术人写作都用的是 MarkDown 轻量级标记语言进行博客写作，这种写作让我们不用像使用 Word 那样那么麻烦地调整排版和格式，只需专心写作并且照样完成排版的一种方式。但是，基本所有支持 MarkDown 本地写作工具都只能采用导入本地图片引用的方式，对于一篇需要大量图片阐述的文章以及该文章上传至网络图片丢失，这不得不是个很糟糕的问题。那么有什么比较好的解决方式吗？很多人采用的图片寄存于网络，用服务厂商作为图片存储的地方，大家都叫为 「图床」 。 那么像 CSDN 博客、简书平台不是都可以吗？是的，它们平台写文章的时候都可以导入图片然后得到一个图片网络地址。但是，图片数量多，一张一张上传，这不是贼烦嘛！那么有专门可以作 「图床」 功能的服务商吗？有的，比如七牛云。 网上谷歌搜下还是能搜到很多图床网站的，先随便列举一些 公共图床SM.MS https://sm.ms/SM.MS 是由 V2EX @Showfom 自建的，无外链限制，无流量限制的图床，支持 HTTPS，速度不错，已经运行两年多了。 极简图床 https://jiantuku.com/#/ 路过图床 https://imgchr.com/ Imgur https://imgur.com/Imgur 是一家国外老牌的图片存储服务商，国外速度很快，口碑不错，支持 HTTPS。但是国内速度很不稳定，所以追求国内速度的同学慎用。 Qchan图床http://tuchuang.org/ 微博图床 微博图床，可以自定义支持七牛，界面简洁美观，支持 Chrome 插件，注册后还可以同步上传历史。 自建图床 目前自建图床方案有两种 是利用云服务商提供的存储服务来作为图床，通过 API 来管理图片 是在 VPS 上安装开源的图片或文件管理程序，只要能提供外链，基本都可以作为图床来用。 建图床（云服务） 七牛云，又拍云，阿里云OSS 自建图床（开源方案） 如果你有 VPS，并且网络速度 OK 的话，自建图床也是一个不错的选择。 Lychee https://github.com/electerious/LycheeLychee 是一个开源免费的基于 PHP 的图片管理系统，支持 Docker 部署，可以直接当做图床来用，Lychee 还支持很多扩展。 树洞外链 https://yun.aoaoao.me/https://github.com/HFO4/shudong-share树洞外链 是一款免费开源的 PHP 外链网盘系统，界面简洁友好，支持七牛、本地、远程、阿里云OSS、又拍云五种储存方式，支持多用户系统，多上传方案策略。 Chevereto https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirementsChevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。 使用图床的目的是希望文章的图片资源能有更好的加载速度和稳定的显示效果。]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>关于图床的选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之堆溢出处理]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java 虚拟机之堆溢出处理在 Java 程序的运行过程中，如果堆空间不足，则有可能抛出内存溢出错误 (Out Of Memory)，简称为 OOM。 如下文字显示了典型的堆内存溢出 1Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:20) 一旦发生这类问题，系统就会被迫退出。如果发生在生产环境，可能会引起严重的业务中断。为了能够不断改善系统，避免或减少这类错误的发生，需要在发生错误时，获得尽可能多的现场信息，以帮助研发人员排查现场问题。 Java 虚拟机提供了参数 -XX:+HeapDumpOnOutOfMemoryError，使用该参数，可以在内存溢出时导出整个堆信息。和它配合使用的还有 -XX:HeapDumpPath，可以指定导出堆的存放路径。 使用如下参数执行上述代码 1-Xms5m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/app/tomcat/logs/P02.dump 显然 20M 堆空间不足以容纳 25M 内存，系统比如发生内存溢出，在发生错误后，控制台输出如下 1java.lang.OutOfMemoryError: Java heap space Dumping heap to /data/app/tomcat/logs/P02.dump... Heap dump file created [23067302 bytes in 0.160 secs] Exception in thread “main” java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:19) 可以看到，虚拟机将当前的堆导出，并保存到 /data/app/tomcat/logs/P02.dump 文件下启动最小空间 5M，配了 20M 最大空间 ，发生了 内存溢出错误，dump 路径为 /data/app/tomcat/logs/P02.dump 使用 MAT 等工具打开该文件进行分析，可以很容易地找到这些 byte 数组和保存它们的 Vector 对象实例]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java虚拟机之堆溢出处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编译安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FPython%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一般情况下，Linux 都会预装 Python，但是这个预装的 Python 版本一般都比较低，很多 Python 的新特性都没有，必须重新安装新一点的版本Python下载地址https://www.python.org/https://www.python.org/ftp/python/https://www.python.org/ftp/python/2.7.15/https://www.python.org/ftp/python/3.6.5/ 查看 Python 版本1234567python -V# CentOS 6.xPython 2.6.6# CentOS 7.xpython 2.7.5 做好链接，保留旧版本 pythoncd /usr/bin/cp /usr/bin/python /usr/bin/python_bak 如果发现 yum 不能用了，解决 yum 无法使用的问题因为 yum 依赖系统默认安装的 python 版本, 处理如下：vim /usr/bin/yum#!/usr/bin/python修改为-&gt; #!/usr/bin/python2.6 或 #!/usr/bin/env python2.6import systry: import yumexcept ImportError:……省略…… 这里不更改 原 Python 版本 安装依赖1yum -y install readline readline-devel sqlite sqlite-devel zlib zlib-devel openssl openssl-devel bzip2 bzip2-devel bzip2-libs 缺少 readline 支持的 IPythonWARNING: IPython History requires SQLite, your history will not be savedWARNING: Readline services not available or not loaded.WARNING: The auto-indent feature requires the readline library 下载 Python12wget -c https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xzwget -c https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tar.xz 安装 Python安装 Python 2.7.15123456tar -xvf Python-2.7.15.tgzcd Python-2.7.15/./configure \--prefix=/data/python2.7.15 --enable-optimizationsmake -j 4make install 安装 Python 3.6.5123456tar -xvf Python-3.6.5.tgzcd Python-3.6.5/./configure \--prefix=/data/python3.6.5 --enable-optimizationsmake -j 4make install 添加 Python 环境变量1234vim /etc/profileexport PATH=$PATH:/data/python2.7.15/binexport PATH=$PATH:/data/python3.6.5/binsource /etc/profile 或 12echo -e '\nexport PATH=$PATH:/data/python2.7.15/bin' &gt;&gt; /etc/profileecho -e 'export PATH=$PATH:/data/python3.6.5/bin' &gt;&gt; /etc/profile PS：如果安装 easy_intall 时报 zlib 没有安装，Linux下直接 yum -y install zlib zlib-devel，然后重新编译 Python2.7.15 继续就可以了cp /usr/bin/python /usr/bin/python_bakln -svnf /data/python2.7.15/bin/python2.7 /usr/bin/python setuptools 安装 下载地址https://pypi.python.org/pypi/setuptoolshttps://pypi.python.org/simple/setuptools/ 1234tar -zxvf setuptools-39.2.0.tar.gzcd setuptools-39.2.0python3 setup.py buildpython3 setup.py install IPython 是一个 python 的交互式 Shell，比默认的 Python Shell 好用一点，支持变量自动补全，自动缩进，支持 Bash Shell 命令，内置了许多很有用的功能和函数安装 IPythonIPython 下载地址https://pypi.org/project/ipython/ 1234tar -zxvf ipython-6.4.0.tar.gzcd ipython-6.4.0/python3 setup.py buildpython3 setup.py install 安装 pip pip 下载地址https://pypi.org/project/pip/ 1234tar -xvf pip-10.0.1.tar.gzcd pip-10.0.1/python3 setup.py buildpython3 setup.py install pip 安装 python 第三方库1234pip3 install requestspip3 install pyapi-gitlabpip3 install readlinepip3 install rlcompleter2]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志切割]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志切割 12345678910111213141516vim logcut.sh#!/bin/bashday=$(date +"%Y-%m-%d")yesterday=$(date -d "yesterday" +%Y-%m-%d)logsdir=(/data/app/*/logs)for logdir in $&#123;logsdir[@]&#125;do for logfile in $(ls $&#123;logdir[@]&#125; | egrep "stdout.log|catalina.out") do cp $logdir/$logfile $logdir/$&#123;logfile%.log&#125;.$&#123;day&#125;.log cp $logs/$file $logs/$&#123;file%.out&#125;.$&#123;day&#125;.out cat /dev/null &gt; $logdir/$logfile donedone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志切割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志压缩]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志压缩打包 压缩 7 天前日志每个月 1 号，创建上个月的目录，年-月 2018-04将 gz 压缩文件拷贝到 年-月 2018-04 目录中 1234567891011121314151617181920vim compresslog.sh#!/bin/bashday=$(date +"%d")month=$(date +"%Y-%d")lastmonth=$(date +"%Y-%m" -d "last month")lastweek=$(date +"%Y-%m-%d" -d "last week")logsdir=(/data/app/*/logs)for logs in $&#123;logsdir[@]&#125;do find $logs/ -mtime +7 -regextype posix-extended -regex ".*\.(log|out|txt)" -exec gzip &#123;&#125; \;done[ $day == 01 ] &amp;&amp; cd $&#123;logsdir[@]&#125; &amp;&amp; mkdir -pv $lastmonthfor logdir in $&#123;logsdir[@]&#125;do [ -d $logdir/$lastmonth ] || mkdir -pv $logdir/$lastmonth mv $logdir/*gz $logdir/$lastmonthdone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM 磁盘扩展]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FLVM%E7%A3%81%E7%9B%98%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[LVM 磁盘扩展 查看磁盘空间1df -h 查看 LV 信息1lvs 查看 VG 信息1vgs 创建 PV1pvcreate /dev/vdb 扩展已有的 VG 容量1vgextend vgdata /dev/vdb Couldn&#39;t&#39; create temporary archive name.因为磁盘实在太小了或已经没有空间了，无法执行，删除一些数据就好了 12vgextend vgdata /dev/sdaVolume group "vgdata" successfully extended 查看 VG 信息1vgs 扩展已有 LV 容量12lvextend -L +99.99G -n /dev/vgdata/lvdatalvextend -L +1020M -n /dev/vgdata/lvdata -L # 指定逻辑卷的大小，单位为 kKmMgGtT 字节，也就是 Size-l # 指定逻辑卷的大小，单位为 PE 数 重新加载逻辑卷12345# 加载 ext 文件系统resize2fs /dev/vgdata/lvdata# 加载 xfs 文件系统xfs_growfs /dev/vgdata/lvdata]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>LVM 磁盘扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建LVM]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FLVM%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[创建 LVM LVM 创建过程创建PV -&gt; 创建VG -&gt; 创建LV -&gt; 格式化LV -&gt; mount挂载 常用命令pvcreate 设备名vgcreate 卷组名 物理卷lvcreate -L 大小 -n 逻辑卷名 卷组名 LVM 常用命令表 功能 管理物理卷 管理卷组 管理逻辑卷 Scan 扫描 pvscan vgscan lvscan Create 创建 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Extend 扩展 vgextend lvextend Reduce 减少 vgreduce lvreduce 安装 LVM1yum -y install lvm2 创建 PV12pvcreate /dev/vdbPhysical volume "/dev/vdb" successfully created 创建 VG12vgcreate vgdata /dev/vdbVolume group "vgdata" successfully created 创建 LV12345lvcreate -L 49.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created.lvcreate -L 99.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created. 文件系统格式化12345# 格式化 ext 文件系统mkfs.ext4 /dev/vgdata/lvdata# 格式化 xfs 文件系统mkfs.xfs /dev/vgdata/lvdata 挂载逻辑卷到目录12mkdir -pv /datamount /dev/vgdata/lvdata /data 编辑 /etc/fstab1234vim /etc/fstab...省略.../dev/mapper/vgdata-lvdata /data xfs defaults 0 0...省略... ###]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>创建LVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加文章结束标记]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FNext%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[添加文章结束标记 编辑 /hexo/themes/next/layout/_macro/post.swig 文件在 if theme.wechat_subscriber.enabled and not is_index 上面添加如下代码 代码片段123456&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt;&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125; &lt;div&gt; &#123;% include 'wechat-subscriber.swig' %&#125; &lt;/div&gt;&#123;% endif %&#125; 显示效果1————— The End —————]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加文章结束标记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加音乐]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[Next 添加音乐 去网易云音乐搜索喜欢的音乐，点击生成外链播放器，复制代码直接放到博文末尾即可height 设为 0 可隐藏播放器，但仍然可以播放音乐auto 设成 0 可手动播放，默认是 1 自动播放 编辑 /hexo/themes/next/layout/_custom/sidebar.swig 文件里，播放器会显示在站点预览中或编辑 /hexo/themes/next/layout/_macro/sidebar.swig 文件里 123# 将代码粘贴到一个合适的位置&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2188265841&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加分类及标签]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FHexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Hexo添加分类及标签创建 分类 选项 生成 分类 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page categories 成功后会提示 1INFO Created: ~/hexo/source/categories/index.md 根据上面的路径，找到 index.md 这个文件，打开后默认内容是这样的 1234---title: 文章分类date: 2018-06-06 22:49:07--- 添加 type: &quot;categories&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "categories"--- 给文章添加 “categories” 属性 打开需要添加分类的文章，为其添加 categories 属性下方的 categories: Hexo笔记 表示添加这篇文章到 Hexo笔记 这个分类注意：hexo 一篇文章只能属于一个分类，也就是说如果在 - Hexo笔记 下方添加 - xxxhexo 不会产生两个分类，而是把分类嵌套（即该文章属于 - Hexo笔记 下的 - xxx 分类） 123456---title: Hexo添加分类及标签date: 2018-06-06 22:44:41categories: - Hexo笔记--- 至此，成功给文章添加分类，点击首页的 分类 可以看到该分类下的所有文章当然，只有添加了 categories: xxx 的文章才会被收录到首页的 分类 中 创建标签选项 生成 标签 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page tags 成功后会提示 1INFO Created: ~/hexo/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的 1234---title: 标签date: 2018-06-06 22:49:07--- 添加 type: &quot;tags&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "tags"--- 给文章添加tags属性打开需要添加标签的文章，为其添加 tags 属性下方的tags:Hexo添加分类及标签- 表格- 表单验证就是这篇文章的标签了 12345678910---title: Hexo添加分类及标签date: 2018-06-06 22:49:07categories: - Hexo笔记tags:- Hexo添加分类及标签- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的标签可以看到该标签下的所有文章当然，只有添加了 tags: xxx 的文章才会被收录到首页的标签中细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的所以我们可以打开 \hexo\scaffolds/post.md 文件，在 tages:上面加入categories:1234567vim /hexo/scaffolds/post.md---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 保存后执行hexo new &quot;文章名&quot;命令生成的文件，页面里就有categories:项了\hexo\scaffolds\ 目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加分类及标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置网站的图标Favicon]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FHexo%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%AB%99%E7%9A%84%E5%9B%BE%E6%A0%87Favicon%2F</url>
    <content type="text"><![CDATA[Hexo 设置网站的图标 Favicon ico图标使用 32x32去别的网站下载或 PS 制作，并将图标名称改为 favicon.ico然后把图标放在 \next\themes\next\source\images\ 目录下也可以放在 hexo\source\images 目录下，这个目录没有可以自己手动创建 修改 next主题配置文件，\next\themes\next\_config.yml 文件12345678favicon: small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo设置网站的图标Favicon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加访问量]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Next添加访问量 使用 Next 主题自带的不蒜子统计，仅限于在文章页面显示阅读量，不在首页显示 修改 themes\next\ _config.yml 文件123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数(UV) site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量(PV) site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 总访问量 (PV) 总访问量独立访客 (UV) 访问人数网站的浏览次数为 PV网站的访客数为 UVPV 计算方式，单个用户连续点击 N 篇文章，记录 N 次访问量UV 计算方式，单个用户连续点击 N 篇文章，只记录 1 次访客数可以根据需要添加相应的统计功能 查看底部显示效果]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加访问量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next修改小型代码块颜色]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E4%BF%AE%E6%94%B9%E5%B0%8F%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%9D%97%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Next 修改小型代码块颜色 修改 \themes\next\source\css\ _variables\base.styl 文件可以加入自定义颜色，如下中已经给出了许多种颜色 12345678910111213// Colors// colors for use across theme.// --------------------------------------------------$whitesmoke = #f5f5f5$gainsboro = #eee$gray-lighter = #ddd...$blue = #0684bd$blue-deep = #262a30$orange = #fc6423 修改 $code-background 与 $code-foreground 的值 以下的各个参数自己根据需求进行设置即可 1234567// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 13px$code-foreground = $black-light //设置成自己喜欢的颜色即可$code-background = $gainsboro //设置成自己喜欢的颜色即可$code-border-radius = 4px 在 \themes\next\source\css\ _variables\base.styl 文件内还有很多的参数，可以酌情进行修改]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next修改小型代码块颜色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next头像圆形旋转]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E5%A4%B4%E5%83%8F%E5%9C%86%E5%BD%A2%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[头像变成圆形，鼠标停留在上面发生旋转效果 介绍一下实现头像圆形，鼠标经过旋转或者一直让旋转效果修改 Hexo 目录下 \themes\next\source\css\_common\components\sidebar\sidebar-author.styl 文件 头像圆形修改 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转修改 修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 方法二：修改 themes/next/source/css/_common/components/sidebar/sidebar-author.styl 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 头像循环旋转效果修改 修改 sidebar-author.styl 文件，添加如下代码 12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next头像圆形旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置首页隐藏指定文章]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Next设置首页隐藏指定文章 修改 next 主题文件夹下的 layout 中的 index.swig 文件定位修改 post_template.render(post, true) 1234567891011\themes\next\layout\index.swig...省略...&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.visible !== 'hide' %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt;...省略... 其中修改的是为文章的首页显示添加判断条件 在新的 post 中添加 visible 字段来控制是否首页显示 例如：当前这篇文章 12345title: Next设置首页隐藏指定文章date: 2018-06-06 01:08:59categories: Next笔记tags: Next设置首页隐藏指定文章visible: hide 这里如果加上 hide 则该文章就不会在文章首页显示，如果留空则表示默认显示]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置首页隐藏指定文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks 安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FShadowsocks%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Shadowsocks 安装 123456yum -y install python-pippip install --upgrade pippip install shadowsockswhich ssserverpip install M2Cryptopip install gevent 123456789101112131415161718vim /etc/systemd/system/shadowsocks.service[Unit]Description=Shadowsocks[Service]Type=simpleTimeoutStartSec=0PIDFile=/data/shadowsocks/var/run/ssserver.pidExecStart=/usr/bin/ssserver -c /data/shadowsocks/conf/shadowsocks.json -d start \ --pid-file /data/shadowsocks/var/run/ssserver.pid \ --log-file /data/shadowsocks/logs/ssserver.logRestart=on-abortRestartSec=10sPrivateTmp=true[Install]WantedBy=multi-user.targettail -f /data/shadowsocks/logs/ssserver.log 123456789101112131415mkdir -pv /data/shadowsocks/&#123;conf,logs,var/run&#125;cd /data/shadowsocks/vim shadowsocks.json&#123; "server":"149.28.231.171", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "8888":"gmlyo", "8889":"glmyo" &#125;, "timeout":300, "method":"aes-256-cfb", "fast_open":false&#125; 1234567systemctl daemon-reloadsystemctl start shadowsockssystemctl -l status shadowsockssystemctl enable shadowsockssystemctl stop shadowsockssystemctl restart shadowsocksjournalctl -fu shadowsocks 12345678910systemctl status firewalldfirewall-cmd --list-allfirewall-cmd --list-servicesfirewall-cmd --get-servicesfirewall-cmd --zone=public --add-port=8888/tcp --permanentfirewall-cmd --zone=public --add-port=8889/tcp --permanentfirewall-cmd --reloadfirewall-cmd --zone=public --query-port=1985/tcpfirewall-cmd --zone=public --list-ports]]></content>
      <categories>
        <category>Shadowsocks笔记</category>
      </categories>
      <tags>
        <tag>Shadowsocks 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat APR 安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F05%2FTomcat%20APR%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Tomcat APR 安装 Tomcat 的 APR(Apache portable Run-time libraries)是 Apache HTTP 服务的支持库，提供了一组映射到下层操作系统的 API是用来改善 Tomcat 对静态文件的处理性能，同时如果使用了 HTTPS 方式传输的话，也可以提升 SSL 的处理性能。默认情况下，Tomcat 是用 BIO 的方式来实现网络通信的，性能非常低。而 APR 使用 JNI 的方式来读取文件以及进行网络传输，从操作系统级别来解决异步的 I/O 问题，大幅度的提高性能。如果操作系统不支持某个特定的功能，APR 将提供一个模拟的实现这样程序员使用 APR 编写真正可在不同平台上移植的程序 安装依赖1234Tomcat 和 JDKyum install -y apr-develyum install -y gcc gcc-develyum install -y openssl openssl-devel 下载 apr 下载地址：https://apr.apache.org/download.cgi 1234cd /data/tools/wget -c http://mirrors.shu.edu.cn/apache//apr/apr-1.6.3.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-util-1.6.1.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-iconv-1.2.2.tar.gz 安装 apr123456789101112131415161718192021# 解压并进入解压目录cd /data/tools/tar -zxvf apr-1.6.3.tar.gzcd apr-1.6.3/# 配置，安装在 /data/ 目录下./configure --prefix=/data/apr# 报错信息config.status: executing libtool commandsrm: cannot remove 'libtoolT': No such file or directoryconfig.status: executing default commands# 解决方法# 编辑 configure 文件把 $RM "$cfgfile" 这行代码注释掉或 把 $RM "$cfgfile" 这行删除掉或 写成 $RM -f "$cfgfile"重新再运行 ./configure 就可以了# 编译安装make -j 4make install 安装 apr-util123456789101112131415161718192021222324252627# 解压并进入解压目录cd /data/tools/tar -zxvf apr-util-1.6.1.tar.gzcd apr-util-1.6.1/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-util \--with-apr=/data/apr \--with-apr-iconv=/data/apr-iconv/bin/apriconv# 编译安装make -j 4# 报错信息xml/apr_xml.c:35:19: fatal error: expat.h: No such file or directory #include &lt;expat.h&gt; ^compilation terminated.make[1]: *** [xml/apr_xml.lo] Error 1make[1]: Leaving directory `/data/tools/apr-util-1.6.1'make: *** [all-recursive] Error 1# 解决办法# 缺少 expat 开发库，安装 expat 库yum install -y expat-devel# 重新执行make -j 4make install 安装 apr-iconv1234567891011# 解压并进入解压目录cd /data/tools/tar -zxvf apr-iconv-1.2.2.tar.gzcd apr-iconv-1.2.2/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-iconv \--with-apr=/data/apr# 编译安装make -j 4make install 配置 Tomcat 使用 apr 库 什么是 tomcat-native ？tomcat-native 库为 Tomcat 提供了本地实现tomcat-native 依赖于三个组件：APR，OPENSSL，JDK 大致就是通过 tomcat-native 库，使 tomcat 运行时通过 APR 更多的调用本地 API，达到提升性能的目的。由于依赖关系，安装时，先安装 APR，openssl，然后再安装 tomcat-native，最后配置 tomcat 启动时依赖的库路径。 有 两 种方式配置 Tomcat 使用 apr 库 方式一：配置环境变量在 Linux 系统中，只要 $LD_LIBRARY_PATH 变量值所在路径包含 Tomcat 本地库默认就使用 org.apache.coyote.http11.Http11AprProtocol 123vim /etc/profileexport LD_LIBRARY_PATH=/data/apr/libsource /etc/profile 方式二：将 apr 库路径参数添加到系统变量中（推荐）编辑 $CATALINA_HOME/bin/setenv.sh 文件（如果文件不存在，新建文件） 1export CATALINA_OPTS="$CATALINA_OPTS -Djava.library.path=/data/apr/lib" 修改 $TOMCAT_HOME/conf/server.xml 1234&lt;Connector port="8000" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443"protocal 修改为 org.apache.coyote.http11.Http11AprProtocol，重启 tomcat 配置安装 Tomcat native 具体的安装步骤其实在 tomcat 自带的 tomcat-native.tar.gz 文件中就有 123456789101112131415161718192021# 进入 Tomcat bin 目录cd /data/app/tomcat/bin/# 解压 tomcat-native.tar.gz 后进入解压目录tar -zxvf tomcat-native.tar.gz# cd tomcat-native-1.2.8-src/native/ # Tomcat7cd tomcat-native-1.1.33-src/jni/native/# 配置 指定 JDK 的目录并加入 SSL./configure \--prefix=/data/apr \--with-apr=/data/apr/bin/apr-1-config \--with-java-home=/data/jdk1.8.0_172 \--with-ssl=yes# 编译安装make -j 4make installwarning: remember to run 'libtool --finish /usr/local/apr/lib'libtool --finish /data/apr/lib-bash: libtool: command not foundyum -y install libtool libtool-devellibtool --finish /data/apr/lib 设置 Tomcat Native 环境变量123456# 编辑 profilevim /etc/profile# 在文件中加入如下配置export LD_LIBRARY_PATH=/data/apr/lib# 退出编辑后保存设置source /etc/profile 测试 启动 Tomcat，若在控制台或日志出现如下示例信息则表示 APR 配置成功 1INFO: Loaded APR based Apache Tomcat Native library 1.1.33. 检查是否安装成功如果看到下面的启动日志，表示成功 123456Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["http-apr-8080"]Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["ajp-apr-8009"]Sep 17, 2017 1:59:19 PM org.apache.catalina.startup.Catalina startINFO: Server startup in 31002 ms]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat APR 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不通过inventory文件，指定host运行Ansible]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F05%2F%E4%B8%8D%E9%80%9A%E8%BF%87inventory%E6%96%87%E4%BB%B6%EF%BC%8C%E6%8C%87%E5%AE%9Ahost%E8%BF%90%E8%A1%8CAnsible%2F</url>
    <content type="text"><![CDATA[如何不通过 inventory 文件，直接指定 host 运行 Ansible？ 使用过 ansible 的都知道，不管是运行 Ad-Hoc 还是 playbook，都需要指定一个 inventory 文件，或者使用默认的 inventory 文件。但是现在有一个主机，它尚未在 inventory 文件中配置，那么我们该如何用 ansible 对其进行操作呢？ 一般我们执行都是这样的 12345ansible 192.168.35.215 -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125; 这时需要在 inventory 文件 /etc/ansible/hosts 中配置 192.168.35.215 信息 12[NgxProxy]192.168.35.215 如果没有在 inventory 文件中配置该主机信息，又想用 ansible 对其进行操作就需要用到逗号 , 字符，使用方法如下 123456# Host and IP addressansible all -i example.com,ansible all -i 93.184.216.119,# Requires 'hosts: all' in your playbookansible-playbook -i example.com, playbook.yml 需要注意的是，需要指定范围为 all 12345ansible all -i 192.168.35.215, -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;]]></content>
      <categories>
        <category>Ansible笔记</category>
      </categories>
      <tags>
        <tag>如何不通过 inventory 文件，直接指定 host 运行 Ansible？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客生成一个站点地图]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[给博客生成一个站点地图 安装 hexo-generator-seo-friendly-sitemap1npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件 _config.yml 中添加12sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客生成一个站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客添加feed]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[给博客添加 feed 安装 hexo-generator-feed1npm install hexo-generator-feed --save 配置到站点配置文件 _config.yml12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 最后，在你 next 主题下的 _config.yml 下，添加 RSS 订阅链接即可1rss: /atom.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客添加feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora快捷键]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FTypora%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Typora常用快捷键 功能 快捷键 新建界面窗口 Ctrl + Shift + N 新建文件 Ctrl + N 打开文件 Ctrl + O 序列表 输入-之后输入空格 序列表 输入数字+“.”之后输入空格 务列表 -[空格]空格 文字 标题 Ctrl + 数字 表格 Ctrl + t 成目录 [TOC]按回车 选中一整行 Ctrl + l 选中单词 Ctrl + d 选中相同格式的文字 Ctrl + e 跳转到文章开头 Ctrl + home 跳转到文章结尾 Ctrl + end 搜索 Ctrl + f 替换 Ctrl + h 引用 输入&gt; 后输入空格 代码块 Ctrl + Alt + f 加粗 Ctrl + b 斜体 Ctrl + i 字体 Ctrl + 数字 下划线 Ctrl + u 删除线 Alt + Shift + 5 插入图片 直接拖动到指定位置即可或Ctrl + Shift + i 插入链接 Ctrl + k]]></content>
      <categories>
        <category>Typora笔记</category>
      </categories>
      <tags>
        <tag>Typora快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安全加固心得]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNginx%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Nginx安全加固心得 Nginx 发展多年，自身的安全漏洞比较少，发现软件漏洞，一般利用软件包管理器升级一下就好了。本文侧重讲述的不是 Nginx 自身的安全，而是利用 Nginx 来加固 Web应用，干一些应用防火墙（WAF）干的活。在做安全加固的时候，我们一定要头脑清晰，手里拿着刀，一刀一刀的切，将我们不想要的流量干掉，除去隐患。 屏蔽 IP 假设我们的网站只是一个国内小站，有着公司业务，不是靠广告生存的那种，那么可以用 Geoip 模块封杀掉除中国和美国外的所有IP。这样可以过滤大部分来自国外的恶意扫描或者无用访问。不用担心封杀了网络蜘蛛。主流的网络蜘蛛（百度/谷歌/必应/搜狗）已经包含在了我们的IP范围内了。如果是公网的登录后台，更应该屏蔽彻底一点。 123if ( $geoip_country_code !~ ^(CN|US)$ ) &#123; return 403;&#125; （很多人担心geoip库不够准确，诚然，中国城市级别的IP段会有误差，但是国家级别的IP段一般是没有问题的，并且geoip库可以随时在线更新） 封杀各种 user-agent user-agent 也即浏览器标识，每个正常的web请求都包含用户的浏览器信息，除非经过伪装，恶意扫描工具一般都会在user-agent里留下某些特征字眼，比如 scan，nmap 等。我们可以用正则匹配这些字眼，从而达到过滤的目的，请根据需要调整。 123456if ($http_user_agent ~* "java|python|perl|ruby|curl|bash|echo|uname|base64|decode|md5sum|select|concat|httprequest|httpclient|nmap|scan" ) &#123; return 403;&#125;if ($http_user_agent ~* "" ) &#123; return 403;&#125; 这里分析得不够细致，具体的非法 user-agent 还得慢慢从日志中逐个提取。通过上面两个大招，相信你的日志里很快就会有大量的 403 记录。，我们接着干。如果网站提供公共 api，注意与开发者约定好 UA，防止撞墙 封杀特定的 URL 特定的文件扩展名，比如 .bak 123location ~* \.(bak|save|sh|sql|mdb|svn|git|old)$ &#123; rewrite ^/(.*)$ $host permanent;&#125; 知名程序，比如 phpmyadmin 123location /(admin|phpadmin|status) &#123; deny all; &#125; 封杀特定的 http 方法和行为，比如 123456if ($request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 405;&#125;if ($http_range ~ "\d&#123;9,&#125;") &#123; return 444;&#125; 强制网站使用域名访问，可以逃过IP扫描，比如123if ( $host !~* 'abc.com' ) &#123; return 403;&#125; url 参数过滤敏感字，比如1234567if ($query_string ~* "union.*select.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; if ($query_string ~* "concat.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; 强制要求referer123if ($http_referer = "" ) ｛ return 403;｝ 如果不想用403，也可以rewrite一个url，比如一个400页面 123456&lt;html&gt; &lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor="white"&gt; &lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx/1.2.0&lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 小结 可以将上述规则结合起来使用，同时匹配多条规则时才会封杀，下面是一个来自老外的稍微复杂一点的例子： 123456789101112131415set $add 1; location /index.php &#123; limit_except GET POST &#123; deny all; &#125; set $ban ""; if ($http_referer = "" ) &#123;set $ban $ban$add;&#125; if ($request_method = POST ) &#123;set $ban $ban$add;&#125; if ($query_string = "action=login" )&#123;set $ban $ban$add;&#125; if ($ban = 111 ) &#123; access_log /var/log/[133]nginx/ban IP; return 404; &#125; proxy_pass http://127.0.0.1:8000; #here is a patch &#125; 其它方法 封杀IP 定时做日志分析，手动将恶意IP加入 iptables 拒绝名单，推荐使用 ipset 模块。 12yum install -y ipset ipset-serviceipset create badip hash:net maxelem 65535iptables -I INPUT -m set --match-set badip src -p tcp --dport 80 -j DROP/etc/init.d/iptables saveipset add badip 1.1.1.2ipset add badip 2.2.2.0/24/etc/init.d/ipset save ipset 还支持 timeout，类似 redis 的 TTL，timeout 之后会自动删除，比较人性化。比如下面的例子就是 timeout 默认 3600 秒，支持自定义 timeout 12ipset destroy badipipset create badip hash:net maxelem 65535 timeout 3600ipset add badip 1.1.1.1ipset add badip 2.2.2.0/24 timeout 60ipset add badip 3.3.3.0/24 timeout 7200 在日志分析的自动化程度比较高，准确率比较好的情况下，可以考虑通过条件触发 ipset。 限速 适当限制客户端的请求带宽，请求频率，请求连接数，这里不展开论述。根据具体需求，阀值应当稍稍宽泛一点。特别要注意办公室/网吧场景的用户，他们的特点是多人使用同一个网络出口。 目录只读 如果没有上传需求，完全可以把网站根目录弄成只读的，加固安全。做了一点小动作，给网站根目录搞了一个只读的挂载点。这里假设网站根目录为 /var/www/html 1234mkdir -pv /datamkdir -pv /var/www/htmlmount --bind /data /var/www/htmlmount -o remount,ro --bind /data /var/www/html 网站内容实际位于/data，网站内容更新就往/data里更新，目录/var/www/html无法执行任何写操作，否则会报错“Read-only file system”，极大程度上可以防止提权篡改。 overlayfs 这种方法跟上面的方法类似，但是有所区别假设网站根目录/var/www/html有一个目录upload是要求可读写的，其他只读即可，那么仔细看下面的操作 123456mkdir -pv /data/lowermkdir -pv /data/uppermkdir -pv /data/workermv /var/www/html/upload /data/upper/mv /var/www/html/* /data/lower/mount -t overlayfs overlay -o lower=/data/lower,upper=/data/upper,workdir=/data/worker /var/www/html 这样就完美实现了读写分离，底层目录只读，上层目录可写。如果程序被篡改，上层目录 /data/upper 除了 upload 内容之外，还会生成其他文件。overlayfs 因为特殊的机制，建议使用 Linux 内核4.0+，否则比较消耗硬盘的 inode。 定时总结和丰富过滤规则]]></content>
      <categories>
        <category>Nginx笔记</category>
      </categories>
      <tags>
        <tag>Nginx安全加固心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置阅读全文]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FNext%E8%AE%BE%E7%BD%AE%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[如何设置「阅读全文」？ 在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。NexT 提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在 主题配置文件 中添加： 123auto_excerpt: enable: true # 改成 true length: 150 # 默认展示的高度 默认截取的长度为 150 字符，可以根据需要自行设定建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外，这种方式也可以让 Hexo 中的插件更好的识别。 需要注意的是，点击「阅读全文」之后，文章会自动定位到 所在位置，想要修改成从头阅读需要修改 主题配置文件 _config.yml 文件： 12# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: false]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置阅读全文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next开启站内搜索]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FNext%E5%BC%80%E5%90%AF%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[Next 如何开启站内搜索？ NexT 主题支持集成 Swiftype、微搜索、Local Search 和 Algolia,Swiftype 和 Algolia 都只有一段时间的试用期，可以采用 Hexo 提供的Local Search，原理是通过 hexo-generator-search 插件在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 Local Search 由 flashlab 贡献 安装步骤安装 hexo-generator-search 在站点的根目录下执行以下命令 1npm install hexo-generator-search --save 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令1npm install hexo-generator-searchdb --save 启用搜索 编辑 站点配置 文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置 文件，启用本地搜索功能 123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next开启站内搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kickstart自动应答文件]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FKickstart%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Kickstart 自动应答文件 Cobbler vim /var/lib/cobbler/kickstarts/centos7.5-ks.cfg1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Cobbler for Kickstart Configurator for CentOS 7 by clsninstallurl --url=$treetextlang en_US.UTF-8keyboard uszerombrbootloader --location=mbr --driveorder=sda --append="crashkernel=auto rhgb quiet"#Network information$SNIPPET('network_config')#network --bootproto=dhcp --device=eth0 --onboot=yes --noipv6 --hostname=CentOS7timezone --utc Asia/Shanghaiauthconfig --enableshadow --passalgo=sha512rootpw --iscrypted $default_password_cryptedclearpart --all --initlabel# Disk partitioning informationpart pv.374 --fstype="lvmpv" --ondisk=sda --size=2052part pv.671 --fstype="lvmpv" --ondisk=sda --size=20484part pv.639 --fstype="lvmpv" --ondisk=sda --size=1 --growpart /boot --fstype="xfs" --ondisk=sda --size=500volgroup vgswap --pesize=4096 pv.374volgroup vgroot --pesize=4096 pv.671volgroup vgdata --pesize=4096 pv.639logvol / --fstype="xfs" --size=20480 --name=lvroot --vgname=vgrootlogvol swap --fstype="swap" --size=2048 --name=lvswap --vgname=vgswaplogvol /data --fstype="xfs" --size=1 --grow --name=lvdata --vgname=vgdatafirstboot --disableselinux --disabledfirewall --disabledlogging --level=inforeboot%pre$SNIPPET('log_ks_pre')$SNIPPET('kickstart_start')$SNIPPET('pre_install_network_config')# Enable installation monitoring$SNIPPET('pre_anamon')%end%packages@^minimal@compat-libraries@core@debugging@developmentbash-completionchronydos2unixkexec-toolslrzsznmapsysstattelnettreevimwgetnet-tools%end%postsystemctl disable postfix.service%end]]></content>
      <categories>
        <category>Cobbler笔记</category>
      </categories>
      <tags>
        <tag>Kickstart自动应答文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Hexo 简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 安装 进入 D:\Blog\gmlyo\ 自定义目录，右键鼠标，点击 Git Bash Here，输入 npm 命令即可安装 12345678910111213141516右击 Git Bash Herecd /d/Blog/gmlyo/npm install hexo -g 或 npm install hexo-cli -ghexo init 或 hexo init blog; cd blog/# 第一句是安装 hexo# 第二句是安装 hexo 部署到 git page 的 deployer# 两个都需要安装# Hexo 初始化配置（有点漫长的等待。。。）npm initHexo 初始化完成后，Hexo 将会在指定文件夹中新建所需要的文件hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # 或 hexo generatehexo s # 或 hexo server 可以在打开浏览器访问 http://localhost:4000/ 查看 查看 hexo 版本信息12345678910111213141516171819# 查看 hexo 版本信息hexo -vhexo: 3.7.1hexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64http_parser: 2.8.0node: 10.3.0v8: 6.6.346.32-node.9uv: 1.20.3zlib: 1.2.11ares: 1.14.0modules: 64nghttp2: 1.29.0napi: 3openssl: 1.1.0hicu: 61.1unicode: 10.0cldr: 33.0tz: 2018c 常用 Hexo 命令123456# 生成静态文件，会在当前目录下生成一个新的叫做 public 的文件夹hexo generate (hexo g)# 启动本地 Web 服务，用于博客的预览hexo server (hexo s)# 部署播客到远端（比如github, heroku等平台）hexo deploy (hexo d) 其他常用命令12hexo new "postName" # 新建文章hexo new page "pageName" # 新建页面 常用简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 常用组合12hexo d -g # 生成部署hexo s -g # 生成预览]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 绑定自定义域名]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[如何将自己购买的域名连接到 Github Pages？ 12345678在 source 目录下新建 CNAME 文件，在首行添加网站域名如：www.gmlyo.com注意前面没有 https://，http:// 等信息，然后重新重新生成并部署站点hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # hexo generadehexo d # hexo deploy或hexo d -g 设置域名解析1234561、先添加一个CNAME，主机记录写@，后面记录值写上你的 xxx.github.io2、再添加一个CNAME，主机记录写www，后面记录值也是 xxx.github.io这样别人用 www 和不用 www 都能访问你的网站其实 www 的方式，会先解析成 https://xxx.github.io，然后根据 CNAME 再变成 http://www.gmlyo.com，即中间是经过一次转换的。注：除了使用 CNAME 记录也有人使用 A 记录，后面的记录值是写 Github Page 里面的 IP 地址，但有时候 IP 地址会更改，导致最后解析不正确，所以还是推荐用 CNAME 别名记录要好些，不建议用 IP。3、等待10分钟左右，域名生效后刷新浏览器，使用自定义域名访问网站即可 Hexo 部署后，CNAME 会被自动删除，如何解决？123将需要上传至 Github 的文件放在 source 目录下如：CNAME, README.md, favicon.ico, images 目录等将这些都放在 source 目录下，每次上传就不会消失了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 绑定自定义域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 删除文章]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hexo 如何删除文章？ 1234567891011删除文章的过程很简单，先删除本地文件，然后通过生成和部署命令将远程仓库中的文件也一并删除。以最开始默认形成的 hello-world.md 这篇文章为例首先进入 D:\Blog\gmlyo\source\_posts\ 文件夹中找到 hello-world.md 文件，在本地直接执行删除。然后依次执行hexo cleanhexo ghexo d再去主页查看就会发现博客上面已经什么都没有了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 删除文章</tag>
      </tags>
  </entry>
</search>
