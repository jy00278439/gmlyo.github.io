<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RabbitMQ集群配置]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F25%2FRabbitMQ%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[RabbitMQ 集群配置这里展示的是多机集群的部署，如果机器受限，可以选择单机集群部署 选用三台主机，主机名分别是pro-rabbitmq01pro-rabbitmq02pro-rabbitmq03 集群配置RabbitMQ 是用 Erlang 开发的，集群非常方便，因为 Erlang 天生就是一门分布式语言，但其本身并不支持负载均衡。RabbitMQ 利用 Erlang 的分布式特性组建集群，erlang 集群通过 magic cookie 实现，此 cookie 保存在 $HOME/.erlang.cookie这里即：/var/lib/rabbitmq/.erlang.cookie，需要保证集群各节点的此 cookie 一致，可以选取一个节点的 cookie，用 rsync，scp 同步到其余节点。 同步 Cookie读取其中一个节点的 cookie，并复制到其他节点节点之间通过 cookie 确定相互是否可通信。cookie 存放在 /var/lib/rabbitmq/.erlang.cookie或$HOME/.erlang.cookie 中 设置 Erlang CookieRabbitMQ 的集群是依赖于 Erlang 的集群来工作的，所以必须先构建起 Erlang 的集群环境。Erlang 的集群中各节点是通过一个 magic cookie 来实现的，这个 Cookie 存放在 /data/erlang/.erlang.cookie 中，文件是 400 的权限。所以必须保证各节点 Cookie 保持一致，否则节点之间就无法通信。我们是删除其中两台的 /data/erlang/.erlang.cookie，然后将另一台的 /data/erlang/.erlang.cookie 拷贝到这两台上。文件权限是 400 注意：.erlang.cookie 文件的权限，RabbitMQ账号，权限 400 或 600 即可，为组或 other 账号赋权会报错 123rsync -avzP /data/erlang/.erlang.cookie root@10.21.20.94:/data/erlang/# scp /var/lib/rabbitmq/.erlang.cookie root@1.1.1.2:/var/lib/rabbitmq/# scp /var/lib/rabbitmq/.erlang.cookie root@1.1.1.3:/var/lib/rabbitmq/ 逐个启动节点1rabbitmq-server -detached 查看各节点的状态12rabbitmqctl statusrabbitmqctl cluster_status 配置各节点的 hosts 文件1234vim /etc/hostsx.x.x.x pro-rabbitmq01x.x.x.x pro-rabbitmq02x.x.x.x pro-rabbitmq03 组建集群pro-rabbitmq02 和 pro-rabbitmq03以 pro-rabbitmq01 为主节点在 pro-rabbitmq02 上 rabbitmqctl join_cluster rabbit@pro-rabbitmq01 中的 rabbit@pro-rabbitmq01，rabbit 代表集群名pro-rabbitmq01 代表集群节点节点名同 hostname，hostname 与 /etc/hosts 中设置必须保持一致pro-rabbitmq02 与 pro-rabbitmq03 均连接到 pro-rabbitmq01，它们之间也会自动建立连接。如果需要使用内存节点，增加一个 --ram 的参数即可如：rabbitmqctl join_cluster --ram rabbit@pro-rabbitmq01rabbitmqctl join_cluster rabbit@pro-rabbitmq01 --ram一个集群中至少需要一个 disk 节点默认是磁盘节点，如果是内存节点的话，需要加 --ram 参数 1234[root@pro-rabbitmq02 ~]# rabbitmqctl stop_app[root@pro-rabbitmq02 ~]# rabbitmqctl reset[root@pro-rabbitmq02 ~]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01[root@pro-rabbitmq02 ~]# rabbitmqctl start_app pro-rabbitmq03 上的操作与 pro-rabbitmq02 的相同 1234[root@pro-rabbitmq03 ~]# rabbitmqctl stop_app[root@pro-rabbitmq03 ~]# rabbitmqctl reset[root@pro-rabbitmq03 ~]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01[root@pro-rabbitmq03 ~]# rabbitmqctl start_app 12345678910111213141516171819202122232425262728[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl stop_appStopping rabbit application on node rabbit@pro-rabbitmq02 ...[root@pro-rabbitmq02 rabbitmq]# netstat -ntlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:4369 0.0.0.0:* LISTEN 2556/epmd tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2717/sshd tcp 0 0 0.0.0.0:25672 0.0.0.0:* LISTEN 2467/beam.smp tcp6 0 0 :::4369 :::* LISTEN 2556/epmd [root@pro-rabbitmq02 rabbitmq]# rabbitmqctl resetResetting node rabbit@pro-rabbitmq02 ...[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01Clustering node rabbit@pro-rabbitmq02 with rabbit@pro-rabbitmq01[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl start_appStarting node rabbit@pro-rabbitmq02 ... completed with 0 plugins.[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq02 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq01',[]&#125;,&#123;'rabbit@pro-rabbitmq02',[]&#125;]&#125;] 修改集群类型 修改 disk 节点到 内存 节点 1234567891011121314[root@pro-rabbitmq02 ~]# rabbitmqctl change_cluster_node_type ramTurning rabbit@pro-rabbitmq02 into a ram node[root@pro-rabbitmq02 ~]# rabbitmqctl start_appStarting node rabbit@pro-rabbitmq02 ... completed with 3 plugins.[root@pro-rabbitmq02 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq02 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01']&#125;,&#123;ram,['rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq01',[]&#125;,&#123;'rabbit@pro-rabbitmq02',[]&#125;]&#125;] 1234567891011121314[root@pro-rabbitmq03 rabbitmq]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq03 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01']&#125;, &#123;ram,['rabbit@pro-rabbitmq03','rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq02','rabbit@pro-rabbitmq01', 'rabbit@pro-rabbitmq03']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq02',[]&#125;, &#123;'rabbit@pro-rabbitmq01',[]&#125;, &#123;'rabbit@pro-rabbitmq03',[]&#125;]&#125;]# 可以看到三个节点都加入了集群中，两个 ram 节点、一个 disc 节点。# 其中三个节点都在运行中，以及集群名称显示。 默认是磁盘节点，如果是内存节点的话，需要加 --ram 参数RabbitMQ 集群节点有 disc 和 ram 两种类型，一个集群中至少要有一个 disc 类型的节点，不指定默认加入为 disc 12# 将集群类型修改成 disk 节点rabbitmqctl change_cluster_node_type disc]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ集群配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ常用命令]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F24%2FRabbitMQ%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[RabbitMQ常用命令 服务启动关闭12345# 启动rabbitmq-server -detached # 关闭rabbitmqctl stop 集群配置相关命令12345678910111213rabbitmqctl stop_app rabbitmqctl reset # 在当前集群中加入某节点rabbitmqctl join_cluster &#123;rabbit_node_name&#125;# 某些低版本可以采用 rabbitmqctl cluster &#123;rabbit_node_name&#125;rabbitmqctl start_app # 集群状态rabbitmqctl cluster_status# 将某节点剔除出当前集群rabbitmqctl forget_cluster_node &#123;rabbit_node_name&#125; 插件管理123456789101112# 开启某个插件rabbitmq-plugins enable &#123;插件名&#125;# 关闭某个插件rabbitmq-plugins disable &#123;插件名&#125;# 有关插件名可以在 rabbitmq 的安装目录下的 plugins 目录中查看$RABBITMQ_HOME/plugins# 举例rabbitmq-plugins enable rabbitmq_management rabbitmq-plugins list 用户管理1234567891011121314151617# 添加用户rabbitmqctl add_user &#123;username&#125; &#123;password&#125;# 删除用户rabbitmqctl delete_user &#123;username&#125;# 修改密码rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;# 设置用户角色rabbitmqctl set_user_tags &#123;username&#125; &#123;tag&#125;tag 可以为 administrator, monitoring, management# 举例rabbitmqctl add_user root rootrabbitmqctl set_user_tags root administratorrabbitmqctl list_users 权限管理123456789101112131415161718# 权限设置rabbitmqctl set_permissions [-p vhostpath] &#123;user&#125; &#123;conf&#125; &#123;write&#125; &#123;read&#125;conf # 一个正则表达式match哪些配置资源能够被该用户访问write # 一个正则表达式match哪些配置资源能够被该用户读read # 一个正则表达式match哪些配置资源能够被该用户访问# 查看（指定vhost）所有用户的权限信息rabbitmqctl list_permissions [-p vhostPath]# 查看指定用户的权限信息rabbitmqctl list_user_permissions &#123;username&#125;# 清除用户的权限信息rabbitmqctl clear_permissions [-p vhostPath] &#123;username&#125;# 举例rabbitmqctl set_permissions -p / root "." "." ".*" 获取服务器状态信息1234567891011121314151617181920212223242526272829303132333435# 服务器状态rabbitmqctl status# 队列信息rabbitmqctl list_queues -p vhostpath# queueinfoitem可以为name, durable, auto_delete, arguments, messages_ready, messages_unacknowled, messages, consumers, memory.# Exchange信息rabbitmqctl list_exchanges -p vhostpath# exchangeinfoitem有name, type, durable, auto_delete, internal, arguments.# Binding信息rabbitmqctl list_bindings -p vhostpath# bindinginfoitem有source_name, source_kind, destination_name, destination_kind, routing_key, arguments.等# connection信息rabbitmqctl list_connections [connectioninfoitem ...]# connectioninfoitem有recv_oct，recv_cnt，send_oct，send_cnt，send_pend 等。# channel信息rabbitmqctl list_channels [channelinfoitem ...]# channelinfoitem有consumer_count，messages_unacknowledged，messages_uncommitted，acks_uncommitted，messages_unconfirmed，prefetch_count，client_flow_blocked# 举例rabbitmqctl list_queues name messages_ready pid slave_pids 更改节点类型12345rabbitmqctl stop_apprabbitmqctl change_cluster_node_type disc或rabbitmqctl change_cluster_node_type ramrabbitmqctl start_app vhost管理12345# 添加vhostrabbitmqctl add vhost &#123;name&#125;# 删除vhostrabbitmqctl delete vhost &#123;name&#125; 镜像队列的设置12345678910111213141516镜像队列的配置通过添加 policy 完成，policy 添加的命令为rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority] -p Vhost: # 可选参数，针对指定 vhost 下的 queue 进行设置Name: # policy 的名称Pattern: # queue 的匹配模式（正则表达式）Definition: # 镜像定义，包括三个部分 ha-mode，ha-params，ha-sync-mode ha-mode: # 指明镜像队列的模式，有效值为 all/exactly/nodes all # 表示在集群所有的节点上进行镜像 exactly # 表示在指定个数的节点上进行镜像，节点的个数由 ha-params 指定 nodes # 表示在指定的节点上进行镜像，节点名称通过 ha-params 指定 ha-params: # ha-mode模式需要用到的参数 ha-sync-mode: # 镜像队列中消息的同步方式，有效值为 automatic，manually # 有效值为 automatic（自动同步），manually（手动同步），默认是 manually # 请注意一定要记得设置为 automatic（自动同步），否则消息在镜像队列中是不会自动同步的（即普通集群模式），只能通过命令手动去同步Priority: # 可选参数，policy 的优先级 示例1234567# 对队列名称以 hello 开头的所有队列进行镜像，并在集群的两个节点上完成镜像# policy 的设置命令为rabbitmqctl set_policy hello-ha "^hello" '&#123;"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"&#125;'# 对队列名称以 “queue_” 开头的所有队列进行镜像，并在集群的两个节点上完成进行# policy 的设置命令为rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue "^queue_" '&#123;"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"&#125;' policy 相关解释12345Name： # policy 策略的唯一名称Pattern： # 用于匹配 exchange 和 queue 等名称的正则表达式Apply to： # 指定将此 policy 应用到哪些项上（例如：exchange，queue等）Priority： # 可选参数，policy 的优先级，exchange 和 queue 名称可以匹配到多个 policy，优先级则定义了 policy 被执行的顺序Definition：# 参数定义 消息的同步 将新节点加入已存在的镜像队列是，默认情况下 ha-sync-mode=manual，镜像队列中的消息不会主动同步到新节点，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行操作，直到同步完毕。当 ha-sync-mode=automatic 时，新加入节点时会默认同步已知的镜像队列。由于同步过程的限制，所以不建议在生产的 active 队列（有生产消费消息）中操作。 12345678910# 可以使用下面的命令来查看那些 slaves 已经完成同步rabbitmqctl list_queues name slave_pids synchronised_slave_pids# 可以通过手动的方式同步一个 queuerabbitmqctl sync_queue name# 同样也可以取消某个 queue 的同步功能rabbitmqctl cancel_sync_queue name# 当然这些都可以通过 management 插件来设置 参考文档https://blog.csdn.net/u013256816/article/details/53524814]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ用户管理]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F24%2FRabbitMQ%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 用户管理 创建用户 在 RabbitMQ 中，用户是访问控制（Access Control）的基本单元，且单个用户可以跨越多个vhost 进行授权。针对一至多个 vhost，用户可以被赋予不同级别的访问权限，并使用标准的用户名和密码来认证用户。创建用户的命令为：rabbitmqctl add_user {username} {password}。其中username 表示要创建的用户名称。password 表示创建用户登录的密码。具体创建一个用户名为 root、密码为 root123 的用户 12[root@node1 ~]# rabbitmqctl add_user root root@123Creating user "root" 修改密码可以通过rabbitmqctl change_password {username} {newpassword}命令来更改指定用户的密码其中username 表示要变更密码的用户名称newpassword 表示要变更的新的密码 举例：将 root用户的密码变更为 root32112[root@node1 ~]# rabbitmqctl change_password root root@321Changing password for user "root" 清除密码同样可以清除密码，这样用户就不能使用密码登录了对于的操作命令为：rabbitmqctl clear_password {username}其中username 表示要清楚密码的用户名称 验证用户使用rabbitmqctl authenticate_user {username} {password}可以通过密码来验证用户其中username 表示需要被验证的用户名称password 表示密码 下面示例中分别采用 root321 和 root322 来验证 root 用户1234567[root@node1 ~]# rabbitmqctl authenticate_user root root@321Authenticating user "root"Success[root@node1 ~]# rabbitmqctl authenticate_user root root@322Authenticating user "root"Error: failed to authenticate user "root" 删除用户删除用户的命令是rabbitmqctl delete_user {username}其中username 表示要删除的用户名称 删除用户 root 的示例如下12[root@node1 ~]# rabbitmqctl delete_user rootDeleting user "root" 查询用户列表rabbitmqctl list_users 命令可以用来罗列当前的所有用户每个结果行都包含用户名称，其后紧跟用户的角色（tags） 示例代码如下：1234[root@node1 ~]# rabbitmqctl list_usersListing usersguest [administrator]root [] 用户的角色分为 5 种类型none：无任何角色。新创建的用户的角色默认为 none。management：可以访问 Web 管理页面。policymaker：包含 management 的所有权限，并且可以管理策略（policy）和参数（parameter）。monitoring：包含 management 的所有权限，并且可以看到所有连接（connections）、信道（channels）以及节点相关的信息。administartor：包含 monitoring 的所有权限，并且可以管理用户、虚拟主机、权限、策略、参数等等。administator 代表了最高的权限。 设置用户角色用户的角色可以通过rabbitmqctl set_user_tags {username} {tag...}命令设置。其中username 参数表示需要设置角色的用户名称。tag 参数用于设置 0 个、1 个 或者 多 个的角色，设置之后任何之前现有的身份都会被删除。 使用示例如下：12345678910111213141516171819202122[root@node1 ~]# rabbitmqctl set_user_tags root monitoringSetting tags for user "root" to [monitoring][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [monitoring][root@node1 ~]# rabbitmqctl set_user_tags root policymaker -q[root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [policymaker][root@node1 ~]# rabbitmqctl set_user_tags rootSetting tags for user "root" to [][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [][root@node1 ~]# rabbitmqctl set_user_tags root policymaker,managementSetting tags for user "root" to ['policymaker,management'][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [policymaker,management] 参考文档https://blog.csdn.net/u013256816/article/details/78181306]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ用户管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ集群管理]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F24%2FRabbitMQ%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 集群管理 rabbitmqctl join_cluster {cluster_node} [–ram] 将节点加入指定集群中。在这个命令执行前需要停止 RabbitMQ 应用并重置节点。 rabbitmqctl cluster_status 显示集群的状态 rabbitmqctl change_cluster_node_type {disc|ram} 修改集群节点的类型。在这个命令执行前需要停止 RabbitMQ 应用 rabbitmqctl forget_cluster_node [–offline] 将节点从集群中删除，允许离线执行 rabbitmqctl update_cluster_nodes {clusternode} 在集群中的节点应用启动前咨询 clusternode 节点的最新信息，并更新相应的集群信息。这个和 join_cluster 不同，它不加入集群。考虑这样一种情况，节点A 和 节点B 都在集群中，当节点A离线了，节点C 又和 节点B 组成了一个集群，然后 节点B 又离开了集群，当 A 醒来的时候，它会尝试联系 节点B，但是这样会失败，因为节点B已经不在集群中了。rabbitmqctl update_cluster_nodes -n A C 可以解决这种场景。 示例如下：12345678910111213141516171819202122232425262728293031323334353637383940# 假设已有 node1 和 node2 组成的集群# 1. 初始状态[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;]# 2. 关闭 node1 节点的应用[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1# 3. 之后将 node3 加入到集群中（rabbitmqctl join_cluster rabbit@node2）# 4. 再将 node2 节点的应用关闭# 5. 最后启动 node1 节点的应用，此时会报错[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1BOOT FAILED===========Timeout contacting cluster nodes: [rabbit@node2].....(省略)# 6. 如果在启动 node1 节点的应用之前咨询 node3 并更新相关集群信息则可以解决这个问题[root@node1 ~]# rabbitmqctl update_cluster_nodes rabbit@node3Updating cluster nodes for rabbit@node1 from rabbit@node3[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1# 7. 最终集群状态[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node3]&#125;]&#125;, &#123;running_nodes,[rabbit@node3,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node3,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;] rabbitmqctl force_boot确保节点可以启动，即使它不是最后一个关闭的节点。通常情况下，当关闭整个 RabbitMQ 集群时，重启的第一个节点应该是最后关闭的节点，因为它可以看到其它节点所看不到的事情。但是有时会有一些异常情况出现，比如整个集群都掉电而所有节点都认为它不是最后一个关闭的。在这种情况下，可以调用 rabbitmqctl force_boot 命令，这就告诉节点可以无条件的启动节点。在此节点关闭后，集群的任何变化，它都会丢失。如果最后一个关闭的节点永久丢失了，那么你需要优先使用 rabbitmqctl forget_cluster_node –offline 命令，因为它可以确保镜像队列的正常运转。 示例如下：123[root@node2 ~]# rabbitmqctl force_bootForcing boot for Mnesia dir /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node2[root@node2 ~]# rabbitmq-server –detached rabbitmqctl sync_queue [-p vhost] {queue} 指示未同步队列 queue 的 slave 镜像可以同步 master 镜像行的内容。同步期间此队列会被阻塞（所有此队列的生产消费者都会被阻塞），直到同步完成。此条命令执行成功的前提是队列queue 配置了镜像。注意，未同步队列中的消息被耗尽后，最终也会变成同步，此命令主要用于未耗尽的队列。 示例如下：12[root@node1 ~]# rabbitmqctl sync_queue queueSynchronising queue 'queue' in vhost '/' rabbitmqctl cancel_sync_queue [-p vhost] {queue} 取消队列 queue 同步镜像的操作。 示例如下：12[root@node1 ~]# rabbitmqctl cancel_sync_queue queueStopping synchronising queue 'queue' in vhost '/' rabbitmqctl set_cluster_name {name} 设置集群名称。集群名称在客户端连接时会通报给客户端。Federation 和 Shovel 插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。 示例如下：12345678910111213141516[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;][root@node1 ~]# rabbitmqctl set_cluster_name cluster_hiddenSetting cluster name to cluster_hidden[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"cluster_hidden"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;] 参考文档https://blog.csdn.net/u013256816/article/details/78348761]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ集群管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ应用管理]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F24%2FRabbitMQ%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 应用管理本文主要阐述应用与集群相关的一些操作管理命令，包括关闭、重置、开启服务，还有建立集群的一些信息。 rabbitmqctl stop [pid_file] 用于停止运行 RabbitMQ 的 Erlang 虚拟机和 RabbitMQ 服务应用。如果指定了 pid_file，还需要等待指定进程的结束。其中 pid_file 是通过调用 rabbitmq-server 启动 RabbitMQ 服务时创建的，默认情况下存放于 Mnesia 目录中，可以通过 RABBITMQ_PID_FILE 这个环境变量来改变存放路径。注意，如果是 rabbitmq-server –detach 启动的 RabbitMQ 服务则不会生成 pid_file 这个文件。 示例如下：123456[root@node1 ~]# rabbitmqctl stop/data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidStopping and halting node rabbit@node1[root@node1 ~]# rabbitmqctl stopStopping and halting node rabbit@node1 rabbitmqctl shutdown 用于停止运行 RabbitMQ 的 Erlang 虚拟机 和 RabbitMQ 服务应用。执行这个命令会阻塞直到 Erlang 虚拟机进程的退出。如果 RabbitMQ 没有成功关闭，则会返回一个非零值。这个命令和 rabbitmqctl stop 的不同的是，它不需要指定 pid_file 而可以阻塞等待指定进程的关闭。 示例如下：1234[root@node1 ~]# rabbitmqctl shutdownShutting down RabbitMQ node rabbit@node1 running at PID 1706Waiting for PID 1706 to terminateRabbitMQ node rabbit@node1 running at PID 1706 successfully shut down rabbitmqctl stop_app 停止 RabbitMQ 服务应用，但是 Erlang 虚拟机还是处于运行状态。此命令优先执行其他管理操作（这些管理操作需要先停止 RabbitMQ 应用），比如 rabbitmqctl reset。 示例如下：12[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1 rabbitmqctl start_app 启动 RabbitMQ 应用。此命令典型的用途是在执行了其他管理操作之后，重新启动之前停止的 RabbitMQ 应用，譬如rabbitmqctl reset。 示例如下：12[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1 rabbitmqctl wait [pid_file] 等待 RabbitMQ 应用的启动。它会等到 pid_file 的创建，然后等待 pid_file 中的所代表的进程启动。当指定的进程没有启动 RabbitMQ 应用而关闭时将会返回失败。 示例如下：12345678[root@node1 ~]# rabbitmqctl wait /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidWaiting for rabbit@node1pid is 3468[root@node1 ~]# rabbitmqctl wait /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidWaiting for rabbit@node1pid is 3468Error: process_not_running rabbitmqctl reset 将 RabbitMQ 节点重置还原到最初状态，包括从原所在的集群中删除此节点，从管理数据库中删除所有的配置数据，如已配置的用户、vhost等，以及删除所有的持久化消息。执行 rabbitmqctl reset 命令前必须停止 RabbitMQ 应用（比如先执行 rabbitmqctl stop_app）。 示例如下：12345[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1[root@node1 ~]# rabbitmqctl resetResetting node rabbit@node1 rabbitmqctl force_reset 强制将 RabbitMQ 节点重置还原到最初状态。不同于 rabbitmqctl reset，rabbitmqctl force_reset 命令不论当前管理数据库的状态和集群配置是什么，会无条件地重置节点。它只能在数据库或集群配置已损坏的情况下才可使用。与 rabbitmqctl reset 命令一下，执行 rabbitmqctl force_reset 命令前必须先停止RabbitMQ 应用。 示例如下：12345[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1[root@node1 ~]# rabbitmqctl force_resetForcefully resetting node rabbit@node1 rabbitmqctl rotate_logs {suffix} 指示 RabbitMQ 节点轮换日志文件。RabbitMQ 节点会将原来的日志文件中的内容追加到 “原始名称+后缀”的日志文件中，然后再将新的日志内容记录到新创建的日志中（与原日志文件同名）。当目标文件不存在时，将会重新创建。如果不指定 suffix，那么则日志文件只是重新打开而不会进行轮换。 示例如下所示原日志文件为 `rabbit@node1.log和rabbit@node1-sasl.log，轮换日志之后，原日志文件中的内容就被追加到rabbit@node1.log.1和rabbit@node1-sasl.log.1日志中，之后重新建立rabbit@node1.log和rabbit@node1-sasl.log` 文件用来接收新的日志。1234567891011121314[root@node1 rabbitmq]# pwd/data/app/rabbitmq/var/log/rabbitmq[root@node1 rabbitmq]# ll-rw-r--r-- 1 root root 1024127 Aug 18 11:56 rabbit@node1.log-rw-r--r-- 1 root root 720553 Aug 17 19:16 rabbit@node1-sasl.log[root@node1 rabbitmq]# rabbitmqctl rotate_logs .1Rotating logs to files with suffix ".1"[root@node1 rabbitmq]# ll-rw-r--r-- 1 root root 0 Aug 18 12:05 rabbit@node1.log-rw-r--r-- 1 root root 1024202 Aug 18 12:05 rabbit@node1.log.1-rw-r--r-- 1 root root 0 Aug 18 12:05 rabbit@node1-sasl.log-rw-r--r-- 1 root root 720553 Aug 18 12:05 rabbit@node1-sasl.log.1 rabbitmqctl hipe_compile {directory} 将部分 RabbitMQ 代码用 HiPE（HiPE是指High Performance Erlang ，是Erlang版的JIT）编译，并且将编译后的 .beam 文件（beam 文件是 Erlang 编译器生成的文件格式，可以直接加载到 Erlang 虚拟机中运行的文件格式）保存到指定的文件目录中。如果这个目录不存在则会自行创建。如果这个目录中原本有任何 .beam 文件，则会在执行编译前被删除。如果要使用预编译的这些文件，需要设置 RABBITMQ_SERVER_CODE_PATH 这个环境变量来指定hipe_compile 调用的路径。 示例如下：123456789101112131415161718192021222324[root@node1 rabbitmq]# rabbitmqctl hipe_compile /data/app/rabbitmq/tmp/rabbit-hipe/ebinHiPE compiling: |---------------------------------------------------------| |#########################################################|Compiled 57 modules in 55s[root@node1 rabbitmq]# ls /opt/rabbitmq/tmp/rabbit-hipe/ebinarray.beam proplists.beam rabbit_misc.beamcredit_flow.beam qlc.beam rabbit_msg_file.beamdelegate.beam queue.beam rabbit_msg_store.beamdict.beam rabbit_amqqueue.beam rabbit_msg_store_ets_index.beamfile_handle_cache.beam rabbit_amqqueue_process.beam rabbit_net.beamgb_sets.beam rabbit_basic.beam rabbit_queue_index.beamgb_trees.beam rabbit_binary_generator.beam rabbit_reader.beamgen.beam rabbit_binary_parser.beam rabbit_router.beamgen_fsm.beam rabbit_channel.beam rabbit_trace.beamgen_server2.beam rabbit_command_assembler.beam rabbit_variable_queue.beamlists.beam rabbit_event.beam rabbit_writer.beamlqueue.beam rabbit_exchange.beam rpc.beammnesia.beam rabbit_exchange_decorator.beam sets.beammnesia_lib.beam rabbit_exchange_type_direct.beam sofs.beammnesia_tm.beam rabbit_exchange_type_fanout.beam ssl.beamorddict.beam rabbit_exchange_type_topic.beam ssl_connection.beamordsets.beam rabbit_framing_amqp_0_9_1.beam ssl_record.beampmon.beam rabbit_guid.beam tls_connection.beampriority_queue.beam rabbit_limiter.beam tls_record.beam 参考文档https://blog.csdn.net/u013256816/article/details/78221439]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ应用管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx修改隐藏版本号]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F17%2FNginx%E4%BF%AE%E6%94%B9%E9%9A%90%E8%97%8F%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Nginx修改隐藏版本号Nginx 配置文件 配置文件里增加 server_tokens off;server_tokens 作用域是 http server location 语句块server_tokens 默认值是 on，表示显示版本信息，设置 server_tokens 值是 off，就可以在所有地方隐藏 nginx 的版本信息 隐藏 Nginx 版本号 在 /data/app/nginx/conf/nginx.conf 里 123456vim /data/app/nginx/conf/nginx.confhost &#123;...省略... server_tokens off;...省略...&#125; 这样修改之后能隐藏掉 nginx 的版本号，但是还是可以显示 Web 软件为 nginx 修改 Nginx 源码版本信息1curl -I "http://127.0.0.1 | grep Server" Nginx 编译前修改版本及版本号1234567891011121314151617181920212223cd /data/tools/cd nginx-1.15.1/vim ./src/core/nginx.h... 省略 ...#define nginx_version 1008001#define NGINX_VERSION "" # 修改想要显示的版本#define NGINX_VER "FastDFS" NGINX_VERSION # 将 nginx 修改成想要显示的软件名称... 省略 ...#define NGINX_VAR "FastDFS" # 将 nginx 修改成想要显示的软件名称(Evan Web Server)#define NGX_OLDPID_EXT ".oldbin"vim ./src/http/ngx_http_header_filter_module.c// static u_char ngx_http_server_string[] = "Server: nginx" CRLF;static u_char ngx_http_server_string[] = "Server: FastDFS" CRLF; # 将 nginx 修改为想要的版本static u_char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;static u_char ngx_http_server_build_string[] = "Server: " NGINX_VER_BUILD CRLF;vim ./src/http/ngx_http_special_response.cstatic u_char ngx_http_error_tail[] =// "&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;" CRLF"&lt;hr&gt;&lt;center&gt;FastDFS&lt;/center&gt;" CRLF # 将 nginx 修改为想要的版本信息"&lt;/body&gt;" CRLF"&lt;/html&gt;" CRLF 修改 fastcgi123456789101112cd /data/tools/nginx-1.15.1/vim ./conf/fastcgi_params找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;修改为fastcgi_param SERVER_SOFTWARE FastDFS/$nginx_version;vim ./conf/fastcgi.conf找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;修改为fastcgi_param SERVER_SOFTWARE FastDFS/$nginx_version; 修改探针中显示的 Web 服务软件信息，在编译前，fastcgi 编译后修改都可以 注意： 当添加 server_tokens off; 参数的时候，调用的是 src/http/ngx_http_header_filter_module.c 里的值不添加的时候，显示版本号调用的是 src/core/nginx.h 里的值所以我们修改的时候需要两个地方都修改。]]></content>
      <categories>
        <category>Nginx笔记</category>
      </categories>
      <tags>
        <tag>Nginx修改隐藏版本号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件处理]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F11%2FPython%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件处理 应用程序中需要经常将内存的数据永久保存下来，而应用程序又无法直接操作硬件只能通过操作系统提供的虚拟单位去间接地操作硬盘 打开文件 open(&#39;文件的路径&#39;, mode=&#39;打开文件的模式&#39;, encoding=&#39;操作文件的字符编码&#39;)r 表示 原始字符串，不转义任何特殊字符 向操作系统发送打开文件的请求 向操作系统发送打开文件的请求 1open(r'/tmp/a.txt') open 有返回值12345f = open(r'/tmp/a.txt', mode='r')print(f)# 输出结果&lt;_io.TextIOWrapper name='/tmp/a.txt' mode='r' encoding='UTF-8'&gt; f =&gt; 应用程序中的一个值 =&gt; 操作系统打开的文件 a.txt =&gt; 硬盘中的一块空间 读/写123456789101112# 应用程序向操作系统发送请求，打开文件f.read() # 把文件内容全都读到内存里去f = open(r'a.txt', mode='r')data = f.read()print(data)# 输出结果UnicodeDecodeError: 'gbk' codec can't decode byte 0x8a in position 8: illegal multibyte sequenc# 注意 不同 操作系统平台 字符编码问题# Windows gbk# Linux utf-8 12345678f = open(r'a.txt', mode='r', encoding='utf-8') # 指定打开文件的字符编码为 utf-8data = f.read() # 在读取的时候就会以 utf-8 的编码读取print(data)# 输出结果你好啊aaawoca 嘞 关闭文件，释放资源1234567f.close() # 回收操作系统的资源，操作系统会定期回收资源print(f) # f 的资源会自动被 Python 回收掉f.read()# 输出结果ValueError: I/O operation on closed file.# del f # 手动回收 f 资源，不要在 f.close() 之前用这个 总结 文件处理的步骤 打开文件 读/写文件 关闭文件 打开多个文件12f1 = open(r'a1.txt', mode='r')f2 = open(r'a2.txt', mode='r') 操作系统资源 =&gt; 文件描述符应用程序资源 with 上下文管理 帮你打开文件先将操作系统把文件打开然后把打开结果赋值给 f（占用两个资源）123with open(r'a.txt', mode='r', encoding='utf-8') as f: print('==&gt;') # 运行 with 的子代码块 print(f.read()) # 在这里基于 with 打开的文件，做读写操作 with 会帮我们自动 close with 打开多个文件12345with open(r'a.txt', mode='r', encoding='utf-8') as f1,\ open(r'b.txt', mode='r', encoding='utf-8') as f2: print('==&gt;') print(f1.read()) print(f2.read()) 文件的打开模式三种纯净模式 r 只读模式（默认模式，文件必须存在，不存在则抛出异常）w 只写模式（不可读，不存在则创建；存在则清空内容）a 只追加写模式（不可读，不存在则创建；存在则追加内容） 控制操作文件内容的模式两种模式 不能单独使用，必须与 r，w，a 连用t（默认）：text文本模式，该模式操作文件内容的单位都是字符串，该模式只适用于文本文件注意： 该模式下必须指定 encoding=&quot;字符编码&quot;b：bytes 二进制模式，该模式下操作文件的内容单位都是bytes，该模式适用于所有类型文件 r 模式，只读模式 默认单位：t，可以不指定默认文件的打开模式是 rt 模式文件必须存在，不存在则报错文件存在则打开文件，并且将文件指针跳到文件的开头 read() 方法 读取所有内容，光标移动到文件末尾把文件内容一次性全都读出，读成 str字符串 数据类型 123456with open('a.txt', mode='rt', encoding='utf-8') as f: data = f.read() print(type(data))# 输出结果&lt;class 'str'&gt; 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: data = f.read() print(data)# 输出结果你好啊aaawoca 了 1234567891011with open('a.txt', mode='rt', encoding='utf-8') as f: data1 = f.read() print('第一次', data1) data2 = f.read() print('第二次', data2)# 输出结果第一次 你好啊aaawoca 了第二次 readable() 判断文件是否可读12345with open('a.txt', mode='rt', encoding='utf-8') as f: print(f.readable())# 输出结果True writable() 判断文件是否可写 r 读模式，不能写，只能读 12345678910with open('a.txt', mode='rt', encoding='utf-8') as f: print(f.writable())# 输出结果Falsewith open('a.txt', mode='rt', encoding='utf-8') as f: f.write('hello')# 输出结果io.UnsupportedOperation: not writable 1234f.closed # 文件是否关闭f.encoding # 如果文件打开模式为b，则没有该属性f.flush() # 立刻将文件内容从内存刷到硬盘f.name readline() 方法 一次读一行读取一行内容，光标移动到第二行首部 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: line = f.readline() print(line, end='') # end='' 取消 print() 自带的换行 print('====&gt;')# 输出结果你好啊====&gt; 1234567891011with open('a.txt', mode='rt', encoding='utf-8') as f: line1 = f.readline() print(line1, end='') # end='' 取消 print() 自带的换行 print('====&gt;') line2 = f.readline() print(line2, end='')# 输出结果你好啊====&gt;aaa readlines() 方法 读取每一行内容，存放于列表中把文件内容一次性全都读出，读成 list列表 数据类型，和 read() 类似 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: l = f.readlines() print(type(l)) print(l)# 输出结果&lt;class 'list'&gt;['你好啊\n', 'aaa\n', 'woca 了'] w 模式，只写模式 只写模式文件存在，会将文件内容情空，并且将文件指针跳到文件的开头文件不存在，则创建一个空文件，并且将文件指针跳到文件的开头 12with open('b.txt', mode='wt', encoding='utf-8') as f: pass 1234567891011with open('b.txt', mode='wt', encoding='utf-8') as f: print(f.readable()) print(f.writable())# 输出结果FalseTruewith open('a.txt', mode='wt', encoding='utf-8') as f: f.readline()# 输出结果io.UnsupportedOperation: not readable write() 方法 针对文本模式的写，需要自己写换行符 12f.write('1111\n2222\n')f.write('1111\n2222\n'.encode('utf-8')) 12345with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊')# 打开文件 b.txt你好啊 123456with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊') f.write('我的天')# 打开文件 b.txt你好啊我的天 1234567with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊\n') f.write('我的天')# 打开文件 b.txt你好啊我的天 注意：如果每次都是重新打开文件，那么文件内容总会清空，指针永远跳到开头如果在打开文件不关闭的情况下，连续的写入，本次写入会基于上一次指针所在的位置往后继续写 writelines() 方法 文件模式12f.writelines(['333\n','444\n'])f.writelines([bytes('333\n', encoding='utf-8'), '444\n'.encode('utf-8')]) 1234567891011121314151617with open('b.txt', mode='wt', encoding='utf-8') as f: l = ['1111\n', '2222\n', '3333\n'] f.writelines(l)# 打开文件 b.txt111122223333# 相当于with open('b.txt', mode='wt', encoding='utf-8') as f: l = ['1111\n', '2222\n', '3333\n'] for line in l: f.write(line)# 打开文件 b.txt111122223333 1234567with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('1111\n\2222\n3333\n')# 打开文件 b.txt111122223333 换行符 \n Unix/Linux平台\r 老 Mac OS\n 新 Mac OS X\r\n Windows平台 查看换行符12345with open('b.txt', mode='rb') as f: print(f.read())# 输出结果b'1111\r\n2222\r\n3333\r\n' 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: l = f.readlines() print(l) print(type(l))# 输出结果['1111\n', '2222\n', '3333']&lt;class 'list'&gt; write() 将内容一次性写入文件中 12345with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('hello')# 打开文件 b.txthello writelines() 将内容循环写入文件中 12345678910with open('b.txt', mode='wt', encoding='utf-8') as f: f.writelines('hello')# 相当于with open('b.txt', mode='wt', encoding='utf-8') as f: for i in 'hello': f.write(i)# 打开文件 b.txthello a 模式，只追加写模式 文件不存在，则创建一个空文件，并且将文件指针跳到文件的末尾文件存在，则会将文件指针跳到文件的末尾 12with open('a.txt', mode='at', encoding='utf-8') as f: pass 12345with open('a.txt', mode='at', encoding='utf-8') as f: print(f.writable())# 输出结果True 1234567with open('a.txt', mode='at', encoding='utf-8') as f: print(f.readable()) f.read()# 输出结果Falseio.UnsupportedOperation: not readable 123456789with open('a.txt', mode='at', encoding='utf-8') as f: f.write('你好\n')# 打开文件 a.txt111122223333你好你好你好 1234567891011with open('a.txt', mode='at', encoding='utf-8') as f: f.writelines(['aaaa\n', 'bbbb\n'])# 打开文件 a.txt111122223333你好你好你好aaaabbbb b 模式 操作文件内容 操作文件内容 t模式 有局限性优点：读写文件以 字符串 为单位，不用自己去进行编码解码的转换缺点：仅仅只适用于文本文件我们不仅仅要操作文本文件，还要操作 图片，视频，等，再用 t模式 就无法处理了文本文件 里存的是 字符，而 图片，视频文件中存的是 二进制 12345with open('1.mp4', mode='rt', encoding='utf-8') as f: f.read()# 输出结果UnicodeDecodeError: 'utf-8' codec can't decode byte 0x86 in position 37: invalid start byte b模式 字节，二进制模式，一种原始的模式，在硬盘上存的都是二进制模式，如果打开的文件时 b模式，意味告诉操作系统，不用做转换，文件存的是什么，读出来就是什么bytes` 二进制模式，该模式下操作文件的内容单位都是bytes，该模式适用于所有类型文件 注意： b模式 不需要指定 encoding 参数12345with open('1.mp4', mode='rb', encoding='utf-8') as f: f.read()# 输出结果ValueError: binary mode doesn't take an encoding argument 获取 音频文件 二进制内容 12345678with open('1.mp4', mode='rb') as f: data = f.readline() # 文件大，文件内容多，用 readline() print(type(data)) print(data)# 输出结果&lt;class 'bytes'&gt;b'\x00\x00\x00\xlcftypisom\x00\x00\x02\x00isomiso2mp41\x00\x00\x08free\t...' 获取 文本文件 二进制内容 12345678with open('d.txt', mode='rb') as f: data = f.read() # 文件小，文件内容少，用 read() print(type(data)) print(data)# 输出结果&lt;class 'bytes'&gt;b'\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x95\x8a\r\naaaa\r\nbbbbccc\r\n1111' 12345678910with open('d.txt', mode='rb') as f: data = f.read() res = data.decode('utf-8') # 将读出的二进制内容解码，转换成人类可识别的内容 print(res)# 输出结果你好啊aaaabbbbccc1111 12with open('d.txt', 'wb') as f: f.write('你好，Python'.encode('utf-8')) 遍历文件内容的方式12345678with open(r'd.txt', mode='rt', encoding='utf-8') as f: for line in f: # 如果文件过大，使用 for循环 读文件内容 print(line, end='')# 输出结果你好，Python你好，Python你好，Python 123456with open(r'd.txt', mode='rb') as f: print(f.readline()) print(f.readline()) print(f.readline())# 输出结果 二进制文件内容，换行符不会被识别 12print(b'11111111\n')print('====================') 输出 二进制文件 内容时，print() 内不要加 end=&#39;&#39;遍历 音频文件 内容 123with open('1.mp4', mode='rb') as f: for line in f: print(line) 练习：利用 b模式，编写一个 cp工具，要求如下： 既可以拷贝文本又可以拷贝视频，图片等文件 用户一旦参数错误，打印命令的正确使用方法，如 usage: cp source_file target_file提示：可以用 import sys，然后用 sys.argv 获取脚本后面跟的参数 1234567import sysprint(sys.argv)# 执行python3 cp.py src.txt dst.txt['cp.py', 'src.txt', 'dst.txt'] 123456789import sysprint(sys.argv[1])print(sys.argv[2])# 执行python3 cp.py src.txt dst.txtsrc.txtdst.txt 1234567891011import sysif len(sys.argv) != 3: print('usage: cp source_file target_file') sys.exit()source_file, target_file=sys.argv[1], sys.argv[2]with open(source_file,'rb') as read_f, \ open(target_file,'wb') as write_f: for line in read_f: write_f.write(line) 文件内光标移动 read(3) 文件打开方式为文本模式时，代表读取 3 个字符 文件打开方式为 b模式 时，代表读取 3 个字节其余的文件内光标移动都是以字节为单位如 seek，tell，truncate 注意： seek 有三种移动方式 0，1，2，其中 1 和 2 必须在 b模式 下进行，但无论哪种模式，都是以 bytes 为单位移动的 truncate是截断文件，所以文件的打开方式必须可写，但是不能用 w 或 w+ 等方式打开，因为那样直接清空文件了，所以 truncate 要在 r+ 或 a 或 a+ 等模式下测试效果 练习：基于 seek 实现 tail -f 功能12345678910import timewith open('test.txt', 'rb') as f: f.seek(0,2) while True: line=f.readline() if line: print(line.decode('utf-8')) else: time.sleep(0.2)]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python列表类型]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F10%2FPython%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[list 列表类型 用途 存放多个值，记录人多个爱好，多个人名 定义方式 在 [] 内用逗号分隔 多个元素 每个元素可以是任意数据类型1234567lst = [1, 'aa', 3.1, [1, 2]] # lst = list([1, 'a', 3.1, [1, 2]])res = list('hello') # 将 字符串 转换成 列表print(res, type(res))# 输出结果['h', 'e', 'l', 'l', 'o'] &lt;class 'list'&gt; list 类型转换的工作原理：list(items) 先造一个空列表 类似调用了一个 for 循环，从 items 里取出一个值放入空列表中，循环往复直到取干净为止但凡可以被 for循环 循环的，都可以被 list() 转换1234print(list(range(1, 5)))# 输出结果[0, 1, 2, 3, 4] 调用 list() 方法123456&gt;&gt;&gt; list('hello')['h', 'e', 'l', 'l', 'o']&gt;&gt;&gt; list((1, 2, 3))[1, 2, 3]&gt;&gt;&gt; list(&#123;'x': 1, 'y': 2&#125;)['x', 'y'] 常用操作+内置方法 按索引存取值（正向存取+反向存取）：即可以取值，也可以改值 123456789101112131415161718l = ['a', 'b', 'c', 'd']print(l[3]) # 正向取值# 输出结果dprint(l[-1]) # 反向取值# 输出结果dl[3] = 'D' # 修改元素值print(l)# 输出结果['a', 'b', 'c', 'D']l[4] = '5555' # 不能根据索引往列表里追加元素值print(l)# 输出结果IndexError: list assignment index out of range 123456789101112131415161718192021222324252627282930313233343536names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[4]) # 正向取值# 输出结果yxxprint(names[-1]) # 反向取值# 输出结果yxxprint(names[-2])# 输出结果xxx# 即可以取值，也可以改值names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names[0] = 'EGON'print(names)# 输出结果['EGON', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(id(names))print(names)names[0] = 'EGON'print(id(names))print(names)# 输出结果3155914092616['egon', 'alex', 'wxx', 'xxx', 'yxx']3155914092616['EGON', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names[5] = 3 # 超出索引限制会报错# 输出结果IndexError: list assignment index out of range 切片（顾头不顾尾，步长） 从一个大列表中切出一个字列表[起始位置:结束位置:步长] 123456l = ['a', 'b', 'c', 'd']l1 = l[1:3]print(l1)# 输出结果['b', 'c'] 1234567891011121314151617181920212223names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[起始位置:结束位置:步长])print(names[0:3]) # 正向取# 输出结果['egon', 'alex', 'wxx']print(names[0:3:2]) # 正向步长# 输出结果['egon', 'wxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[::1])# []内 起始没写，默认从索引0开始# 结束没写，默认到最后结束# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[:]) # [] 冒号左边没有值，默认索引是0，冒号右边没有写值，默认到最后结束 # 如果要获取列表内所有的值，可以省略掉 冒号 左右两边的值# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx'] 反向取值，反向步长（顾头不顾尾）1234567891011121314print(names[起始位置:结束位置:反向步长])names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[3:0:-1]) # 遵循切片顾头不顾尾的规则，agon 获取不到# 输出结果['xxx', 'wxx', 'alex']print(names[3::-1]) # 在结束位置不写值，就能获取到最后一个元素值# 输出结果['xxx', 'wxx', 'alex', 'egon']print(names[-1::-1])# 输出结果['yxx', 'xxx', 'wxx', 'alex', 'egon'] 长度 len()12345l = ['a', 'b', 'c', 'd']print(len(l)# 输出结果4 12345names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(len(names))# 输出结果5 成员运算 in 和 not in123456789101112names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]print('alex' in names)# 输出结果Trueprint(4 in names)# 输出结果Trueprint(5 not in names)# 输出结果True 追加 append()123456l = ['a', 'b', 'c', 'd']l.append('aaa')print(l)# 输出结果['a', 'b', 'c', 'd', 'aaa'] 12345678910111213names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.append('oldboy')print(names)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx', 'oldboy']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.append('oldboy1')names.append('oldboy2')names.append('oldboy3')print(names)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx', 'oldboy1', 'oldboy2', 'oldboy3'] 插入 insert()1234567891011121314151617l = ['a', 'b', 'c', 'd']l.insert(1, 'B')print(l)# 输出结果['a', 'B', 'b', 'c', 'd']l.insert(0, 'B')print(l)# 输出结果['B', 'a', 'b', 'c', 'd']l.insert(0, 'B')l.insert(0, 'egon')print(l)# 输出结果['egon', 'B', 'a', 'b', 'c', 'd'] 12345678910names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.insert(0, oldboy) # 两个参数：索引下标，插入的值print(names)# 输出结果['oldboy', 'egon', 'alex', 'wxx', 'xxx', 'yxx']names.insert(2, 'oldboy')print(names)# 输出结果['egon', 'alex', 'oldboy', 'wxx', 'xxx', 'yxx'] 删除 del, remove(), pop()del 删除1234567891011l = ['a', 'b', 'alex', 'd']del l[2]print(l)# 输出结果['a', 'b', 'd']res = del l[2]print(res)# 输出结果SyntaxError: invalid syntax 123456names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']del names[2] # 删除列表中某一个元素print(names)# 输出结果['egon', 'alex', 'xxx', 'yxx'] 非列表独有的删除，是一种通用的删除方法 remove() 删除 只是单纯的删除操作，没有返回值 1234567891011l = ['a', 'b', 'alex', 'd']l.remove('alex')print(l)# 输出结果['a', 'b', 'd']res = l.remove('alex') # 只是单纯的删除操作，没有返回值print(res)# 输出结果None 12345678910111213141516names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.remove(0) # 单纯的删除，没有返回值print(names)# 输出结果ValueError: list.remove(x): x not in listnames = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.remove('wxx') # remove() 是指定元素值删除print(names)# 输出结果['egon', 'alex', 'xxx', 'yxx']res = names.remove('wxx') # remove() 没有返回值print(res)# 输出结果None pop() 从列表中取走一个元素值 删除一个元素 将该元素当做返回值返回默认从最后一个删除 12345678910111213l = ['a', 'b', 'alex', 'd']res = l.pop() # 默认从最后一个删除print(l)print(res)# 输出结果['a', 'b', 'alex']dl = ['a', 'b', 'alex', 'd']res = l.pop(2)print(res)# 输出结果alex 1234567891011121314151617181920212223names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.pop(0) # pop() 是按照索引下标删除元素值print(names)# 输出结果['alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']res = names.pop(0)print(names)print(res) # pop() 会获取返回删除的元素值# 输出结果['alex', 'wxx', 'xxx', 'yxx']egonres = names.pop(100) # 超过索引限制会报错# 输出结果IndexError: pop index out of rangenames = ['egon', 'alex', 'wxx', 'xxx', 'yxx']if 100 &lt; len(names): # 可以加一个判断 来让它不报错 res = names.pop(100) print(names) print(res) 循环（循环取值）12345678l = ['a', 'b', 'c']for item in l: print(item)# 输出结果abc 1234567891011121314names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]for item in names: print(item)# 输出结果egonalexwxxxxxyxx1234 列表可变类型可变类型：值变，id不变，可变 == 不可hash 12345678l1 = ['a', 'b', 'c']print(id(l1))l1[0] = 'A'print(id(l1))# 输出结果14608203903441460820390344 reverse() 反转（单纯的反转）123456l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.reverse()print(l1)# 输出结果['a', 'b', 'a', 'a', 2.3, 1] 123456names = ['alex', 'wxx', 'lxx']names.reverse()print(names)# 输出结果['lxx', 'wxx', 'alex'] 123456names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]names.reverse() # reverse() 反转，改的是原值print(names)# 输出结果[4, 3, 2, 1, 'yxx', 'xxx', 'wxx', 'alex', 'egon'] count() 统计列表元素值的个数12345l1 = [1, 2.3, 'a', 'b', 'a']print(l1.count('a'))# 输出结果3 12345names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]print(names.count('xxx')) # count()方法 统计列表元素值的个数# 输出结果2 clear() 清空列表所有元素值123456l1 = [1, 2.3, 'a']l1.clear()print(l1)# 输出结果[] 123456names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]names.clear() # clear() 清空列表所有元素值print(names)# 输出结果[] copy() 列表复制123456l1 = [1, 2.3, 'a']l2 = l1.copy()print(l2)# 输出结果[1, 2.3, 'a'] 12345678names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]print(names)lst = names.copy() # copy() 复制一份列表元素值print(lst)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4] extend() 向列表末尾追加多个元素值123456789101112131415l1 = [1, 2.3, 'a', 'a', 'b', 'a']l2 = [4, 5, 6]l1.append(l2[0])l1.append(l2[1])l1.append(l2[2])# 输出结果[1, 2.3, 'a', 'a', 'b', 'a', 4, 5, 6]# 一个一个追加，比较麻烦l1 = [1, 2.3, 'a', 'a', 'b', 'a']l2 = [4, 5, 6]l1.extend(l2)print(l1)# 输出结果[1, 2.3, 'a', 'a', 'b', 'a', 4, 5, 6] index()获取列表元素值的索引下标1234567891011121314l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.index('egon')# 输出结果ValueError: 'egon' is not in listl1 = [1, 2.3, 'a', 'a', 'b', 'a']print(l1.index('a'))# 输出结果2l1 = [1, 2.3, 'a', 'a', 'b', 'a']print(l1.index('a', 0, 3)) # 指定 起始位置,结束位置（顾头不顾尾）# 输出结果2 12345678910names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]# names.index(元素值, 起始位置，结束位置)print(names.index('alex'))# 输出结果1# 没有的元素值，会报错print(names.index('alexabcd'))# 输出结果ValueError: 'alexabcd' is not in list sort 排序 默认从小到大排序 123456names = [1, 10, 3, -1]names.sort() # 默认从小到大排序print(names)# 输出结果[-1, 1, 3, 10] 1234567891011nums = [9, 3, 4, -1, 5, 100, 98]nums.sort(reverse=True) # 从大到小排序print(nums)# 输出结果[-1, 3, 4, 5, 9, 98, 100]nums = [9, 3, 4, -1, 5, 100, 98]nums.sort(reverse=True) # 从大到小排序print(nums)# 输出结果[100, 98, 9, 5, 4, 3, -1] 123456l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.sort()# 输出结果TypeError: '&lt;' not supported between instances of 'str' and 'float'# 字符串 和 浮点类型 之间不支持排序 1234567names = [1, 10, 3, -1, 'a']names.sort()print(names)# 输出结果TypeError: '&lt;' not supported between instances of 'str' and 'int'# 字符串 和 整型 之间不支持排序 列表中的元素值，必须是 同一 类型，才能做比较排序 1234567891011121314151617181920212223names = ['b', 'a', 'c']names.sort()print(names)# 输出结果['a', 'b', 'c']names = ['b', 'a', '+']names.sort()print(names)# 输出结果['+', 'a', 'b']s1 = 'hello's2 = 'z'print(s1 &gt; s2)# 输出结果Falsex = 'hello'y = 'hez'print(y &gt; x)# 输出结果True 字符串 是 根据位置 比较的，先比较两个字符串的第一个位置的字符如果 第一个字符比出大小，后面的字符将不再做比较字符串之间根据 ASCII码 来做比较小写字母 比 大写字母 大 列表比较大小123456789101112131415161718lst1 = [1, 2, 'a', 'b']lst2 = [3, 4]print(lst2 &gt; lst1)# 输出结果Truelst1 = [1, 2, 'a', 'b']lst2 = [1, 2, 3]print(lst2 &gt; lst1)# 输出结果TypeError: '&gt;' not supported between instances of 'int' and 'str'# 第三个位置不是同一种类型，所以报错lst1 = [1, 2, 'a', 'b']lst2 = [1, 2, 'b']print(lst2 &gt; lst1)# 输出结果True 队列：先进先出1234567891011121314151617l = []# 入队l.append('first')l.append('second')l.append('third')print(l)# 输出结果['first', 'second', 'third']# 出队print(l.pop(0))print(l.pop(0))print(l.pop(0))# 输出结果firstsecondthird 堆栈：先进后出1234567891011121314151617l = []# 入栈l.append('first')l.append('second')l.append('third')print(l)# 输出结果['first', 'second', 'third']# 出栈print(l.pop(-1)) # 默认是 -1，不写就是 -1print(l.pop(-1))print(l.pop(-1))# 输出结果thirdsecondfirst 总结 能存多个值，没有类型限制 有序（能够按索引取值的属于有序的） 可变类型 可变：值变，id不变，可变 == 不可hash list（任何能被 for循环的对象）转换成 列表]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python列表类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python集合类型]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F10%2FPython%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[set 集合类型 用途 主要用于关系运算去重 定义方式 在 {} 内用逗号分隔开多个元素每一个元素必须为不可变类型(int，float，str，tuple)集合内的元素不能重复集合内元素无序 12pythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']linuxers = ['wxx', '吴三江', '张大炮', '王全蛋'] 获取即报名Linux，又报名Python 课程 的 学生姓名 12345678pl = []for name in pythoners: if name in linuxers: pl.append(name)print(pl)# 输出结果['wxx', '吴三江'] 123456789s = &#123;&#125; # 定义空字典print(s, type(s))# 输出结果&#123;&#125; &lt;class 'dict'&gt;s = set() # 定义空集合print(s, type(s))# 输出结果set() &lt;class 'set'&gt; 123456789s = &#123;1, 2&#125; # s = set(&#123;1, 2&#125;)print(type(s))# 输出结果&lt;class 'set'&gt;s = &#123;1, 'a', 3&#125; # s = set(&#123;1, 'a', 3&#125;)print(s, type(s))# 输出结果&#123;1, 3, 'a'&#125; &lt;class 'set'&gt; 12345s = &#123;1, 'a', 3.1, [1,2]&#125;# 输出结果TypeError: unhashable type: 'list'# 列表类型 是 不可hash类型，不能用于 集合 可变类型 不可 hash不可变类型 可 hash集合无法一个值一个值取值 集合类型 元素不能重复12345s = &#123;1,2,2,2,2,22,2,2,2,2&#125;print(s)# 输出结果&#123;1, 2, 22&#125; 集合去重有局限性 不能保证原来的顺序不能针对可变类型去重 1234s = set('hello')print(s)# 输出结果&#123;'o', 'h', 'l', 'e'&#125; 12345678910111213141516171819202122l = [1, 1, 1, 1, 'egon', 'alex', 'egon']s = set(l) # 将 l 列表 转换成 集合print(s)# 输出结果&#123;1, 'egon', 'alex'&#125;s = &#123;'egon', 'alex', 'wxx', 'lxx'&#125;for item in s: # 遍历 集合 print(item)# 输出结果egonlxxwxxalexl = [1, 1, 1, 1, 'egon', 'alex', 'egon']s = set(l) # 将 列表 转换成 集合# print(s)l = list(s) # 再将 集合 转换成 列表print(l)# 输出结果[1, 'egon', 'alex'] 需求：即想针对可变类型去重，又想保证原来的顺序 列表内的元素有可变类型 去重之后要保证原来顺序 1234567891011121314151617181920info = [ &#123;'name':'egon', 'age':18&#125;, &#123;'name':'alex', 'age':73&#125;, &#123;'name':'egon', 'age':18&#125;, &#123;'name':'lxx', 'age':19&#125;, &#123;'name':'egon', 'age':18&#125;, &#123;'name':'lxx', 'age':19&#125;,]l = []for dic in info: if dic not in l: l.append(dic)# print(l)info = lprint(info)# 输出结果[&#123;'name':'egon', 'age':18&#125;, &#123;'name':'alex', 'age':73&#125;, &#123;'name':'lxx', 'age':19&#125;] 12345678910s = &#123;'a', 'asdfsa', (1, 2), 1, 3.1&#125;for item in s: print(item)# 输出结果(1, 2)13.1asdfsaa 长度len()12345678print(len(&#123;1, 2, 3&#125;))# 输出结果3pythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']print(len(pythoners))# 输出结果5 成员运算 in 和 not in12345678print(1 in &#123;1, 2, 3&#125;)# 输出结果Truepythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']print('egon' in pythoners)# 输出结果True 集合的关系运算交集 &amp; ，intersection() 内置方法 获取两个集合的共同部分 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners &amp; linuxers)# 输出结果['wxx', '吴三江'] 123print(pythoners.intersection(linuxers))# 输出结果['wxx', '吴三江'] 差集 -，difference() 内置方法 获取只报名Python，没有报名Linux 的人即集合pythoners 减去 linuxers ，称之为 差集 12345pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners - linuxers)# 输出结果&#123;'艾利克斯', 'oldboy', 'egon'&#125; 123print(pythoners.difference(linuxers))# 输出结果&#123;'艾利克斯', 'oldboy', 'egon'&#125; 获取只报名 linux，没有报名 python 的人 12345pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(linuxers - pythoners)# 输出结果&#123;'王全蛋', '张大炮'&#125; 123print(linuxers.difference(pythoners))# 输出结果&#123;'王全蛋', '张大炮'&#125; 合集，并集 |，union() 内置方法 获取两个集合的总和，把两个集合合到一起，把重复的部分去除获取所有的学生的姓名 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners | linuxers)# 输出结果&#123;'吴三江', 'oldboy', '王全蛋', 'egon', 'wxx', '张大炮', '艾利克斯'&#125; 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners.union(linuxers))# 输出结果&#123;'吴三江', 'oldboy', '王全蛋', 'egon', 'wxx', '张大炮', '艾利克斯'&#125; 对称差集 ^，symmetric_difference()` 内置方法 获取没有同时报名两门课程的学生姓名 123456789pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners ^ linuxers)# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125;print(linuxers ^ pythoners)# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125; 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners.symmetric_difference(linuxers))# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125; == 比较两个值是否相等1234567891011s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2, 3&#125;print(s1 == s2)# 输出结果Trues1 = &#123;1, 2, 3&#125;s2 = &#123;3, 2, 1&#125;print(s1 == s2)# 输出结果True 集合之间做比较，指的是包含 与 被包含的关系 父集 &gt; &gt;=，issuperset() 内置方法12345678910s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1 &gt; s2)print(s1 &gt;= s2)# 判断 s1 是否是 s2 的父集# 判断 s1 是否包含 s2# 输出结果TrueTrue 123456s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2, 4&#125;print(s1 &gt;= s2) # 判断 s1 是否是 s2 的父集# 输出结果False 123456s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1.issuperset(s2)) # 判断 s1 是否是 s2 的父集# 输出结果True 子集 &lt; &lt;=，issubset()内置方法1234567s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s2 &lt;= s1) # 判断 s2 是否是 s1 的子集 # 判断 s2 是否被 s1 包含# 输出结果True 1234567s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s2.issubset(s1)) # 判断 s2 是否是 s1 的子集 # 判断 s2 是否被 s1 包含# 输出结果True 添加集合元素 集合属于可变类型，值变，id不变，不可 hash 123456789s1 = &#123;1, 2, 3, 4, 5&#125;print(id(s1))s1.add(6)print(id(s1))# 输出结果3014527602472&#123;1, 2, 3, 4, 5, 6&#125;3014527602472 12345678910s1 = &#123;'a', 'b', 'c'&#125;print(id(s1))s1.add('d')print(s1)print(id(s1))# 输出结果1981688305928&#123;'b', 'd', 'a', 'c'&#125;1981688305928 删除集合元素remove() 按元素名删除元素12345678910111213141516s1 = &#123;'a', 'b', 'c'&#125;s1.remove('b')print(s1)# 输出结果&#123;'a', 'c'&#125;# 查看是否有返回值s1 = &#123;'a', 'b', 'c'&#125;res = s1.remove('b') # 只是单纯的删除，没有返回值print(res)# 输出结果Nones1.remove('dddd') # 指定元素删除，如果元素不存在，则报错# 输出结果KeyError: 'dddd' discard() 按元素名删除元素1234567891011s1 = &#123;1, 2, 3, 4, 5&#125;s1.discard(3)print(s1)# 输出结果&#123;1, 2, 4, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s1.discard(333333) # 指定元素删除，如果元素不存在，不会报错print(s1)# 输出结果&#123;1, 2, 3, 4, 5&#125; 123456789101112131415161718s1 = &#123;'a', 'b', 'c'&#125;s1.discard('b')print(s1)# 输出结果&#123;'a', 'c'&#125;# 查看是否有返回值s1 = &#123;'a', 'b', 'c'&#125;res = s1.discard('b') # 没有返回值print(res)# 输出结果Nones1 = &#123;'a', 'b', 'c'&#125;s1.discard('dddd') # 指定元素删除，如果元素不存在，不会报错print(s1)# 输出结果&#123;'a', 'b', 'c'&#125; pop() 随即删除，有返回值，将删除的元素值返回出来123456s1 = &#123;'a', 'b', 'c'&#125;res = s1.pop() # 随即删除，有返回值，将删除的元素值返回出来print(res)# 输出结果c 更新集合元素update() 更新集合中的元素值，并且去除重复值12345678910s1 = &#123;1, 2, 3, 4, 5&#125;s1.update(&#123;3, 4, 5, 6, 7&#125;)print(s1)# 输出结果&#123;1, 2, 3, 4, 5, 6, 7&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s1.update('hello') # 先将字符串 hello 转成集合，再更新到 s1 里去# 输出结果&#123;1, 2, 3, 4, 5, 'l', 'e', 'h', 'o'&#125; 清空集合元素12s1 = &#123;1, 2, 3, 4, 5&#125;s1.clear 查看两个集合是否有交集（共同部分）isdisjoint() 判断两个集合没有交集（共同部分），返回 True1234# 查看注释，Ctrl + 点击左键def isdisjoint(self, *args, **kwargs): # real signature unknown """ Return True if two sets have a null intersection. """ pass 1234567891011s1 = &#123;1, 2, 3&#125;s2 = &#123;4, 5, 6&#125;print(s1.isdisjoint(s2))# 输出结果Trues1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1.isdisjoint(s2))# 输出结果False 把找出来的差集，重新覆盖原集合12345678910111213141516171819202122232425262728s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;res = s1.difference(s2) # s1 - s2print(res)# 输出结果&#123;1, 2, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1.difference(s2) # s1 - s2print(s1)# 输出结果&#123;1, 2, 3, 4, 5&#125;# 原 s1 的值其实并没有改变s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1 = s1.difference(s2) # s1 = s1 - s2，将改变后的值重新赋值给 s1 将其改变print(s1)# 输出结果&#123;1, 2, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1.difference_update(s2) # s1=s1.difference # s1=s1-s2，将改变后的值重新赋值给 s1 将其改变print(s1)# 输出结果&#123;1, 2, 5&#125; 1234567891011121314s1 = &#123;'a', 'b', 'c'&#125;s2 = &#123;'b', 'd', 'f'&#125;print(s1.difference(s2))print(s1)# 输出结果&#123;'a', 'c'&#125; # 这是一个新的元素值&#123;'a', 'c', 'b'&#125; # 原 s1 的内容没有改变s1 = &#123;'a', 'b', 'c'&#125;s2 = &#123;'b', 'd', 'f'&#125;s1.difference_update(s2) # 等于 s1 = s1.difference(s2)print(s1)# 输出结果&#123;'a', 'c'&#125; # 将差集的结果直接赋值给s1 将对称差集的结果，重新覆盖原集合1s1.symmetric_difference_update() 将交集的结果，重新覆盖原集合1s1.intersection_update() 用集合去重，不保证顺序1234567l = ['a', 'b', 1, 'a', 'a']print(list(set(l)))names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']print(set(names))# 输出结果&#123;'wxx', 'alex', 'egon'&#125; 将 集合 转回 原来 的类型，不保证顺序12345names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']print(list(set(names)))# 输出结果['egon', 'wxx', 'alex'] 用集合去重，局限性很强不能保证元数据类型的顺序元数据类型中包含的元素必须全都为不可变类型 即想去重，又想保证顺序 遍历集合123s = &#123;'egon', 'alex', 'wxx', 'lxx'&#125;for item in s: print(item) 123456789names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']new_names = []for name in names: if name not in new_names: new_names.append(name)print(new_names)# 输出结果['alex', 'egon', 'wxx'] 使用 keys() 方法1names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx'] list() 方法是把 str字符串 或 tuple元组 转成 list列表12345new_names = list(&#123;&#125;.fromkeys(names).keys())print(new_names)# 输出结果['alex', 'egon', 'wxx'] 列表类型，字典类型，集合类型方式 去除重复的部分，保证原来的顺序12345678910111213141516171819202122232425262728l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = set() # 创建一个空集合new_l = []for d in l: # n, a, s = d['name'], d['age'], d['sex'] # 获取到 字典的值 # print(n, a, s) # s.add((n, a, s)) values = (d['name'], d['age'], d['sex']) print(values) if values not in s: s.add(values) new_l.append(d)print(new_l)# 输出结果('egon', 18, 'male')('alex', 73, 'male')('egon', 20, 'female')('egon', 18, 'male')('egon', 18, 'male')[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 列表类型，字典类型 方式 去除重复的部分，保证原来的顺序123456789101112131415161718l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = []new_l = []for d in l: if d not in s: s.append(d) new_l.append(d)print(new_l)# 输出结果[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 列表类型，字典类型 方式 去除重复的部分，保证原来的顺序12345678910111213141516l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = []for d in l: if d not in s: s.append(d)print(s)# 输出结果[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 去重，保证原来的顺序1234567l = ['a', 'b', 1, 'a', 'a']l_new = []s = set()for item in l: if item not in s: s.add(item) l_new.append(item) 集合总结定义1s = &#123;1, 2, 3&#125; 注意 集合能存多个值集合无序集合内元素不能重复集合内的元素必须为不可变类型，但set集合是可变的 用途 集合是用来进行关系运算，单独取集合的某一个元素是没有意义的，也没有相应的方法1234交集：s1 &amp; s2 取两个集合的共同部分差集：s1 - s2 结果存于 s1 而不存于 s2 的元素集合补集：s1 ^ s2 扣掉 s1 与 s2 共同部分，剩下的部分合到一起并集：s1 | s2 把两个合到一起，去掉重复]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python集合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串类型]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F05%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[str 字符串类型str 基本使用用途 用于 描述型的数据，姓名，性别，地址，国籍 等 定义方式 在单引号，双引号，三引号内包含一串的字符 1234567891011121314151617msg="hello world" # msg=str("hello world") res1=str(1)res2=str(1.2)res3=str([1,2,3])print(type(res1),type(res2),type(res3))info = 'my name is agon'name = 'egon' # name = str('egon')print(name)print(type(name))print(id(name))# 输出结果egon&lt;class 'str'&gt;3172826579048 常用操作+内置的方法12345678910111213141516171819# 按索引取值（正向取+反向取），只能取msg = 'he lo'print(msg[0])print(msg[3])# 输出结果hlmsg = 'he lo'msg[2] = 'A'TypeError: 'str' object does not support item assignment# 字符串不支持更改内容msg = 'hello'print(msg[0:]) # 正向取值print(msg[::-1]) # 反向取值# 输出结果helloolleh 切片（顾头不顾尾，步长）123456789101112131415161718192021msg = 'hello world'print(msg[0:4]) # 从索引 0 开始 到 4 结束# 输出结果hell # 遵循 顾头不顾尾 的规则，输出到 o 前面的字符 l 结束print(msg[0:4:2]) # 步长，隔2步，取一个字符# 输出结果hl# 从一个大字符串中切除一个子字符串（骨头不顾尾，步长）msg = 'hello world'print(msg[1:3])print(msg[6:11])print(msg[6:11:2])# 倒着取值，注意方向要一致msg = 'hello world'print(msg[6:])print(msg[-1:-6:-1])print(msg[-1::-1])print(msg[::-1]) 123456789inp = 'get a.txt'cmd = inp[0:3]filepath = inp[4:]print(cmd)print(filepath)# 输出结果 获取 命令 和 文件名geta.txt 123456inp = 'get a.txt'# inp.split() # 不指定 分割符 默认以空格为分割符res = inp.split(' ')print(res)# 输出结果['get', 'a.txt'] 12345678910111213s = "1234567890"s = "abcdefghij"print(s[-1:]) # 截取最后一个元素print(s[0:3]) # 截取第一位到第三位的字符print(s[:]) # 截取字符串的全部字符print(s[6:]) # 截取第七个字符到结尾print(s[:-3]) # 截取从头开始到倒数第三个字符之前print(s[2]) # 截取第三个字符print(s[::-1]) # 创建一个与原字符串顺序相反的字符串print(s[-3:-1]) # 截取 倒数第三位 和 倒数第一位 之前的字符print(s[-3:]) # 截取 倒数第三位 到结尾print(s[:-12:-2]) # 逆序截取后个数，每 3 个取一个，而且取是逆向取值print(s[:10:2]) # 前 10 个数，每两个取一个 长度len12345msg = 'hello world'print(len(msg)) # 长度是11，索引最大到10# 输出结果5 成员运算 in 和 not in12345678910111213141516171819202122232425msg = 'hello world alex is SB'print('alex' in msg) # 判断 子字符串 'alex' 是否在 msg 变量字符串里print('SB' in msg)print('egon' not in msg)print(not 'egon' in msg)# 输出结果Truemsg = 'alex say my name is alex'if 'alex' in msg: print('存在')# 输出结果存在msg = 'alex say my name is alex'print('alex' in msg)print('alex' not in msg) # 推荐使用这种形式print(not 'alex' in msg)# 输出结果TrueFalseFalse strip 移除字符串左右两边的字符 strip 只能 移除 字符串 左右两边的 字符1234567name = '***egon*****'print(name.strip('*'))print(name)# 输出结果egon # strip 是生成了一个新的值，并不是改变原值***egon***** 12345678name = ' egon '# strip() 不写指定符号，默认去除字符串左右两边的空格name = name.strip()# 将 strip() 生成的新值，重新赋值给 变量name，可以看作是 字符串的变更print(name)# 输出结果egon 12345msg = '* / , alex is sb -*=*******'print(msg.strip('*, /-='))# 输出结果alex is sb 123name = input('&gt;&gt;&gt;: ')name = input('&gt;&gt;&gt;: ').strip()print(name) 1234567while True: # cmd = input('cmd&gt;&gt;: ') # cmd = cmd.strip() # 主要用于用户输入时，去除左右两边的空格字符 cmd = input('cmd&gt;&gt;: ').strip() if len(cmd) == 0:continue if cmd == 'q':break print('%s is running' % cmd) 切分（分割）split1234567891011info = 'root:x:0:0:root:/root:/bin/bash'print(info)res = info.split(':') # 不指定分割符，默认从头切到尾# res = info.split(':', maxsplit=-1)print(res, type(res))print(res[0]) # 经过 split 分割后，获取下标为 0 的元素# 输出结果root:x:0:0:root:/root:/bin/bash['root', 'x', '0', '0', 'root', '/root', '/bin/bash']root 123456789101112cmd = 'get a.txt'res = cmd.split() # split() 不写参数，默认以空格分割print(res[0])print(res[1])# 输出结果 获取 命令 和 文件名geta.txtcmd = 'get a.txt 33333'res = cmd.split(' ', maxsplit=1)print(res) 循环（循环取值） while 循环取值12345678msg = 'hello world'n = 0while True: print(msg[n]) n += 1# 输出信息IndexError: string index out of range 123456789101112131415161718msg = 'hello world'n = 0 # 指定一个计数器while n &lt; len(msg): print(msg[n]) n += 1 # 自加计数器# 输出结果helloworld for循环迭代取值12345678910111213141516msg = 'hello world'for item in msg: print(item)# 输出结果helloworld strip, lstrip, rstrip123456789name='*****hello*****'print(name.strip('*')) # 去除左右两边的字符print(name.lstrip('*')) # 去除左边的字符print(name.rstrip('*')) # 去除右边的字符# 输出结果hellohello**********hello lower, upper12345678910name='hello'print(name.lower()) # 转换小写字母print(name) # lower 方法不改变原值print(name.upper()) # 转换大写字母print(name) # upper 方法不改变原值# 输出结果helloHELLOHello startswith, endswith1234567name='Hello is run'print(name.startswith('Hello')) # 以 Hello 开头print(name.endswith('run')) # 以 run 结尾# 输出结果TrueTrue format 字符串格式化输出 的 三种方法 %s 的方式传值需要记住传值位置1print('name is %s age is %s' % ('egon', 18)) 缺点严格依赖 %s 的位置 123456789101112131415161718192021# format() 里的参数可以不用对应（推荐使用这种方式）print('name is &#123;name&#125; age is &#123;age&#125;'.format(age=18, name='egon'))# 输出方式name is egon age is 18# 此方法类似 %s 的格式化输出print('name is &#123;&#125; age is &#123;&#125;'.format('egon', 18))# 输出结果name is egon age is 18print('name is &#123;0&#125;&#123;0&#125;&#123;0&#125; age is &#123;1&#125;'.format(18, 'egon'))# 输出结果name is 181818 age is egonprint('&#123;1&#125; &#123;0&#125; &#123;1&#125;'.format('egon', 18, 'male'))# 输出结果18 egon 18print('&#123;0&#125; &#123;1&#125; &#123;2&#125;'.format('egon', 18, 'male'))# 输出结果egon 18 male split, rsplit split 可以把 字符串 切割成 列表 1234cmd = 'get|a.txt|3333'print(cmd.split('|', 1))print(cmd.rsplit('|', 1)) 123456789info = 'root:x:0:0:root:/root:/bin/bash'print(info.split(':')) # 这里的分割符指定为(:)冒号，默认分隔符为空格print(info.split(':', -1)) # 默认值为 -1，-1 表示从头切到尾info = 'root:x:0:0:root:/root:/bin/bash' # 获取第一个 rootprint(info.split(':', 1)) # 1 表示切一次，从左往右切割一次# 输出结果['root', 'x:0:0:root:/root:/bin/bash'] 12345info = 'root:x:0:0:root:/root:/bin/bash'print(info.rsplit(':', 1)) # 从右开始切割一次# 输出结果['root:x:0:0:root:/root', '/bin/bash'] join 拼接 join 把 列表 转成 字符串，前提是列表中的所有数据为字符串123456info = 'root:x:0:0:root:/root:/bin/bash'str_to_list = info.split(':')print(str_to_list)# 输出结果['root', 'x', '0', '0', 'root', '/root', '/bin/bash'] 12345678lst = ['root', 'x', '0', '0', 'root', '/root', '/bin/bash']list_to_str = ':'.join(lst)print(list_to_str)print(type(list_to_str))# 输出结果root:x:0:0:root:/root:/bin/bash&lt;class 'str'&gt; iterable 参数 可被 for 循环的 全都是 iterable1234567for i in lst: print(i)# 注意：join 只能连接 所包含的元素 全都为 字符串类型 的列表lst = [1, 2, 3]':'.join(lst)TypeError: sequence item 0: expected str instance, int found replace 替换字符串 replace 不会改变原值123456789msg = 'my name is alex, alex say hello'print(msg.replace('alex', 'egon')) # 不指定，表示全部替换print(msg.replace('alex', 'egon', 1)) # 1 表示 替换第一个print(msg.replace('alex', 'egon', -1)) # -1 表示全部替换# 输出结果my name is egon, egon say hellomy name is egon, alex say hellomy name is egon, egon say hello isdigit 判断 字符串 是否是 纯数字1234567print('10101'.isdigit())# 输出结果Trueprint('abc123'.isdigit())# 输出结果False 判断 bytes 和 unicode 类型，是最常用的用于于判断 字符 是否为 “数字” 的方法 猜年龄演示错误结果 1234567891011121314151617age='abcdefg'int(age)# 不是整型的报错信息ValueError: invalid literal for int() with base 10: 'abcdefg'age = 50while True: age = input('&gt;&gt;: ').strip() if not age.isdigit():continue age = int(age) if age &gt; 50: print('too big') elif age &lt; 50: print('too small') else: print('you got it') break find, rfind, index, rindex, coun1234567891011121314151617181920212223msg = 'my name is egon, egon is nb'print(msg.find('egon')) # 查找 子字符串 在 大字符串中的起始位置 # 找的是 'egon' 在大字符串 msg 中的起始索引# 输出结果11print(msg.find('egon', 1, 5) # 从 1 开始 到 5 结束 # 顾头不顾尾，找不到则返回 -1 不会报错，找到了则显示索引# 输出结果-1print(msg.index('egon', 1, 3)) # 同上，但是找不到会报错# 报错信息ValueError: substring not foundprint(msg.index('egon')) # 不写位置参数，和 find() 效果一样# 输出结果6print(msg.rfind('egon'))print(msg.rindex('egon'))print(msg.count('egon')) # 统计 子字符串 有多少个print(msg.count('egon', 1, 3)) # 顾头不顾尾，如果不指定范围则查找所有 center, ljust, rjust, zfill123456789101112131415print('info'.center(30,'#')) # 居中显示，两个参数，宽度，填充字符# 输出结果#############info##############print('info'.ljust(30,'*')) # 左对齐，两个参数，宽度，填充字符# 输出结果info**************************print('info'.rjust(30,'=')) # 右对齐，两个参数，宽度，填充字符# 输出结果==========================infoprint('info'.zfill(30)) # 用 0 填充 和 rjust 效果一样# 输出结果00000000000000000000000000info expandtabs 控制 tab键 的 空格个数123456789101112131415161718192021print('aaabbbb', end='')print('cccc', end='')# 输出结果aaabbbbccccprint(aaaa\nbbbb)# 输出结果aaaabbbbprint(r'a\tb') # \t 表示制表符 tab，如想取消掉这个制表符效果，在字符串前加 r # r开头的字符串内都是原始字符串，右斜杠没有特殊意义print('a\tb') # r 表示原始字符串(raw string)# 输出结果a\tba bprint('aaa\tbbb'.expandtabs(3)) # expandtabs 控制空格数print('aaa\tbbb'.expandtabs(tabsize=3))# 输出结果aaa bbb captalize, swapcase, title1234567891011print('abc'.capitalize()) # 首字母大写# 输出结果Abcprint('Ab'.swapcase()) # 大小写翻转# 输出结果aBprint('my name is egon'.title()) # 每个单词的首字母大写# 输出结果My Name Is Egon is数字系列 在 Python3 中12345678910111213141516171819202122num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isdigt 判断字符串是否是 bytes，unicodeprint(num1.isdigit()) # 常用（推荐）# 输出结果Trueprint(num2.isdigit())# 输出结果Trueprint(num3.isdigit()) # 不能判断中文数字# 输出结果Falseprint(num4.isdigit()) # 不能判断罗马数字# 输出结果False isnumeric 判断字符串是否是 unicode，中文/繁体数字，罗马数字 bytes 类型没有 isnumeric 方法123456789101112131415161718num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isnumeric: unicode, 中文，罗马print(num2.isnumeric())# 输出结果Trueprint(num3.isnumeric())# 输出结果Trueprint(num4.isnumeric())# 输出结果True isdecimal 判断字符串是否是 uncicode bytes 类型没有 isdecimal 方法123456789101112131415161718num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isdecimal:unicodeprint(num2.isdecimal())# 输出结果Trueprint(num3.isdecimal())# 输出结果Falseprint(num4.isdecimal())# 输出结果False 三者 都不能 判断 浮点数 1234num5 = '4.3'print(num5.isdigit())print(num5.isdecimal())print(num5.isnumeric()) 总结：最常用的是 isdigit，可以判断 bytes 和 unicode 类型，这也是最常见的数字应用场景如果要判断 中文数字 或 罗马数字，则需要用到 isnumeric is其他 判断字符串内是否是空格1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071print(''.isspace())# 输出结果Falseprint(' '.isspace()) # 判断字符串内是否是空格# 输出结果True# 判断字符串是否全部由字母组成print(''.isalpha())# 输出结果Falseprint('abcdefg'.isalpha()) # 判断字符串是否全部由字母组成# 输出结果Trueprint('abc123'.isalpha())# 输出结果False# 判断字符串中是否由字母或数字组成print(''.isalnum())# 输出结果Falseprint('abc123'.isalnum())# 输出结果Trueprint('abcdefg'.isalnum())# 输出结果Trueprint('123456'.isalnum())# 输出结果True# 判断字符串是否全都是小写字母print('Garfield'.islower())# 输出结果Falseprint('garfield'.islower())# 输出结果True# 判断字符串是否全都是大写字母print('Garfield'.isupper())# 输出结果Falseprint('garfield'.isupper())# 输出结果Falseprint('GARFIELD'.isupper())# 输出结果True# 判断字符串是否是标题，也就是单词首字母是否大写print('Garfield'.istitle())# 输出结果Trueprint('garfield'.istitle())# 输出结果Falseprint(''.isprintable())print(''.isidentifier()) str 字符串类型总结 只能存一个值 有序（能够按索引取值的属于有序的） 不可变类型不可变：值变，id也变。不可变==可hash12345678x = 'abc'print(id(x))x = 'bcd'print(id(x))# 输出结果16958601986241695860293792 参考文档http://www.cnblogs.com/linhaifeng/articles/7133357.html#_label3]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python字符串类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典类型]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F05%2FPython%E5%AD%97%E5%85%B8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[dict 字典类型用途 可变类型，存放多个值，key:value，key 对 value 有描述性的作用 定义方式 在 {} 内用逗号分隔 多个元素 每个元素都是 key:value 的形式key 必须是不可变类型且唯一，key 通常都是用字符串类型，需要可描述的value 可以是任意数据类型即字典的 key 可以是 int, float, tuple, str, 通常是字符串类型 12345d = &#123;3.1:1, (1,2,3):2222&#125; # d = dict(&#123;3.1:1, (1,2,3):2222&#125;)print(d[(1,2,3)])# 输出结果2222 12345d1 = dict(x=1, y=2, z=3)print(d1)# 输出结果&#123;'x': 1, 'y': 2, 'z': 3&#125; 12345d2 = dict([('name', 'egon'), ['age', 18], ('sex', 'male')])print(d2)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; 1234567891011121314151617info = &#123;'name': 'egon', 'age': 18&#125; # info = dict(&#123;'name': 'egon', 'age': 18&#125;)print(info['name']) # 根据 key 取值# 输出结果egoninfo = &#123;'name': 'egon', 'age': 18&#125;print(id(info)) # 修改前，查看 idinfo['name'] = 'EGON' # 根据 key 取值，然后修改 valueprint(id(info)) # 修改前，查看 idprint(info)# 输出结果15523023659361552302365936&#123;'name': 'EGON', 'age': 18&#125; 添加一个 key 123456d = &#123;'name': 'egon', 'age': 18&#125;d['sex'] = 'male'print(d)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; key 必须是独一无二的 12345d = &#123;'name': 'egon', 'age': 18, 'age': 19, 'age': 20&#125;print(d)# 输出结果&#123;'name': 'EGON', 'age': 20&#125; # 只认最后一个key key 必须是不可变类型123456info = &#123;'name': 'egon', [1, 2]: 18&#125;print(info[[1, 2]])# 输出结果TypeError: unhashable type: 'list'# 列表是 可变类型，不可hash，不支持key 元组是不可变类型，可 hash，支持 key12345info = &#123;'name': 'egon', (1, 2): 18&#125;print(info[(1, 2)])# 输出结果18 常用操作+内置方法 按 key 存取值：可存值，也可取值12345d = &#123;'x': 1&#125;d['x'] = 2print(d)# 输出结果&#123;'x': 2&#125; 123456789101112d = &#123;'x': 1&#125;print(id(d))print(d)d['x'] = 2print(id(d))print(d)# 输出结果2536822683256&#123;'x': 1&#125;2536822683256&#123;'x': 2&#125; 12345d = &#123;'x': 1&#125;d['y'] = 3print(d)# 输出结果&#123;'x': 1, 'y': 3&#125; 长度len123456789101112info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(len(info))# 输出结果3d = &#123;'name': 'egon', 'age': 18&#125;print(len(d))# 输出结果2 成员运算 in 和 not in 判断的是字典的 key1234567891011121314info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print('x' in info)# 输出结果Trued = &#123;'name': 'egon', 'age': 18&#125;print(18 in d)# 输出结果Falsed = &#123;'name': 'egon', 'age': 18&#125;print('name' in d)# 输出结果True 删除123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;del info['x']print(info)# 输出结果&#123;'y': 2, 'z': 3&#125; 1234567info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.popitem()) # 随机删，将删除的内容以元组格式返回print(info)# 输出结果('z', 3)&#123;'x': 1, 'y': 2&#125; 1234567891011121314151617181920212223242526d = &#123;'name': 'egon', 'age': 18&#125;d.pop('xx') # 如果指定了一个不存在的 key# 输出结果KeyError: 'xx'd.pop('sex', None) # 指定了 None 就不会报错了res = d.pop('sex', None)print(res)# 输出结果None# pop() 删除 key 对应的元素，并返回 value 值res = d.pop('name', None) # 删除存在的 key 时，可以不用写 Noneprint(res)# 输出结果egonprint(d)# 输出结果&#123;'age': 18&#125;info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('x')) # 根据 key 删除，把删除的 value 返回出来print(info)# 输出结果1&#123;'y': 2, 'z': 3&#125; 12345info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx')) # 如果没有这个 key，在没有指定 default 值的情况下，会报错# 输出结果KeyError: 'xxxxx' 123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx', '没有找到key')) # 指定default值的情况下，会输出 default 的值# 输出结果没有找到key&#123;'x': 1, 'y': 2, 'z': 3&#125; 123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx', None)) # 通常 default值 写None# 输出结果None&#123;'x': 1, 'y': 2, 'z': 3&#125; 键keys()，值values()，键值对items()1234d = &#123;'name': 'egon', 'age': 18&#125;d.keys() # 取 keyd.values() # 取 valued.items() # 取 key value Python2 中字典的格式Python 2.7.15 12345678&gt;&gt;&gt; d = &#123;'name': 'egon', 'age': 18&#125;&gt;&gt;&gt; d.keys()['age', 'name'] # 5个鸡蛋&gt;&gt;&gt; d.values()[18, 'egon']&gt;&gt;&gt; d.items()[('age', 18), ('name', 'egon')]&gt;&gt;&gt; 1234567891011121314&gt;&gt;&gt; msg_dic = &#123;... 'apple': 10,... 'tesla': 100000,... 'mac': 3000,... 'lenovo': 30000,... 'chicken': 10,... &#125;&gt;&gt;&gt; print(msg_dic.keys())['tesla', 'mac', 'lenovo', 'apple', 'chicken'] # 5个鸡蛋&gt;&gt;&gt; print(msg_dic.values())[100000, 3000, 30000, 10, 10]&gt;&gt;&gt; msg_dic.items()[('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('apple', 10), ('chicken', 10)]&gt;&gt;&gt; Python3 做了优化，节省内存Python 3.6.5 123456789101112131415161718192021222324252627d = &#123;'name': 'egon', 'age': 18&#125;for k in d.keys(): print(k)# 输出结果nameaged = &#123;'name': 'egon', 'age': 18&#125;for v in d.values(): print(v)# 输出结果egon18d = &#123;'name': 'egon', 'age': 18&#125;for item in d.items(): # k, v = ('name', 'egon') print(item)# 输出结果('name', 'egon')('age', 18)d = &#123;'name': 'egon', 'age': 18&#125;for k,v in d.items(): # k, v = ('name', 'egon') print(k,v)# 输出结果name egonage 18 python3 做出 python2 中的结果123456789d = &#123;'name': 'egon', 'age': 18&#125;print(list(d.keys()))print(list(d.values()))print(list(d.items()))# 输出结果['name', 'age']['egon', 18][('name', 'egon'), ('age', 18)] 123456789101112131415&gt;&gt;&gt; msg_dic = &#123;... 'apple': 10,... 'tesla': 100000,... 'mac': 3000,... 'lenovo': 30000,... 'chicken': 10,... &#125;&gt;&gt;&gt; msg_dic.keys()dict_keys(['apple', 'tesla', 'mac', 'lenovo', 'chicken']) # 一只有5个鸡蛋的老母鸡&gt;&gt;&gt; res = msg_dic.keys()&gt;&gt;&gt; type(res)&lt;class 'dict_keys'&gt;&gt;&gt;&gt; type(res) is listFalse&gt;&gt;&gt; 123456789101112for k in msg_dic.keys(): # 这种方式比较鸡肋，不加 .keys() 默认是循环 key print(k)等于for k in msg_dic: print(k)# 输出结果appleteslamaclenovochicken 1234567891011121314151617msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;for v in msg_dic.values(): # 只获取value print(v)# 输出结果1010000030003000010 12345678910for x in msg_dic.items(): # 获取 key 和 value print(x)# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]# 输出结果('apple', 10)('tesla', 100000)('mac', 3000)('lenovo', 30000)('chicken', 10) 12345678910# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]for x in msg_dic.items(): print(x[0], x[1])# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 12345678910# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]# k, v = ('apple', 10)for k, v in msg_dic.items(): print(k, v)# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 循环（循环取值）12345678910111213d = &#123;'name': 'egon', 'age': 18&#125;for k in d: # d 不加 .keys() 默认也是取 key print(k)# 输出结果nameaged = &#123;'name': 'egon', 'age': 18&#125;for k in d: print(k, d[k])# 输出结果name egonage 18 1234567891011121314151617msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;for k in msg_dic: print(k, msg_dic[k])# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 内置方法1234567891011121314151617181920212223242526msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;print(msg_dic['applexxxxx']) # key 不存在的情况下，会报错# 输出结果KeyError: 'applexxxxx'if 'applexxxxx' in msg_dic: # 利用 if 判断 key 是否存在 print(msg_dic['applexxxxx'])else: print(None)# 代码比较多print(msg_dic.get('applexxxxx')) # key 不存在的情况下，默认返回None# 输出结果None# 也可以自定义返回值print(msg_dic.get('applexxxxx', 'xxxxx'))# 输出结果xxxxx dict.get() 取值12345678910111213141516d = &#123;'name': 'egon', 'age': 18&#125;d['sex']# 输出结果KeyError: 'sex'# 为了避免这种问题res = d.get('sex', '没有这个key')print(res)# 输出结果没有这个keyd = &#123;'name': 'egon', 'age': 18&#125;res = d.get('name', None) # 通常写Noneprint(res)# 输出结果egon dict.popitem() 随机删除123456d = &#123;'name': 'egon', 'age': 18&#125;res = print(d.popitem()) # 随机删，将删除的内容以元组格式返回print(d, res)# 输出结果&#123;'name': 'egon'&#125; ('age': 18) dict.update() 更新1234567891011d = &#123;'name': 'egon', 'age': 18&#125;d.update(&#123;'x': 1, 'name': 'EGON'&#125;) # 老字典 d 没有的则添加，有的则以新字典为准进行修改print(d)# 输出结果&#123;'name': 'EGON', 'age': 18, 'x': 1&#125;d1 = &#123;'x': 1, 'y': 2&#125;d1.update(&#123;'x': 2, 'z': 3&#125;) # 有原值就更新，没有的就新增print(d1)# 输出结果&#123;'x': 2, 'y': 2, 'z': 3&#125; dict.setdefault() 有则不改，无则增加123456789101112131415161718d = &#123;'name': 'egon', 'age': 18&#125;res = d.setdefault('name': 'EGON'&#125;) # 当key存在时，不修改值，会返回原值print(res)# 输出结果egond = &#123;'name': 'egon', 'age': 18&#125;res = d.setdefault('sex': 'male'&#125;) # 当key不存在时，则新增一个元素，会返回一个新值print(res)# 输出结果maled = &#123;'name': 'egon', 'age': 18&#125;d.setdefault('name': 'EGON'&#125;) # 当key存在时，不修改值d.setdefault('sex': 'male'&#125;) # 当key不存在时，则新增一个元素print(d)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; 12345678910&#123;&#125;.setdefault() # 有则不改，无则增加d = &#123;'x': 1, 'y': 2&#125;d.setdefault('x', 1000) # 当key存在时 则不改变 key 对应的值，返回原值res = d.setdefault('x', 1000)print(d)print(res)# 输出结果&#123;'x': 1, 'y': 2&#125;1 123456789d = &#123;'x': 1, 'y': 2&#125;d.setdefault('z', 1000) # key不存在 则增加一个 key:value，返回新增的valueres = d.setdefault('z', 1000)print(d)print(res)# 输出结果&#123;'x': 1, 'y': 2, 'z': 1000&#125;1000 1234567891011121314151617181920212223242526272829303132333435# 统计单词个数统计 s = 'hello alex alex say hello sb sb' 中每个单词的个数结果如：&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;s = 'hello alex alex say hello sb sb'words = s.split()print(words)# 输出结果['hello', 'alex', 'alex', 'say', 'hello', 'sb', 'sb']d = &#123;&#125;for word in words: if word not in d: d[word] = 1 else: d[word] += 1# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;d = &#123;&#125;words = s.split()for word in words: # print(word, words.count(word)) d[word] = words.count(word)print(d)# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;d = &#123;&#125;words = s.split()for word in words: d.setdefault(word, words.count(word))print(d)# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125; dict.fromkeys 用于字典的初始化，快速造出字典123456789101112131415161718192021222324252627282930&#123;&#125;.fromkeys(序列类型, 值)序列类型：有索引的类型（字符串，列表，元组）# 用于字典的初始化# items = ['name', 'age', 'sex']items = ('name', 'age', 'sex')dic = d.fromkeys(items, None)print(dic)# 输出结果&#123;'name': None, 'age': None, 'sex': None&#125;d = &#123;&#125;.fromkeys(['name', 'age', 'sex'], '初始值')print(d)# 输出结果&#123;'name': '初始值', 'age': '初始值', 'sex': '初始值'&#125;info = &#123;&#125;.fromkeys('hello', None)print(info)# 输出结果&#123;'h': None, 'e': None, 'l', None, 'o', None&#125;# 字典key 不能重复，所以这里只有一个 l# 实现 不用 formkeys，从以下元组中取出没一个元素，造一个字典items = ('name', 'age', 'sex')dic = &#123;&#125;for item in items: dic[item] = Noneprint(dic)# 输出结果&#123;'name': None, 'age': None, 'sex': None&#125; dict 字典类型总结 能存多个值，没有类型限制 无序（能够按索引取值的属于有序） 可变类型可变：值变，id不变。可变==不可hash 参考文档http://www.cnblogs.com/linhaifeng/articles/7133357.html#_label6]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python字典类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS禁止密码登录]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F03%2FCentOS%E7%A6%81%E6%AD%A2%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[CentOS 禁止密码登录 允许 sshkey 密钥登录，禁止密码登录 编辑 SSH 配置文件12345678910111213141516vim /etc/ssh/sshd_config# 找到以下配置项#RSAAuthentication yes#PubkeyAuthentication yes#AuthorizedKeysFile .ssh/authorized_keys# 去调上面 3 行前面的 (#)注释# 找到下面 1 行PasswordAuthentication yesPermitRootLogin yes# 修改为PasswordAuthentication no # 禁止密码登录PermitRootLogin no # 禁止 root 登录PermitRootLogin without-password # 禁止 root 密码登录 重启 SSH 服务12systemctl reload sshdsystemctl -l status sshd 参考文档https://blog.csdn.net/u013372487/article/details/71307323]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>CentOS禁止密码登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper可视化界面zkui搭建与配置]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F28%2FZookeeper%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2zkui%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Zookeeper可视化界面zkui搭建与配置一个允许在 Zookeeper 上进行 CRUD 操作的 UI 控制面板。 下载地址https://github.com/DeemOpen/zkui 运行环境jdk 7 初始化环境 zkui 是基于 java 语言开发，首先就要我们安装 jdk 环境。因为 zkui 需要我们手工进行编译、构建和打包，所以还需要安装 maven 环境。 安装 jdk1.712tar -zxvf jdk-7u80-linux-x64.tar.gz -C /data/chown -R root:root /data/jdk1.7.0_80/ 添加环境变量12345678910cat &gt;&gt; /etc/profile.d/jdk.sh &lt;&lt; “EOF”#!/bin/bashexport JAVA_HOME=/data/jdk1.7.0_80export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binEOFsource /etc/profilejava –version 生成 zkui 的 jar 包 zkui 的源码包，我们可以在 github 上进行下载https://github.com/DeemOpen/zkui.git1234567cd /data/tools/git clone https://github.com/DeemOpen/zkui.gitcd zkui/ll -h# 使用 mvn 命令进行编译构建打包mvn clean install 可以看到 maven 打包后生成了 zkui-2.0-SNAPSHOT.jar 和 zkui-2.0-SNAPSHOT-jar-with-dependencies.jar 两个文件，其中 zkui-2.0-SNAPSHOT-jar-with-dependencies.jar 是我们需要的 jar 文件。 启动 zkui zkui 运行的 jar 文件生成后，我们就可以直接运行该文件了。在运行该文件之前，我们还需要修改 zkui 的配置文件 config.cfg。config.cfg 文件中配置了，zkui 需要连接的 zookeeper 集群的 IP 地址和端口，访问 ui 的用户名和密码，以及 zkui 监听的端口号 123456789cd zkui/vim config.cfgserverPort=9090 # Web服务端口zkServer=10.1.1.127:2181,10.1.1.128:2181,10.1.1.129:2181 # 一个或多个 Zookeeper 节点地址ldapAuth=falseldapDomain=mycompany,mydomainldapUrl=ldap://&lt;ldap_host&gt;:&lt;ldap_port&gt;/dc=mycom,dc=comldapRoleSet=&#123;"users": [&#123; "username":"domain\\user1" , "role": "ADMIN" &#125;]&#125;userSet = &#123;"users": [&#123; "username":"admin" , "password":"manager","role": "ADMIN" &#125;,&#123; "username":"appconfig" , "password":"appconfig","role": "USER" &#125;]&#125; 默认用户信息 用户名：Admin（Admin权限，支持CRUD操作）密码：manager用户名：appconfig（Readonly权限，支持读取操作）密码：appconfig LDAP 配置 如果你想使用 LDAP 身份验证，则提供 LDAP url。这将优先于 roleSet property 文件认证。ldapUrl=ldap://&lt;ldap_host&gt;:&lt;ldap_port&gt;/dc=mycom,dc=com如果不提供此功能，则将使用默认 roleSet 文件认证。 12nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &gt; /data/app/zkui/logs/stdout.log 2&gt;&amp;1 &amp;netstat -tunlp | grep 9090 访问 http://x.x.x.x:9090 参考文档https://www.ilanni.com/?p=13646]]></content>
      <categories>
        <category>Zookeeper笔记</category>
      </categories>
      <tags>
        <tag>Zookeeper可视化界面zkui搭建与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ集群安装与配置]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F27%2FActiveMQ%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ActiveMQ集群安装与配置ActiveMQ 集群是依赖于 ZooKeeper 集群而存在的在此我们把 ZooKeeper 集群和 ActiveMQ 集群安装在同样三台机器上。 ActiveMQ 集群原理 ActiveMQ 集群原理，使用 ZooKeeper 集群注册所有的 ActiveMQ Broker。只有其中的一个 Broker 可以对外提供服务，被视为 master。而其他的 Broker 处于待机状态，被视为 slave。而此时 slave 只是做数据的主从同步。 如果 master 因故障而不能提供服务，ZooKeeper 集群会从 slave 中选举出一个Broker 充当 master。slave 连接 master 并同步它们的存储状态，slave 不接受客户端连接。所有的存储操作都将被复制到连接至 master 的 slave 上。 如果 master 宕机了，得到了最新更新的 slave 会成为 master。而故障节点在恢复后会重新加入到集群中并连接 master 进入 slave 模式。 需要同步的消息操作都将等待存储状态被复制到其他节点的操作完成后才能完成。 所以，如果你配置了 replicas=3，那么假定大小是 (3/2)+1=2。master 将会存储并更新然后等待 (2-1)=1 个 slave 存储和更新完成，才汇报 success。 至于为什么是 2-1，熟悉 ZooKeeper 集群的应该知道，有一个 node 要作为观擦者存在。当一个新的 master 被选中，你需要至少保障一个假定 node 在线以能够找到拥有最新状态的 node。这个 node 可以成为新的 Master。因此，推荐运行至少 3 个 replica nodes，以防一个 node 失败了，服务中断。（原理与 Zookeeper 集群的高可用实现方式类似）。 初始化环境 至少需要三台机器，这三台机器都已经安装 ActiveMQ 服务，ZooKeeper 集群也已经配置完毕。这三台机器的 IP 分别为 10.1.1.127，10.1.1.128，10.1.1.129 查看 ZooKeeper 集群的情况1/data/app/zookeeper/bin/zkServer.sh status 环境初始化完毕后，开始配置 ActiveMQ 集群。 配置 ActiveMQ 集群 ActiveMQ 集群的配置比较简单，我们只需要修改 ActiveMQ 的配置文件 activemq.xml 中部分内容即可。ActiveMQ 根目录下的 conf/activemq.xml 文件，原来默认内容如下：1234vim conf/activemq.xml +81&lt;persistenceAdapter&gt;&lt;kahaDB directory=”$&#123;activemq.data&#125;/kahadb”/&gt;&lt;/persistenceAdapter&gt; 修改后的内容如下：12345678910111213vim conf/activemq.xml +81&lt;persistenceAdapter&gt;&lt;replicatedLevelDBdirectory=”$&#123;activemq.data&#125;/leveldb”replicas=”3″bind=”tcp://0.0.0.0:0″zkAddress=”10.1.1.127:2181,10.1.1.128:2181,10.1.1.129:2181″zkSessionTimeout=”4s”hostname=”10.1.1.127″sync=”local_disk”zkPath=”/activemq/leveldb-stores”/&gt;&lt;/persistenceAdapter&gt; 配置的含义解释如下：directory：表示 ActiveMQ 集群消息持久化保存到服务器上的路径，注意该路径一定要先创建好。replicas：表示 ActiveMQ 集群的节点个数。bind：表示当这个节点成为 master 后，绑定的机器的地址与端口。此处 0.0.0.0:0 表示绑定到本机所有可用 IP，而端口是随机的。zkAddress：表示 ZooKeeper 的 IP 和 port。如果是 ZooKeeper 集群的话，则用逗号隔开。zkSessionTimeout：表示 ActiveMQ 与 ZooKeeper 集群连接的会话超时时间。hostname：表示本机的 IP 地址。服务器根据不同的 IP 地址做出改变，其他配置相同。sync：在消息被消费完成前，同步信息所存贮的策略。如果有多种策略用逗号隔开，ActiveMQ 会选择较强的策略。而如果有 local_mem，local_disk 这两种策略的话，那么 ActiveMQ 则优先选择 local_disk 策略，存储在本地硬盘。zkPath：表示 ActiveMQ 在 ZooKeeper 集群上创建的 znode 节点的路径，也即是ZooKeeper 选举信息交换的存贮路径。注意：这 3 个 ActiveMQ 节点中的 brokerName 配置必须相同，否则不能加入集群。 启动 ActiveMQ 集群 ActiveMQ 集群配置完毕后，我们现在来启动 ActiveMQ 集群。但是在正式启动 ActiveMQ 集群之前，一定要先启动 ZooKeeper集群。 要启动 ActiveMQ 集群，我们只需要启动这 3 台服务器的 ActiveMQ 服务即可。如下：12/data/app/activemq/bin/activemq startps -ef | grep mq ActiveMQ 集群启动完毕，根据 ZooKeeper 的策略，会从这三台 ActiveMQ 服务器选一台作为 master 对外提供服务，其他两台作为 slave 等待运行，而 slave 只是做数据上的主从同步。 所以，ActiveMQ 集群后，访问http://10.1.1.127:8161/admin/http://10.1.1.128:8161/admin/http://10.1.1.129:8161/admin/只会有一个成功 那么现在在 ActiveMQ 集群中，如何查看哪一台服务器是 master 节点呢？我们可以通过查看这三台服务器哪一台服务器监听 8161 端口，来判断哪台服务器是 master 节点。 现在在切换到服务器上查看监听的端口，如下：1netstat -tunlp | grep 8161 可以很明显的看出，目前只有 10.1.1.127 这台服务器监听 8161 端口的。那就说明目前10.1.1.127 是 master 节点。其他两个节点是 slave 节点，处于待机状态，没有监听 8161 端口。 现在我们再来看访问 10.1.1.127 服务器 ActiveMQ 管理控制台看看，如下：http://10.1.1.127:8161/admin到此说明 ActiveMQ 集群已经部署完毕。 验证 ActiveMQ 集群高可用 要验证 ActiveMQ 集群的高可用，我们只需要关闭能访问http://x.x.x.x:8161/admin/ 的 ActiveMQ 服务，然后访问其他两个。 如果其中有一个能访问，那就说明 ActiveMQ+ZooKeeper 集群高可用已经配置成功。通过第四章节，我们知道目前 master 节点是 10.1.1.127 这台服务器。现在我们来关闭10.1.1.127 这台服务器的 ActiveMQ 服务，看看 ActiveMQ 集群，是否能正常访问。如下： 12ps -ef | grep mqkill -9 3889 我们已经把 10.1.1.127 这台服务器的 ActiveMQ 服务已经关闭了。现在我们再来看看目前哪台服务器是 master 节，也即是查看哪台服务器的 8161 端口对外提供服务器。如下：12netstat -tunlp | rep 8161ps -ef | rep mq 可以很明显的看出目前 10.1.1.128 这台服务器是 master 节点。现在我再来通过管理控制台访问10.1.1.128 的 8161 端口看看。如下：http://10.1.1.128:8161/admin/ 我们可以很明显的看出 10.1.1.127 这台服务器的 ActiveMQ 服务停止后，并没有影响 ActiveMQ 集群的正常运行。这也就说明了 ActiveMQ 集群是正常工作的。到此，有关 ActiveMQ 集群的搭建与配置已经全部完毕。 参考文档https://www.ilanni.com/?p=13569]]></content>
      <categories>
        <category>ActiveMQ笔记</category>
      </categories>
      <tags>
        <tag>ActiveMQ集群安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ安装与配置]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F27%2FActiveMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ActiveMQ安装与配置 操作系统 CentOS7建议 ActiveMQ 集群 和 Zookeeper 集群部署在同一台服务器上，否则随着时间的增加，ActiveMQ 集群容易出现假死的情况。 JMS 支持的消息传递模型 JMS 支持两种消息传递模型：队列（Queue）和 主题（Topic）。 点对点传递模型 点对点（point-to-point，简称 PTP）Queue 消息传递模型。 通过该消息传递模型，一个应用程序（即消息生产者）可以向另外一个应用程序（即消息消费者）发送消息。 在此传递模型中，消息目的地类型是队列（即 Destination 接口实现类实例由 Session 接口实现类实例通过调用其 createQueue 方法并传入队列名称而创建）。 消息首先被传送至消息服务器端特定的队列中，然后从此对列中将消息传送至对此队列进行监听的某个消费者。同一个队列可以关联多个消息生产者和消息消费者，但一条消息仅能传递给一个消息消费者。 如果多个消息消费者正在监听队列上的消息，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。 如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。这种消息传递模型是传统意义上的懒模型或轮询模型。 在此模型中，消息不是自动推动给消息消费者的，而是要由消息消费者从队列中请求获得。 发布/订阅传递模型 发布/订阅（publish/subscribe，简称 pub/sub）Topic 消息传递模型。 通过该消息传递模型，应用程序能够将一条消息发送给多个消息消费者。在此传送模型中，消息目的地类型是主题（即 Destination 接口实现类实例由 Session 接口实现类实例通过调用其 createTopic 方法并传入主题名称而创建）。 消息首先由消息生产者发布至消息服务器中特定的主题中，然后由消息服务器将消息传送至所有已订阅此主题的消费者。 主题目标也支持长期订阅。长期订阅表示消费者已注册了主题目标，但在消息到达目标时该消费者可以处于非活动状态。 当消费者再次处于活动状态时，将会接收该消息。如果消费者均没有注册某个主题目标，该主题只保留注册了长期订阅的非活动消费者的消息。 与 PTP 消息传递模型不同，pub/sub 消息传递模型允许多个主题订阅者接收同一条消息。JMS 一直保留消息，直至所有主题订阅者都接收到消息为止。 pub/sub 消息传递模型基本上是一个推模型。在该模型中，消息会自动广播，消息消费者无须通过主动请求或轮询主题的方法来获得新的消息。 具体区别对比如下 类型 Topic Queue 概要 Publish Subscribe messaging 发布订阅消息 Point-to-Point 点对点 有无状态 Topic 数据默认不落地，是无状态的。 Queue 数据默认会在 mq 服务器上以文件形式保存，比如Active MQ 一般保存在 $AMQ_HOME/data/kr-store/data 下面。也可以配置成 DB 存储。 完整性保障 并不保证 publisher 发布的每条数据，Subscriber 都能接受到。 Queue 保证每条数据都能被 receiver 接收。 消息是否会丢失 一般来说 publisher 发布消息到某一个 topic 时，只有正在监听该 topic 地址的 sub 能够接收到消息；如果没有 sub 在监听，该 topic 就丢失了。 Sender 发送消息到目标 Queue，receiver 可以异步接收这个 Queue 上的消息。Queue 上的消息如果暂时没有 receiver 来取，也不会丢失。 消息发布接收策略 一对多的消息发布接收策略，监听同一个 topic 地址的多个 sub 都能收到 publisher 发送的消息。Sub 接收完通知 mq 服务器。 一对一的消息发布接收策略，一个 sender 发送的消息，只能有一个 receiver 接收。receiver 接收完后，通知 mq 服务器已接收，mq 服务器对 queue 里的消息采取删除或其他操作。 初始化环境在此我们安装的是 ActiveMQ 5.14.5，ActiveMQ 5.14.5 使用的是 jdk1.7。ActiveMQ 5.15.0 使用的是 jdk1.8。 安装 jdk1.71234cd /data/tools/wget -c http://mirrors.linuxeye.com/jdk/jdk-7u80-linux-x64.tar.gztar -zxvf jdk-7u80-linux-x64.tar.gz -C /data/chown -R root:root /data/jdk1.7.0_80 添加环境变量123456vim /etc/profileexport JAVA_HOME=/data/jdk1.7.0_80export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binsource /etc/profilejava -version 关闭 防火墙 和 selinux，同步服务器时间123456ntpdate -u cn.ntp.org.cnsed -i ‘/SELINUX/s/enforcing/disabled/’ /etc/selinux/configsetenforce 0systemctl disable firewalld.servicesystemctl stop firewalld.serviceshutdown -r now 安装 ActiveMQ ActiveMQ 官网http://activemq.apache.org/ 下载 ActiveMQhttp://activemq.apache.org/download.htmlhttp://archive.apache.org/dist/activemq/ 下载 ActiveMQ5.14.51234mkdir -pv /data/app/activemqcd /data/tools/wget -c http://mirrors.hust.edu.cn/apache/activemq/5.14.5/apache-activemq-5.14.5-bin.tar.gztar -zxvf apache-activemq-5.14.5-bin.tar.gz -C /data/app/activemq –strip-components 1 查看 ActiveMQ 目录结构1ll -h 文件名/目录名 详解 activemq-all-5.14.5.jar ActiveMQ 所有 jar bin ActiveMQ 启动命令的二进制执行文件及一些命令脚本 conf ActiveMQ 配置目录，包含最基本的 ActiveMQ 配置文件 data ActiveMQ 数据目录，默认为空。包含 ActiveMQ 的进程文件、数据文件、日志文件。该目录也是 ActiveMQ 消息持久化的目录 docs 用户使用帮助相关文件 examples 操作 ActiveMQ 相关实例 lib ActiveMQ 需要的类库 webapps ActiveMQ 控制台应用目录 webapps-demo ActiveMQ 使用实例目录 LICENSE ActiveMQ 所有包使用的 Apache 开源消息协议 NOTICE ActiveMQ 版权信息 README 用户使用引导文件，包括一些文档及 URL 启动 ActiveMQ12/data/app/activemq/bin/activemq starttail -f /data/app/activemq/data/activemq.log ActiveMQ 启动方式 普通启动1/data/app/activemq/bin/activemq start 后台启动并指定日志文件1nohup /data/app/activemq/bin/activemq start &gt; /data/app/activemq/logs/smlog 2&gt;&amp;1 &amp; ActiveMQ 管理控制台 ActiveMQ 默认的管理后台端口是 8161，默认管理用户名和密码均是 admin。ActiveMQ 默认的管理后台端口，可以在 ActiveMQ 的配置文件 jetty.xml 中查看到12vim /data/app/activemq/conf/jetty.xml +110&lt;property name=”port” value=”8161″/&gt; ActiveMQ 默认管理用户名和密码均是 admin，如果要修改默认用户名和密码的话，可以通过修改 jetty-realm.properties 文件来达到目的123vim /data/app/activemq/conf/jetty-realm.propertiesadmin: password@123, adminuser: user@123, user 注意：ActiveMQ 用户名和密码的格式是1username: password, rolename 登陆管理控制台http://x.x.x.x:8161/admin 管理控制台介绍 在 ActiveMQ 的管理控制台，关注比较多的是 Queues队列 和 Topics主题。 Queues队列 选项 字段 详解 Number Of Pending Messages 表示还有多少条消息没有被消费，实际上是表示消息的积压程度。 Number Of Consumers 表示在该队列上还有多少消费者在等待接受消息。其实就是消费者的数量。 Messages Enqueued 表示生产了多少条消息。 Messages Dequeued 表示消费了多少条消息。 Topics主题 选项 字段 详解 Number Of Consumers 表示在该队列上还有多少消费者在等待接受消息。 Messages Enqueued 表示生产了多少条消息。 Messages Dequeued 表示消费了多少条消息。 参考文档https://www.ilanni.com/?p=13543]]></content>
      <categories>
        <category>ActiveMQ笔记</category>
      </categories>
      <tags>
        <tag>ActiveMQ安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os模块]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F21%2Fos%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os 模块 os 模块是与操作系统交互的一个接口 模块方法 注释 os.getcwd() 获取当前工作目录，即当前 python 脚本工作的目录路径 os.chdir(&quot;dirname&quot;) 改变当前脚本工作目录；相当于 shell 下 cd os.curdir 返回当前目录: (&#39;.&#39;) os.pardir 获取当前目录的父目录字符串名：(&#39;..&#39;) os.makedirs(&#39;dirname1/dirname2&#39;) 可生成多层递归目录 os.removedirs(&#39;dirname1&#39;) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(&#39;dirname&#39;) 生成单级目录；相当于 shell 中 mkdir dirname os.rmdir(&#39;dirname&#39;) 删除单级空目录，若目录不为空则无法删除，报错；相当于 shell 中 rmdir dirname os.listdir(&#39;dirname&#39;) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录 os.stat(&#39;path/filename&#39;) 获取文件/目录信息 os.sep 输出操作系统特定的路径分隔符，Windows下为&quot;\\&quot;，Linux下为&quot;/&quot; os.linesep 输出当前平台使用的行终止符，Windows下为&quot;\t\n&quot;，Linux下为&quot;\n&quot; os.pathsep 输出用于分割文件路径的字符串，Windows下为;，Linux下为: os.name 输出字符串指示当前使用平台。Windows-&gt;&#39;nt&#39;，Linux-&gt;&#39;posix&#39; os.system(&quot;bash command&quot;) 运行shell命令，直接显示 os.environ 获取系统环境变量 os.path.abspath(path) 返回 path 规范化的绝对路径 os.path.split(path) 将 path 分割成目录和文件名二元组返回 os.path.dirname(path) 返回 path 的目录。其实就是 os.path.split(path) 的第一个元素 os.path.basename(path) 返回 path 最后的文件名。如何 path 以 / 或 \ 结尾，那么就会返回空值。即 os.path.split(path) 的第二个元素 os.path.exists(path) 如果 path 存在，返回 True；如果 path 不存在，返回 False os.path.isabs(path) 如果 path 是绝对路径，返回 True os.path.isfile(path) 如果 path 是一个存在的文件，返回 True。否则返回 False os.path.isdir(path) 如果 path 是一个存在的目录，则返回 True。否则返回 False os.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回 path 所指向的文件或者目录的最后存取时间 os.path.getmtime(path) 返回 path 所指向的文件或者目录的最后修改时间 os.path.getsize(path) 返回 path 的大小 列出指定目录下的所有文件和子目录 包括隐藏文件，并以列表方式打印 12345import osprint(os.listdir(r'.'))# 输出结果['01 时间模块.py', '02 random模块.py', '03 os模块.py', '今日内容.txt'] 获取 文件/目录 信息12345678910import osprint(os.stat('今日内容.txt'))# 输出结果os.stat_result(st_mode=33206, st_ino=4503599627409980, st_dev=239211959, st_nlink=1, st_uid=0, st_gid=0, st_size=280, st_atime=1526694304, st_mtime=1526694304, st_ctime=1526694102)# 获取文件大小，以 bytes 为单位print(os.stat('今日内容.txt').st_size)# 输出结果280 获取 文件 大小信息12345import osprint(os.path.getsize(r'E:\PycharmProjects\SH_s1\day07\今日内容.txt'))# 输出结果280 os.system(&quot;bash command&quot;) 方法 运行shell命令，直接显示 123456789import osos.system('tasklist') # 输出 Windows 下当前所有进程列表# os.system() 只是单纯的执行命令，并不能把命令执行后的结果做进一步的处理res = os.system('tasklist')print('res----&gt;', res) # res变量只是命令的执行成功与否的执行状态# 输出结果res----&gt; 0 os.environ 方法 获取系统环境变量 123456789全局的用于在程序任何地方都需要用到它的结果的时候import osos.environ['login'] = 'yes'print(os.environ['login'])# 输出结果yes os.path.split(path) 方法 将 path 分割成 目录 和 文件名 二元组返回 12345678910print(os.path.split('/a/b/c/d.txt'))# 输出结果('/a/b/c', 'd.txt')print(os.path.split('/a/b/c/d.txt')[0])print(os.path.split('/a/b/c/d.txt')[1])# 输出结果/a/b/cd.txt os.path.dirname(path) 方法 返回 path 的 目录其实就是 os.path.split(path) 的第一个元素 123print(os.path.dirname('a/b/c/d.txt'))# 输出结果a/b/c os.path.basename(path) 方法 返回 path 最后的 文件名如何 path 以 / 或 \ 结尾，那么就会返回空值即 os.path.split(path) 的第二个元素 123print(os.path.basename('a/b/c/d.txt'))# 输出结果d.txt os.path.join(path1[, path2[, …]]) 方法 用于拼接路径将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 123print(os.path.join('a', 'b', 'c', 'd.txt'))# 输出结果a\b\c\d.txt 123print(os.path.join('a', 'b', 'D:\\', 'c', 'd.txt'))# 输出结果D:\c\d.txt 123print(os.path.join('a', 'b', 'd', 'c', '/', 'd.txt'))# 输出结果/d.txt os.path.normcase(path) 方法 只用于 Windows 系统，规范 Windows 目录在 Windows 平台上会将路径中所有字符转换为小写，将路径中的左斜杠转换为 Windows 中的右斜杠在 Linux 和 Mac 平台上，该函数会原样返回 path 123print(os.path.normcase('c:/windOws\\system32\\'))# 输出结果c:\windows\system32\ os.path.normpath(path) 方法 用于规范路径如 (..) 点点 (/) 斜杠 123456789101112print(os.path.normpath('c:\\windOws/a/b/../system32\\'))# 输出结果c:\windOws\a\system32print(os.path.normpath('c://windows\\System32\\../Temp/'))# 输出结果c:\windows\Tempa = '/Users/jieli/test1/\\\a1/\\\\aa.py/../..'print(os.path.normpath(a))# 输出结果/Users/jieli/test1 os 路径处理 常用路径处理方法 123os.path.dirname(os.path.dirname(os.path.abspath(__file__)))os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) OpenStack 中获取路径方式 1234567891011121314151617181920OpenStack 获取路径方式res = os.path.join( os.path.abspath(__file__), '..', '..')print(res)print(os.path.normpath(res))# 输出结果E:\PycharmProjects\SH_s1\day07\03 os模块.py\..\..E:\PycharmProjects\SH_s1# 合并一下print(os.path.normpath( os.path.join( os.path.abspath(__file__), '..', '..' ))) 12345678910import osimport os,syspossible_topdir = os.path.normpath(os.path.join( os.path.abspath(__file__), os.pardir, # 上一级 os.pardir, os.pardir))sys.path.insert(0, possible_topdir) 参考文档http://www.cnblogs.com/linhaifeng/articles/6384466.html#_label3]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>os模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调整Linux的网络栈Buffer_Size来提升网络性能]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F20%2F%E8%B0%83%E6%95%B4Linux%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A0%88Buffer_Size%E6%9D%A5%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[调整 Linux 的网络栈 Buffer Size 来提升网络性能 有两台位于不同数据中心的服务器，都用来处理很多并行的大文件传输。但是处理大文件，网络性能非常差。并且涉及到一个大文件，会导致性能降级。怎样通过调整 Linux下面的 TCP 来解决这个问题？ 默认，Linux 的 stack 是没有为广域网之间的大文件高速传输而配置的，这样做是为了节约内存资源。为了使连接的系统服务之间能有更加高速的网络处理更多的网络包，你可以很容易的通过增加网络 buffer size 来调整 Linux 网络 stack。 默认的 Linux buffer size 的最大值是非常小的，tcp 的内存是基于系统的内存自动计算的，你能通过键入以下命令找到实际的值 1cat /proc/sys/net/ipv4/tcp_mem 默认的和最大的接收数据包内存大小 12cat /proc/sys/net/core/rmem_defaultcat /proc/sys/net/core/rmem_max 默认的和最大的发送数据包内存的大小 12cat /proc/sys/net/core/wmem_defaultcat /proc/sys/net/core/wmem_max 最大的内存 buffers 的选项 1cat /proc/sys/net/core/optmem_max 调整值 为所有的协议队列设置操作系统层面的最大的发送 buffer size(wmem) 和 接收 buffer size (rmem)为 12MB。换句话说，设置内存数量，分配给每一个为了传送文件而打开或者是创建的 tcp socket。 警告！在大多数的 Linux 中 rmem_max 和 wmem_max 被分配的值为 128k，在一个低延迟的网络环境中，或者是 apps 比如 DNS、Web Server，这或许是足够的。尽管如此，如果延迟太大，默认的值可能就太小了，所以请记录以下在你的服务器上用来提高内存使用方法的设置。 12echo 'net.core.wmem_max=12582912' &gt;&gt; /etc/sysctl.confecho 'net.core.rmem_max=12582912' &gt;&gt; /etc/sysctl.conf 还需要设置 minimum size, initial size, and maximum size in bytes 12echo 'net.ipv4.tcp_rmem= 10240 87380 12582912' &gt;&gt; /etc/sysctl.confecho 'net.ipv4.tcp_wmem= 10240 87380 12582912' &gt;&gt; /etc/sysctl.conf 打开 window scaling，这是一个用来扩展传输窗口的选项 1echo 'net.ipv4.tcp_window_scaling = 1' &gt;&gt; /etc/sysctl.conf 确保定义在 RFC1323 中的 timestamps 打开 1echo 'net.ipv4.tcp_timestamps = 1' &gt;&gt; /etc/sysctl.conf 确保 select acknowledgments 1echo 'net.ipv4.tcp_sack = 1' &gt;&gt; /etc/sysctl.conf 这个 “select acknowledgments” 不知道该如何翻译，翻译为“选择确认？” 当连接关闭的时候，TCP 默认缓存了很多连接指标在 route cache 中，以至于在不久的将来，连接建立的时候，可以用这些值来设置初始化条件。通常，这提升了整体的性能，但是，有时候会引起性能下降， 如果设置的话，TCP 在关闭的时候不缓存这些指标。 1echo 'net.ipv4.tcp_no_metrics_save = 1' &gt;&gt; /etc/sysctl.conf 当 interface 接收到的数据包数量比内核处理速度的快的时候， 设置 input 队列最大的 packets 数量值。 1echo 'net.core.netdev_max_backlog = 5000' &gt;&gt; /etc/sysctl.conf 现在重载这些改变，使其生效 1sysctl -p 使用 tcpdump 命令查看 通过 eth0 数据包流量的变化 1tcpdump -ni eth0 参考文档https://segmentfault.com/a/1190000000473365 推荐阅读 请参考内核文档/networking/ip-sysctl.txt获取更加多的信息 请查看 sysctl 的 man 手册]]></content>
      <categories>
        <category>Linux内核优化笔记</category>
      </categories>
      <tags>
        <tag>调整Linux的网络栈Buffer_Size来提升网络性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat中Connector常用配置]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F15%2FTomcat%E4%B8%ADConnector%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Tomcat 中 Connector 常用配置 模式 描述 BIO 阻塞式 I/O，采用传统的 java I/O 进行操作，该模式下每个请求都会创建一个线程，适用于并发量小的场景 NIO 同步非阻塞，比传统 BIO 能更好的支持大并发，Tomcat 8.0 后默认采用该模式 APR Tomcat 以JNI形式调用http服务器的核心动态链接库来处理文件读取或网络传输操作，需要编译安装 APR 库 AIO 异步非阻塞，Tomcat 8.0 后支持 配置方法：在 tomcat/conf/ 下 server.xml 12345`&lt;Connector port="8080" protocol="HTTP/1.1"/&gt;`BIO: protocol="org.apache.coyote.http11.Http11Protocol"NIO: protocol="org.apache.coyote.http11.Http11NioProtocol"AIO: protocol="org.apache.coyote.http11.Http11Nio2Protocol"APR: protocol="org.apache.coyote.http11.Http11AprProtocol" BIO（blocking I/O） 阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作（即 java.io 包及其子包）。默认的模式，性能最差，没有经过任何优化处理和支持。 NIO（non-blocking I/O） Java SE 1.4 及后续版本提供的一种新的 I/O 操作方式（即 java.nio 包及其子包）。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API。拥有比传统 I/O 操作（BIO）更好的并发运行性能。要让 Tomcat 以 NIO 模式来运行，修改配置文件：tomcat/conf/server.xml 修改以下内容123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 修改 protocol 的值为 org.apache.coyote.http11.Http11NioProtocol1234&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; 重启 Tomcat 后生效 在 Tomcat 6.0 之后，提供了 NIO 的方式，可以有效的提升性能，特别是在大量长连接/数据上传+下载等 Web 应用中此时 portocal=”org.apache.coyote.http11.Http11NioProtocol”Tomcat 支持：BIO，NIO，NIO2，APR 四种 I/O 模式，Tomcat 8.5 之前 默认为 BIO Tomcat 8.5 and 9.0 have completely dropped the BIO connector.Tomcat 8.5 和 9.0 完全删除了 BIO 连接器默认 NIO 模式 对于互联网应用，我们应该在 NIO、NIO2 之间做选择，因为它能够有效的提升性能（主要是并发能力）其中 NIO2 即为 AIO，需要 JDK 1.7+、Linux 2.6+ 才能支持。BIO：JDK 1.5+，tomcat 5.x+NIO：JDK 1.6+，tomcat 6.x+NIO2：JDK 1.7+，tomcat 7.x+为了保守起见，我们暂且基于 NIO 模式 查看 Tomcat Connector 运行模式方法一：在 http://x.x.x.x:8080/manager/status 中查看服务器状态 方法二：根据 Tomcat 启动日志信息判断BIO12INFO: Initializing ProtocolHandler ["http-bio-8080"]Aug 04, 2015 10:20:35 PM org.apache.coyote.AbstractProtocol init NIO12INFO: Initializing ProtocolHandler ["http-nio-8080"]Aug 04, 2015 10:27:58 PM org.apache.coyote.AbstractProtocol init APR12INFO: Initializing ProtocolHandler ["http-apr-8080"]Aug 04, 2015 10:33:45 PM org.apache.coyote.AbstractProtocol init 整合Tomcat apr 设置环境变量方法一：在 tomcat/bin/catalina.sh 中增加1行在 echo “Using CATALINA_BASE: $CATALINA_BASE” 的上一行添加CATALINA_OPTS=”-Djava.library.path=/data/apr/lib” 方法二：在 /etc/profile 中加入1export CATALINA_OPTS=-Djava.library.path=/usr/local/apr/lib 使配置生效1source /etc/profile 修改配置文件1234567vim tomcat/conf/server.xml &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;# 修改 `protocol` 的值为 `org.apache.coyote.http11.Http11NioProtocol`&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; 重启 Tomcat，启动日志出现以下内容证明此时以 APR 模式启动 参考文档：https://blog.csdn.net/fd2025/article/details/80007435]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat中Connector常用配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回到页首按钮显示百分比]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F11%2F%E5%9B%9E%E5%88%B0%E9%A1%B5%E9%A6%96%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E7%99%BE%E5%88%86%E6%AF%94%2F</url>
    <content type="text"><![CDATA[回到页首按钮显示百分比 Back-to-top 按钮显示百分比 编辑配置文件 Next主题配置文件 /hexo/themes/next/_config.yml 12# Scroll percent label in b2t button. scrollpercent: false 将 scrollpercen: 的值改为 true 即可]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>回到页首按钮显示百分比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加在线联系]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FHexo%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[Hexo添加在线联系 当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。 配置方法 首先到 DaoVoice 上注册一个账号，注册完成后会得到一个 app_idhttp://dashboard.daovoice.io 获取 appid 的步骤 在 DaoVoice 的应用设置 -&gt; 安装到网站中的找到自己的 app_id然后在主题 /next/layout/_partials/head.swig 文件中最后添加代码 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 主题配置文件中添加配置 在主题配置文件 /next/_config.yml 中添加相应的配置 123# Online contactdaovoice: truedaovoice_app_id: 这里输入前面获取的app_id 调整位置 最后聊天图标的位置可能和一些东西重叠这个使用可以在控制面板中应用设置 -&gt; 聊天设置里面设置相对右边和底部的位置 参考文档https://www.ezlippi.com/blog/2018/01/next-chat.htmlhttps://meta.tn/a/c40f12eb1b892bbb8cda053c03c688e3f20e4f642164080ef463cd4a7bc3b042http://www.niww.me/2018/03/02/hexo-daovoice/]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加在线联系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题背景]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FNext%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Next主题背景个性化DIY 整理了一下博客，加个背景图片（BackGroundImage）调整一下视觉感官，背景图片 是动态变化的，每次刷新都会更新一张图 一个图片网站 分享一个非常 Nice 的图片网站，感觉这个国外的图片社区网站真的秒杀一众图片网站啊，不仅图片质量高，免费，而且还提供了随机拉取图片的服务 API，太赞，对于想实现动态背景，简直是福音https://source.unsplash.com/ 添加背景图片 修改 \themes\next\source\css\_custom\custom.styl 文件这个是 Next 故意留给用户自己个性化定制一些样式的文件，添加以下代码 123456body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; URL 括号中直接添加图片的地址链接，也可以置换成你所喜欢的任意图片。repeat、attachment、position 就是调整图片的位置，不重复出现、不滚动等。]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next主题背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加看板娘]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2F%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98%2F</url>
    <content type="text"><![CDATA[添加看板娘 实现效果 用 Git Bash Here 在站点根目录执行如下代码 12cd D:\hexo\npm install hexo-helper-live2d --save 然后打开 /themes/next/layout/_layout.swig 将下面代码放到 &lt;/body&gt; 之前{ { live2d() } }注意：由于官方更新了包，所以画删除线的不用做了 然后在这里可以看到一些已有的模型，记下想要的模型名字，使用安装命令https://huaji8.top/post/live2d-plugin-2.0/ 1npm install "模型的包名" 模型的包名 12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 以 hijiki 为例12345678910$ npm install "live2d-widget-model-hijiki" --savenpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)+ live2d-widget-model-hijiki@1.0.5added 1 package and audited 3800 packages in 8.046sfound 2 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for details$ npm install live2d-widget-model-tororo --save 在 配置文件 末尾添加代码 安装完成后，还需要在一些小小的修改在 _config.yml（Hexo站点 或 Next主题 皆可）中，加入以下内容 /blog/_config.yml或/blog/next/themes/_config.yml 123456789101112131415## 看板娘live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki display: position: right width: 150 height: 300 mobile: show: true # false 手机端不显示 详细配置1234567891011121314151617181920live2d: enable: true # 是否开启 scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url model: use: live2d-widget-model-wanko # 调用模型名，必须要先下载 display: position: right # 在博客的左边还是右边显示 width: 150 # 边框宽度 height: 300 # 边框高度 mobile: show: true # 是否在手机上显示 # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 根据需要可修改use:后的包名；调整长度和宽度；选择是否停用插件等。 参考文档https://wangyuyang.me/2018/04/06/对基于HEXO的NexT主题的美化/https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.mdhttps://alvabill.ml/hexo搭建个人博客-NexT主题优化/]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>添加看板娘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome自带的长截屏功能]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FChrome%E8%87%AA%E5%B8%A6%E7%9A%84%E9%95%BF%E6%88%AA%E5%B1%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Chrome自带的长截屏功能 在 Google Chrome 里面，打开开发人员工具 按F12或网站上任意空白处右键 – 选择 “检查” 或者“审查元素” 快捷键 Ctrl + Shift + P，会看到右边的审查元素出现了一个输入框输入 screenshot 然后回车保存图片]]></content>
      <categories>
        <category>Chrome笔记</category>
      </categories>
      <tags>
        <tag>Chrome自带的长截屏功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chevereto图床]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FChevereto%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[Chevereto图床 Chevereto 是一款采用 PHP 语言开发的网络相册脚本程序，支持多语言，提供中文语言包的下载的开源在线图片存储分享服务系统，支持本地上传和在线获取两种图像上传方式，并集成了 TinyURL 网址缩短服务。Chevereto 这套程序可以像 Discuz 或 WordPress 一样随意架设在任何空间上。而它的功能除了一般图片空间单纯的从电脑上传图片外，也支援利用网址也可以上传，最屌的是还有 TinyURL 的缩短网址的功能可以使用，因此这套 Chevereto 可以说是比市面上的图片空间好太多了。他是把图片上传到空间的，相信一般大家都一定会使用免费空间，在此建议大家在挑主机时尽可能使用 cPanel 的空间，因为可以使用 cPanel 特有的 「Cron Jobs」 来备份你上传的图片。 Chevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirements Clevereto 错误 404 解决方法 如果 Web服务 是 Nginx，基本第一步安装好后再次打开网站会出现 404 错误。因为 Chevereto 默认提供基于 Apache 环境的伪静态规则 需要设置以下 Rewrite 伪静态规则123456789101112131415location / &#123; if (-f $request_filename/index.html)&#123; rewrite (.*) $1/index.html break; &#125; if (-f $request_filename/index.php)&#123; rewrite (.*) $1/index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125; try_files $uri $uri/ /api.php;&#125;location /admin &#123; try_files $uri /admin/index.php?$args;&#125; 官方推荐配置123456789101112131415161718192021222324252627282930# Disable access to .ht* fileslocation ~ /\.ht &#123; deny all;&#125;# Disable access to sensitive files in app pathlocation ~ /(app|content|lib)/.*\.(po|php|lock|sql)$ &#123; deny all;&#125;# Disable log on not found images + image replacement# Image not found replacementlocation ~* (jpe?g|png|gif) &#123; log_not_found off; error_page 404 /content/images/system/default/404.gif;&#125;# Enable CORS header (avoids font rendering issues)location ~ \.(ttf|ttc|otf|eot|woff|woff2|font.css|css|js)$ &#123; add_header Access-Control-Allow-Origin "*";&#125;# Force serve upload path as static contentlocation ~ /images &#123;&#125;# Pretty URLs# Route dynamic request to index.phplocation / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 参考文档 https://www.zhujibiji.com/2017/11/install-chevere-to-build-your-image-sharing-website/https://lala.im/2478.html]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>Chevereto图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图床的选择]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2F%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%BA%8A%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[关于图床的选择为什么要使用图床？ Hexo 文章中的图片，我们可以放到本地，然后一起部署到 Github 中，这样完全没有问题。然而 github pages 空间毕竟有限（貌似只有 300M）,另外图片的管理太混乱了，一些原创的图片可能被盗链。 很多技术人写作都用的是 MarkDown 轻量级标记语言进行博客写作，这种写作让我们不用像使用 Word 那样那么麻烦地调整排版和格式，只需专心写作并且照样完成排版的一种方式。但是，基本所有支持 MarkDown 本地写作工具都只能采用导入本地图片引用的方式，对于一篇需要大量图片阐述的文章以及该文章上传至网络图片丢失，这不得不是个很糟糕的问题。那么有什么比较好的解决方式吗？很多人采用的图片寄存于网络，用服务厂商作为图片存储的地方，大家都叫为 「图床」 。 那么像 CSDN 博客、简书平台不是都可以吗？是的，它们平台写文章的时候都可以导入图片然后得到一个图片网络地址。但是，图片数量多，一张一张上传，这不是贼烦嘛！那么有专门可以作 「图床」 功能的服务商吗？有的，比如七牛云。 网上谷歌搜下还是能搜到很多图床网站的，先随便列举一些 公共图床SM.MS https://sm.ms/SM.MS 是由 V2EX @Showfom 自建的，无外链限制，无流量限制的图床，支持 HTTPS，速度不错，已经运行两年多了。 极简图床 https://jiantuku.com/#/ 路过图床 https://imgchr.com/ Imgur https://imgur.com/Imgur 是一家国外老牌的图片存储服务商，国外速度很快，口碑不错，支持 HTTPS。但是国内速度很不稳定，所以追求国内速度的同学慎用。 Qchan图床http://tuchuang.org/ 微博图床 微博图床，可以自定义支持七牛，界面简洁美观，支持 Chrome 插件，注册后还可以同步上传历史。 自建图床 目前自建图床方案有两种 是利用云服务商提供的存储服务来作为图床，通过 API 来管理图片 是在 VPS 上安装开源的图片或文件管理程序，只要能提供外链，基本都可以作为图床来用。 建图床（云服务） 七牛云，又拍云，阿里云OSS 自建图床（开源方案） 如果你有 VPS，并且网络速度 OK 的话，自建图床也是一个不错的选择。 Lychee https://github.com/electerious/LycheeLychee 是一个开源免费的基于 PHP 的图片管理系统，支持 Docker 部署，可以直接当做图床来用，Lychee 还支持很多扩展。 树洞外链 https://yun.aoaoao.me/https://github.com/HFO4/shudong-share树洞外链 是一款免费开源的 PHP 外链网盘系统，界面简洁友好，支持七牛、本地、远程、阿里云OSS、又拍云五种储存方式，支持多用户系统，多上传方案策略。 Chevereto https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirementsChevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。 使用图床的目的是希望文章的图片资源能有更好的加载速度和稳定的显示效果。]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>关于图床的选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之堆溢出处理]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F10%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java 虚拟机之堆溢出处理在 Java 程序的运行过程中，如果堆空间不足，则有可能抛出内存溢出错误 (Out Of Memory)，简称为 OOM。 如下文字显示了典型的堆内存溢出 1Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:20) 一旦发生这类问题，系统就会被迫退出。如果发生在生产环境，可能会引起严重的业务中断。为了能够不断改善系统，避免或减少这类错误的发生，需要在发生错误时，获得尽可能多的现场信息，以帮助研发人员排查现场问题。 Java 虚拟机提供了参数 -XX:+HeapDumpOnOutOfMemoryError，使用该参数，可以在内存溢出时导出整个堆信息。和它配合使用的还有 -XX:HeapDumpPath，可以指定导出堆的存放路径。 使用如下参数执行上述代码 1-Xms5m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/app/tomcat/logs/P02.dump 显然 20M 堆空间不足以容纳 25M 内存，系统比如发生内存溢出，在发生错误后，控制台输出如下 1java.lang.OutOfMemoryError: Java heap space Dumping heap to /data/app/tomcat/logs/P02.dump... Heap dump file created [23067302 bytes in 0.160 secs] Exception in thread “main” java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:19) 可以看到，虚拟机将当前的堆导出，并保存到 /data/app/tomcat/logs/P02.dump 文件下启动最小空间 5M，配了 20M 最大空间 ，发生了 内存溢出错误，dump 路径为 /data/app/tomcat/logs/P02.dump 使用 MAT 等工具打开该文件进行分析，可以很容易地找到这些 byte 数组和保存它们的 Vector 对象实例]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java虚拟机之堆溢出处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编译安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FPython%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一般情况下，Linux 都会预装 Python，但是这个预装的 Python 版本一般都比较低，很多 Python 的新特性都没有，必须重新安装新一点的版本Python下载地址https://www.python.org/https://www.python.org/ftp/python/https://www.python.org/ftp/python/2.7.15/https://www.python.org/ftp/python/3.6.5/ 查看 Python 版本1234567python -V# CentOS 6.xPython 2.6.6# CentOS 7.xpython 2.7.5 做好链接，保留旧版本 pythoncd /usr/bin/cp /usr/bin/python /usr/bin/python_bak 如果发现 yum 不能用了，解决 yum 无法使用的问题因为 yum 依赖系统默认安装的 python 版本, 处理如下：vim /usr/bin/yum#!/usr/bin/python修改为-&gt; #!/usr/bin/python2.6 或 #!/usr/bin/env python2.6import systry: import yumexcept ImportError:……省略…… 这里不更改 原 Python 版本 安装依赖1yum -y install readline readline-devel sqlite sqlite-devel zlib zlib-devel openssl openssl-devel bzip2 bzip2-devel bzip2-libs 缺少 readline 支持的 IPythonWARNING: IPython History requires SQLite, your history will not be savedWARNING: Readline services not available or not loaded.WARNING: The auto-indent feature requires the readline library 下载 Python12wget -c https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xzwget -c https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tar.xz 安装 Python安装 Python 2.7.15123456tar -xvf Python-2.7.15.tgzcd Python-2.7.15/./configure \--prefix=/data/python2.7.15 --enable-optimizationsmake -j 4make install 安装 Python 3.6.5123456tar -xvf Python-3.6.5.tgzcd Python-3.6.5/./configure \--prefix=/data/python3.6.5 --enable-optimizationsmake -j 4make install 添加 Python 环境变量1234vim /etc/profileexport PATH=$PATH:/data/python2.7.15/binexport PATH=$PATH:/data/python3.6.5/binsource /etc/profile 或 12echo -e '\nexport PATH=$PATH:/data/python2.7.15/bin' &gt;&gt; /etc/profileecho -e 'export PATH=$PATH:/data/python3.6.5/bin' &gt;&gt; /etc/profile PS：如果安装 easy_intall 时报 zlib 没有安装，Linux下直接 yum -y install zlib zlib-devel，然后重新编译 Python2.7.15 继续就可以了cp /usr/bin/python /usr/bin/python_bakln -svnf /data/python2.7.15/bin/python2.7 /usr/bin/python setuptools 安装 下载地址https://pypi.python.org/pypi/setuptoolshttps://pypi.python.org/simple/setuptools/ 1234tar -zxvf setuptools-39.2.0.tar.gzcd setuptools-39.2.0python3 setup.py buildpython3 setup.py install IPython 是一个 python 的交互式 Shell，比默认的 Python Shell 好用一点，支持变量自动补全，自动缩进，支持 Bash Shell 命令，内置了许多很有用的功能和函数安装 IPythonIPython 下载地址https://pypi.org/project/ipython/ 1234tar -zxvf ipython-6.4.0.tar.gzcd ipython-6.4.0/python3 setup.py buildpython3 setup.py install 安装 pip pip 下载地址https://pypi.org/project/pip/ 1234tar -xvf pip-10.0.1.tar.gzcd pip-10.0.1/python3 setup.py buildpython3 setup.py install pip 安装 python 第三方库1234pip3 install requestspip3 install pyapi-gitlabpip3 install readlinepip3 install rlcompleter2]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志切割]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志切割 12345678910111213141516vim logcut.sh#!/bin/bashday=$(date +"%Y-%m-%d")yesterday=$(date -d "yesterday" +%Y-%m-%d)logsdir=(/data/app/*/logs)for logdir in $&#123;logsdir[@]&#125;do for logfile in $(ls $&#123;logdir[@]&#125; | egrep "stdout.log|catalina.out") do cp $logdir/$logfile $logdir/$&#123;logfile%.log&#125;.$&#123;day&#125;.log cp $logs/$file $logs/$&#123;file%.out&#125;.$&#123;day&#125;.out cat /dev/null &gt; $logdir/$logfile donedone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志切割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志压缩]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志压缩打包 压缩 7 天前日志每个月 1 号，创建上个月的目录，年-月 2018-04将 gz 压缩文件拷贝到 年-月 2018-04 目录中 1234567891011121314151617181920vim compresslog.sh#!/bin/bashday=$(date +"%d")month=$(date +"%Y-%d")lastmonth=$(date +"%Y-%m" -d "last month")lastweek=$(date +"%Y-%m-%d" -d "last week")logsdir=(/data/app/*/logs)for logs in $&#123;logsdir[@]&#125;do find $logs/ -mtime +7 -regextype posix-extended -regex ".*\.(log|out|txt)" -exec gzip &#123;&#125; \;done[ $day == 01 ] &amp;&amp; cd $&#123;logsdir[@]&#125; &amp;&amp; mkdir -pv $lastmonthfor logdir in $&#123;logsdir[@]&#125;do [ -d $logdir/$lastmonth ] || mkdir -pv $logdir/$lastmonth mv $logdir/*gz $logdir/$lastmonthdone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM 磁盘扩展]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FLVM%E7%A3%81%E7%9B%98%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[LVM 磁盘扩展 查看磁盘空间1df -h 查看 LV 信息1lvs 查看 VG 信息1vgs 创建 PV1pvcreate /dev/vdb 扩展已有的 VG 容量1vgextend vgdata /dev/vdb Couldn&#39;t&#39; create temporary archive name.因为磁盘实在太小了或已经没有空间了，无法执行，删除一些数据就好了 12vgextend vgdata /dev/sdaVolume group "vgdata" successfully extended 查看 VG 信息1vgs 扩展已有 LV 容量123lvextend -l +100%FREE /dev/vgdata/lvdatalvextend -L +99.99G -n /dev/vgdata/lvdatalvextend -L +1020M -n /dev/vgdata/lvdata -L # 指定逻辑卷的大小，单位为 kKmMgGtT 字节，也就是 Size-l # 指定逻辑卷的大小，单位为 PE 数 重新加载逻辑卷12345# 加载 ext 文件系统resize2fs /dev/vgdata/lvdata# 加载 xfs 文件系统xfs_growfs /dev/vgdata/lvdata]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>LVM 磁盘扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建LVM]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FLVM%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[创建 LVM LVM 创建过程创建PV -&gt; 创建VG -&gt; 创建LV -&gt; 格式化LV -&gt; mount挂载 常用命令pvcreate 设备名vgcreate 卷组名 物理卷lvcreate -L 大小 -n 逻辑卷名 卷组名 LVM 常用命令表 功能 管理物理卷 管理卷组 管理逻辑卷 Scan 扫描 pvscan vgscan lvscan Create 创建 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Extend 扩展 vgextend lvextend Reduce 减少 vgreduce lvreduce 安装 LVM1yum -y install lvm2 创建 PV12pvcreate /dev/vdbPhysical volume "/dev/vdb" successfully created 创建 VG12vgcreate vgdata /dev/vdbVolume group "vgdata" successfully created 创建 LV12345lvcreate -L 49.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created.lvcreate -L 99.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created. 文件系统格式化12345# 格式化 ext 文件系统mkfs.ext4 /dev/vgdata/lvdata# 格式化 xfs 文件系统mkfs.xfs /dev/vgdata/lvdata 挂载逻辑卷到目录12mkdir -pv /datamount /dev/vgdata/lvdata /data 编辑 /etc/fstab1234vim /etc/fstab...省略.../dev/mapper/vgdata-lvdata /data xfs defaults 0 0...省略... ###]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>创建LVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加文章结束标记]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F07%2FNext%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[添加文章结束标记 编辑 /hexo/themes/next/layout/_macro/post.swig 文件在 if theme.wechat_subscriber.enabled and not is_index 上面添加如下代码 代码片段123456&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt;&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125; &lt;div&gt; &#123;% include 'wechat-subscriber.swig' %&#125; &lt;/div&gt;&#123;% endif %&#125; 显示效果1————— The End —————]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加文章结束标记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加音乐]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[Next 添加音乐 去网易云音乐搜索喜欢的音乐，点击生成外链播放器，复制代码直接放到博文末尾即可height 设为 0 可隐藏播放器，但仍然可以播放音乐auto 设成 0 可手动播放，默认是 1 自动播放 编辑 /hexo/themes/next/layout/_custom/sidebar.swig 文件里，播放器会显示在站点预览中或编辑 /hexo/themes/next/layout/_macro/sidebar.swig 文件里 123# 将代码粘贴到一个合适的位置&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2188265841&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加分类及标签]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FHexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Hexo添加分类及标签创建 分类 选项 生成 分类 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page categories 成功后会提示 1INFO Created: ~/hexo/source/categories/index.md 根据上面的路径，找到 index.md 这个文件，打开后默认内容是这样的 1234---title: 文章分类date: 2018-06-06 22:49:07--- 添加 type: &quot;categories&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "categories"--- 给文章添加 “categories” 属性 打开需要添加分类的文章，为其添加 categories 属性下方的 categories: Hexo笔记 表示添加这篇文章到 Hexo笔记 这个分类注意：hexo 一篇文章只能属于一个分类，也就是说如果在 - Hexo笔记 下方添加 - xxxhexo 不会产生两个分类，而是把分类嵌套（即该文章属于 - Hexo笔记 下的 - xxx 分类） 123456---title: Hexo添加分类及标签date: 2018-06-06 22:44:41categories: - Hexo笔记--- 至此，成功给文章添加分类，点击首页的 分类 可以看到该分类下的所有文章当然，只有添加了 categories: xxx 的文章才会被收录到首页的 分类 中 创建标签选项 生成 标签 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page tags 成功后会提示 1INFO Created: ~/hexo/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的 1234---title: 标签date: 2018-06-06 22:49:07--- 添加 type: &quot;tags&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "tags"--- 给文章添加tags属性打开需要添加标签的文章，为其添加 tags 属性下方的tags:Hexo添加分类及标签- 表格- 表单验证就是这篇文章的标签了 12345678910---title: Hexo添加分类及标签date: 2018-06-06 22:49:07categories: - Hexo笔记tags:- Hexo添加分类及标签- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的标签可以看到该标签下的所有文章当然，只有添加了 tags: xxx 的文章才会被收录到首页的标签中细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的所以我们可以打开 \hexo\scaffolds/post.md 文件，在 tages:上面加入categories:1234567vim /hexo/scaffolds/post.md---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 保存后执行hexo new &quot;文章名&quot;命令生成的文件，页面里就有categories:项了\hexo\scaffolds\ 目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加分类及标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置网站的图标Favicon]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FHexo%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%AB%99%E7%9A%84%E5%9B%BE%E6%A0%87Favicon%2F</url>
    <content type="text"><![CDATA[Hexo 设置网站的图标 Favicon ico图标使用 32x32去别的网站下载或 PS 制作，并将图标名称改为 favicon.ico然后把图标放在 \next\themes\next\source\images\ 目录下也可以放在 hexo\source\images 目录下，这个目录没有可以自己手动创建 修改 next主题配置文件，\next\themes\next\_config.yml 文件12345678favicon: small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo设置网站的图标Favicon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加访问量]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Next添加访问量 使用 Next 主题自带的不蒜子统计，仅限于在文章页面显示阅读量，不在首页显示 修改 themes\next\ _config.yml 文件123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数(UV) site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量(PV) site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 总访问量 (PV) 总访问量独立访客 (UV) 访问人数网站的浏览次数为 PV网站的访客数为 UVPV 计算方式，单个用户连续点击 N 篇文章，记录 N 次访问量UV 计算方式，单个用户连续点击 N 篇文章，只记录 1 次访客数可以根据需要添加相应的统计功能 查看底部显示效果]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加访问量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next修改小型代码块颜色]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E4%BF%AE%E6%94%B9%E5%B0%8F%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%9D%97%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Next 修改小型代码块颜色 修改 \themes\next\source\css\ _variables\base.styl 文件可以加入自定义颜色，如下中已经给出了许多种颜色 12345678910111213// Colors// colors for use across theme.// --------------------------------------------------$whitesmoke = #f5f5f5$gainsboro = #eee$gray-lighter = #ddd...$blue = #0684bd$blue-deep = #262a30$orange = #fc6423 修改 $code-background 与 $code-foreground 的值 以下的各个参数自己根据需求进行设置即可 1234567// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 13px$code-foreground = $black-light //设置成自己喜欢的颜色即可$code-background = $gainsboro //设置成自己喜欢的颜色即可$code-border-radius = 4px 在 \themes\next\source\css\ _variables\base.styl 文件内还有很多的参数，可以酌情进行修改]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next修改小型代码块颜色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next头像圆形旋转]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E5%A4%B4%E5%83%8F%E5%9C%86%E5%BD%A2%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[头像变成圆形，鼠标停留在上面发生旋转效果 介绍一下实现头像圆形，鼠标经过旋转或者一直让旋转效果修改 Hexo 目录下 \themes\next\source\css\_common\components\sidebar\sidebar-author.styl 文件 头像圆形修改 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转修改 修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 方法二：修改 themes/next/source/css/_common/components/sidebar/sidebar-author.styl 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 头像循环旋转效果修改 修改 sidebar-author.styl 文件，添加如下代码 12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next头像圆形旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置首页隐藏指定文章]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FNext%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Next设置首页隐藏指定文章 修改 next 主题文件夹下的 layout 中的 index.swig 文件定位修改 post_template.render(post, true) 1234567891011\themes\next\layout\index.swig...省略...&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.visible !== 'hide' %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt;...省略... 其中修改的是为文章的首页显示添加判断条件 在新的 post 中添加 visible 字段来控制是否首页显示 例如：当前这篇文章 12345title: Next设置首页隐藏指定文章date: 2018-06-06 01:08:59categories: Next笔记tags: Next设置首页隐藏指定文章visible: hide 这里如果加上 hide 则该文章就不会在文章首页显示，如果留空则表示默认显示]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置首页隐藏指定文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks 安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F06%2FShadowsocks%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Shadowsocks 安装 123456yum -y install python-pippip install --upgrade pippip install shadowsockswhich ssserverpip install M2Cryptopip install gevent 123456789101112131415161718vim /etc/systemd/system/shadowsocks.service[Unit]Description=Shadowsocks[Service]Type=simpleTimeoutStartSec=0PIDFile=/data/shadowsocks/var/run/ssserver.pidExecStart=/usr/bin/ssserver -c /data/shadowsocks/conf/shadowsocks.json -d start \ --pid-file /data/shadowsocks/var/run/ssserver.pid \ --log-file /data/shadowsocks/logs/ssserver.logRestart=on-abortRestartSec=10sPrivateTmp=true[Install]WantedBy=multi-user.targettail -f /data/shadowsocks/logs/ssserver.log 123456789101112131415mkdir -pv /data/shadowsocks/&#123;conf,logs,var/run&#125;cd /data/shadowsocks/vim shadowsocks.json&#123; "server":"149.28.231.171", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "8888":"gmlyo", "8889":"glmyo" &#125;, "timeout":300, "method":"aes-256-cfb", "fast_open":false&#125; 1234567systemctl daemon-reloadsystemctl start shadowsockssystemctl -l status shadowsockssystemctl enable shadowsockssystemctl stop shadowsockssystemctl restart shadowsocksjournalctl -fu shadowsocks 12345678910111213141516171819202122232425262728293031323334# 查看防火墙状态systemctl status firewalldsystemctl -l status firewalld# 查看防火墙，添加的端口也可以看到firewall-cmd --list-all# 显示所有公共区域（public）所有设置firewall-cmd --zone=public --list-all# 查看开放的服务firewall-cmd --list-services# 显示服务列表firewall-cmd --get-services# 永久添加开放端口firewall-cmd --zone=public --permanent --add-port=8888/tcpfirewall-cmd --zone=public --permanent --add-port=1194/udp# 查询刚插入的规则是否生效firewall-cmd --zone=public --query-port=1985/tcp# 查询指定的端口是否永久开放firewall-cmd --zone=public --permanent --query-port=1985/tcp# 永久删除正在开放的端口firewall-cmd --zone=public --permanent --remove-port=8080/tcpfirewall-cmd --zone=public --permanent --remove-port=1194/udp# 重新加载配置firewall-cmd --reload# 查看所有打开的端口firewall-cmd --zone=public --list-portsfirewall-cmd --zone=dmz --list-ports]]></content>
      <categories>
        <category>Shadowsocks笔记</category>
      </categories>
      <tags>
        <tag>Shadowsocks 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat_APR_安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F05%2FTomcat_APR_%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Tomcat APR 安装 APR(Apache portable Run-time libraries) 可移植运行时库，是 Apache HTTP 服务的支持库，提供了一组映射到下层操作系统的 API。Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高 Tomcat 对静态文件的处理性能。改善 Tomcat 对静态文件的处理性能，同时如果使用了 HTTPS 方式传输的话，也可以提升 SSL 的处理性能。默认情况下，Tomcat 是用 BIO 的方式来实现网络通信的，性能非常低。Tomcat apr 也是在 Tomcat 上运行高并发应用的首选模式。APR 使用 JNI 的方式来读取文件以及进行网络传输，从操作系统级别来解决异步的 I/O 问题，大幅度的提高性能。如果操作系统不支持某个特定的功能，APR 将提供一个模拟的实现，这样程序员使用 APR 编写真正可在不同平台上移植的程序 安装依赖12345Tomcat 和 JDKyum install -y apr-develyum install -y gcc gcc-develyum install -y openssl openssl-develyum install -y expat-devel 下载 apr 下载地址：https://apr.apache.org/download.cgi 1234cd /data/tools/wget -c http://mirrors.shu.edu.cn/apache//apr/apr-1.6.3.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-util-1.6.1.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-iconv-1.2.2.tar.gz 安装 apr1234567891011121314151617181920212223# 解压并进入解压目录cd /data/tools/tar -zxvf apr-1.6.3.tar.gzcd apr-1.6.3/# 配置，安装在 /data/ 目录下./configure --prefix=/data/apr# 报错信息config.status: executing libtool commandsrm: cannot remove 'libtoolT': No such file or directoryconfig.status: executing default commands# 解决方法# 编辑 configure 文件cd apr-1.6.3/vim configure把 $RM "$cfgfile" 这行代码注释掉或 把 $RM "$cfgfile" 这行删除掉或 写成 $RM -f "$cfgfile"重新再运行 ./configure 就可以了# 编译安装make -j 4make install 安装 apr-iconv1234567891011# 解压并进入解压目录cd /data/tools/tar -zxvf apr-iconv-1.2.2.tar.gzcd apr-iconv-1.2.2/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-iconv \--with-apr=/data/apr# 编译安装make -j 4make install 安装 apr-util123456789101112131415161718192021222324252627# 解压并进入解压目录cd /data/tools/tar -zxvf apr-util-1.6.1.tar.gzcd apr-util-1.6.1/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-util \--with-apr=/data/apr \--with-apr-iconv=/data/apr-iconv/bin/apriconv# 编译安装make -j 4# 报错信息xml/apr_xml.c:35:19: fatal error: expat.h: No such file or directory #include &lt;expat.h&gt; ^compilation terminated.make[1]: *** [xml/apr_xml.lo] Error 1make[1]: Leaving directory `/data/tools/apr-util-1.6.1'make: *** [all-recursive] Error 1# 解决办法# 缺少 expat 开发库，安装 expat 库yum install -y expat-devel# 重新执行make -j 4make install 配置 Tomcat 使用 apr 库 什么是 tomcat-native ？tomcat-native 库为 Tomcat 提供了本地实现tomcat-native 依赖于三个组件：APR，OpenSSL，JDK 大致就是通过 tomcat-native 库，使 tomcat 运行时通过 APR 更多的调用本地 API，达到提升性能的目的。由于依赖关系，安装时，先安装 APR，OpenSSL，然后再安装 tomcat-native，最后配置 tomcat 启动时依赖的库路径。 安装配置 Tomcat native 具体的安装步骤其实在 tomcat 自带的 tomcat-native.tar.gz 文件中就有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 进入 Tomcat bin 目录cd /data/app/tomcat/bin/# 解压 tomcat-native.tar.gz 后进入解压目录tar -zxvf tomcat-native.tar.gz# cd tomcat-native-1.2.8-src/native/ # Tomcat7cd tomcat-native-1.1.33-src/jni/native/# 配置 指定 JDK 的目录并加入 SSL./configure \--prefix=/data/apr \--with-apr=/data/apr/bin/apr-1-config \--with-java-home=/data/jdk1.8.0_172 \--with-ssl=yes# 编译安装make -j 4make installwarning: remember to run 'libtool --finish /usr/local/apr/lib'libtool --finish /data/apr/lib-bash: libtool: command not foundyum -y install libtool libtool-devellibtool --finish /data/apr/lib###################################################################################################cd tomcat-native-1.2.16-src/native//data/apr/build-1/libtool --mode=install /bin/install -c -m 755 libtcnative-1.la /data/apr/liblibtool: install: /bin/install -c -m 755 .libs/libtcnative-1.so.0.2.16 /data/apr/lib/libtcnative-1.so.0.2.16libtool: install: (cd /data/apr/lib &amp;&amp; &#123; ln -s -f libtcnative-1.so.0.2.16 libtcnative-1.so.0 || &#123; rm -f libtcnative-1.so.0 &amp;&amp; ln -s libtcnative-1.so.0.2.16 libtcnative-1.so.0; &#125;; &#125;)libtool: install: (cd /data/apr/lib &amp;&amp; &#123; ln -s -f libtcnative-1.so.0.2.16 libtcnative-1.so || &#123; rm -f libtcnative-1.so &amp;&amp; ln -s libtcnative-1.so.0.2.16 libtcnative-1.so; &#125;; &#125;)libtool: install: /bin/install -c -m 755 .libs/libtcnative-1.lai /data/apr/lib/libtcnative-1.lalibtool: install: /bin/install -c -m 755 .libs/libtcnative-1.a /data/apr/lib/libtcnative-1.alibtool: install: chmod 644 /data/apr/lib/libtcnative-1.alibtool: install: ranlib /data/apr/lib/libtcnative-1.alibtool: finish: PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/data/jdk1.8.0_144/bin:/data/jdk1.8.0_144/jre/bin:/root/bin:/sbin" ldconfig -n /data/apr/lib----------------------------------------------------------------------Libraries have been installed in: /data/apr/libIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the '-LLIBDIR'flag during linking and do at least one of the following: - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the 'LD_RUN_PATH' environment variable during linking - use the '-Wl,-rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to '/etc/ld.so.conf'See any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------# 将 apr 加载到 ldconfig 中vim /etc/ld.so.conf.d/apr.conf/data/apr/lib/data/apr-util/lib/data/apr-iconv/lib# 重新加载以下 ldconfigldconfig -v | grep apr/data/apr/lib: libapr-1.so.0 -&gt; libapr-1.so.0.6.3/data/apr-util/lib: libaprutil-1.so.0 -&gt; libaprutil-1.so.0.6.1/data/apr-iconv/lib: libapriconv-1.so.0 -&gt; libapriconv-1.so.0.2.2 CentOS 6.x 安装配置 Tomcat native CentOS 6.x 会出现以下这类问题 1234checking OpenSSL library version &gt;= 1.0.2... Found OPENSSL_VERSION_NUMBER 0x1000105f (OpenSSL 1.0.1e 11 Feb 2013)Require OPENSSL_VERSION_NUMBER 0x1000200f or greater (1.0.2)configure: error: Your version of OpenSSL is not compatible with this version of tcnative OpenSSL 版本与 tcnative 版本不兼容CentOS 7.2 或以上版本不会出现这类问题需要手工安装 OpenSSL 1.0.2 或以上版本 123456789101112# 下载 OpenSSLwget -c https://www.openssl.org/source/openssl-1.0.2o.tar.gz或wget -c https://www.openssl.org/source/openssl-1.1.0h.tar.gz# 安装 OpenSSLtar -xvf openssl-1.1.0h.tar.gzcd openssl-1.1.0h./config --prefix=/usr/local/openssl./config -tmake -j 4make install 123456789101112131415161718192021222324252627282930# 将 openssl 的 lib 加入系统 ldconfig 中vim /etc/ld.so.conf.d/openssl.conf/usr/local/openssl/lib# 加载一下ldconfig -vldconfig -v | grep libssl# 查看 OpenSSL 版本/usr/local/openssl/bin/openssl version -a# 如果遇到以下错误openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directoryopenssl: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory# 是由于 OpenSSL 库的位置不正确造成的# 做一下软链接，就好了ln -svnf /usr/local/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1ln -svnf /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1# 配置环境变量vim /etc/profile.d/openssl.sh#!/bin/bashexport PATH=$PATH:/usr/local/openssl/binopenssl version -a# 或把原来的命令备份一下，做个软链接ll -h /usr/bin/opensslcp /usr/bin/openssl&#123;,_bak&#125;ln -svnf /usr/local/openssl/bin/openssl /usr/bin/openssl 有 两 种方式配置 Tomcat 使用 apr 库方式一：配置 Tomcat Native 环境变量 在 Linux 系统中，只要 $LD_LIBRARY_PATH 变量值所在路径包含 Tomcat 本地库默认就使用 org.apache.coyote.http11.Http11AprProtocol 12345vim /etc/profile.d/apr.sh#!/bin/bashexport LD_LIBRARY_PATH=/data/apr/libsource /etc/profile 方式二：将 apr 库路径参数添加到 Tomcat 系统变量中（推荐） 编辑 $CATALINA_HOME/bin/setenv.sh 文件（如果文件不存在，新建文件） 1export CATALINA_OPTS="$CATALINA_OPTS -Djava.library.path=/data/apr/lib" 修改 $TOMCAT_HOME/conf/server.xml 12345&lt;Connector port="8000" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443"protocal 修改为 org.apache.coyote.http11.Http11AprProtocol，重启 tomcat 测试 启动 Tomcat，若在控制台或日志出现类似如下示例信息则表示 APR 配置成功 1INFO: Loaded APR based Apache Tomcat Native library 1.1.33. 检查是否安装成功如果看到下面的启动日志，表示成功 123456Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["http-apr-8080"]Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["ajp-apr-8009"]Sep 17, 2017 1:59:19 PM org.apache.catalina.startup.Catalina startINFO: Server startup in 31002 ms]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat_APR_安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不通过inventory文件，指定host运行Ansible]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F05%2F%E4%B8%8D%E9%80%9A%E8%BF%87inventory%E6%96%87%E4%BB%B6%EF%BC%8C%E6%8C%87%E5%AE%9Ahost%E8%BF%90%E8%A1%8CAnsible%2F</url>
    <content type="text"><![CDATA[如何不通过 inventory 文件，直接指定 host 运行 Ansible？ 使用过 ansible 的都知道，不管是运行 Ad-Hoc 还是 playbook，都需要指定一个 inventory 文件，或者使用默认的 inventory 文件。但是现在有一个主机，它尚未在 inventory 文件中配置，那么我们该如何用 ansible 对其进行操作呢？ 一般我们执行都是这样的 12345ansible 192.168.35.215 -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125; 这时需要在 inventory 文件 /etc/ansible/hosts 中配置 192.168.35.215 信息 12[NgxProxy]192.168.35.215 如果没有在 inventory 文件中配置该主机信息，又想用 ansible 对其进行操作就需要用到逗号 , 字符，使用方法如下 123456# Host and IP addressansible all -i example.com,ansible all -i 93.184.216.119,# Requires 'hosts: all' in your playbookansible-playbook -i example.com, playbook.yml 需要注意的是，需要指定范围为 all 12345ansible all -i 192.168.35.215, -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;]]></content>
      <categories>
        <category>Ansible笔记</category>
      </categories>
      <tags>
        <tag>如何不通过 inventory 文件，直接指定 host 运行 Ansible？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客生成一个站点地图]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[给博客生成一个站点地图 安装 hexo-generator-seo-friendly-sitemap1npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件 _config.yml 中添加12sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客生成一个站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客添加feed]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[给博客添加 feed 安装 hexo-generator-feed1npm install hexo-generator-feed --save 配置到站点配置文件 _config.yml12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 最后，在你 next 主题下的 _config.yml 下，添加 RSS 订阅链接即可1rss: /atom.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客添加feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora快捷键]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FTypora%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Typora常用快捷键 功能 快捷键 新建界面窗口 Ctrl + Shift + N 新建文件 Ctrl + N 打开文件 Ctrl + O 序列表 输入-之后输入空格 序列表 输入数字+“.”之后输入空格 务列表 -[空格]空格 文字 标题 Ctrl + 数字 表格 Ctrl + t 成目录 [TOC]按回车 选中一整行 Ctrl + l 选中单词 Ctrl + d 选中相同格式的文字 Ctrl + e 跳转到文章开头 Ctrl + home 跳转到文章结尾 Ctrl + end 搜索 Ctrl + f 替换 Ctrl + h 引用 输入&gt; 后输入空格 代码块 Ctrl + Alt + f 加粗 Ctrl + b 斜体 Ctrl + i 字体 Ctrl + 数字 下划线 Ctrl + u 删除线 Alt + Shift + 5 插入图片 直接拖动到指定位置即可或Ctrl + Shift + i 插入链接 Ctrl + k]]></content>
      <categories>
        <category>Typora笔记</category>
      </categories>
      <tags>
        <tag>Typora快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安全加固心得]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F04%2FNginx%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Nginx安全加固心得 Nginx 发展多年，自身的安全漏洞比较少，发现软件漏洞，一般利用软件包管理器升级一下就好了。本文侧重讲述的不是 Nginx 自身的安全，而是利用 Nginx 来加固 Web应用，干一些应用防火墙（WAF）干的活。在做安全加固的时候，我们一定要头脑清晰，手里拿着刀，一刀一刀的切，将我们不想要的流量干掉，除去隐患。 屏蔽 IP 假设我们的网站只是一个国内小站，有着公司业务，不是靠广告生存的那种，那么可以用 Geoip 模块封杀掉除中国和美国外的所有IP。这样可以过滤大部分来自国外的恶意扫描或者无用访问。不用担心封杀了网络蜘蛛。主流的网络蜘蛛（百度/谷歌/必应/搜狗）已经包含在了我们的IP范围内了。如果是公网的登录后台，更应该屏蔽彻底一点。 123if ( $geoip_country_code !~ ^(CN|US)$ ) &#123; return 403;&#125; （很多人担心geoip库不够准确，诚然，中国城市级别的IP段会有误差，但是国家级别的IP段一般是没有问题的，并且geoip库可以随时在线更新） 封杀各种 user-agent user-agent 也即浏览器标识，每个正常的web请求都包含用户的浏览器信息，除非经过伪装，恶意扫描工具一般都会在user-agent里留下某些特征字眼，比如 scan，nmap 等。我们可以用正则匹配这些字眼，从而达到过滤的目的，请根据需要调整。 123456if ($http_user_agent ~* "java|python|perl|ruby|curl|bash|echo|uname|base64|decode|md5sum|select|concat|httprequest|httpclient|nmap|scan" ) &#123; return 403;&#125;if ($http_user_agent ~* "" ) &#123; return 403;&#125; 这里分析得不够细致，具体的非法 user-agent 还得慢慢从日志中逐个提取。通过上面两个大招，相信你的日志里很快就会有大量的 403 记录。，我们接着干。如果网站提供公共 api，注意与开发者约定好 UA，防止撞墙 封杀特定的 URL 特定的文件扩展名，比如 .bak 123location ~* \.(bak|save|sh|sql|mdb|svn|git|old)$ &#123; rewrite ^/(.*)$ $host permanent;&#125; 知名程序，比如 phpmyadmin 123location /(admin|phpadmin|status) &#123; deny all; &#125; 封杀特定的 http 方法和行为，比如 123456if ($request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 405;&#125;if ($http_range ~ "\d&#123;9,&#125;") &#123; return 444;&#125; 强制网站使用域名访问，可以逃过IP扫描，比如123if ( $host !~* 'abc.com' ) &#123; return 403;&#125; url 参数过滤敏感字，比如1234567if ($query_string ~* "union.*select.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; if ($query_string ~* "concat.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; 强制要求referer123if ($http_referer = "" ) ｛ return 403;｝ 如果不想用403，也可以rewrite一个url，比如一个400页面 123456&lt;html&gt; &lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor="white"&gt; &lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx/1.2.0&lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 小结 可以将上述规则结合起来使用，同时匹配多条规则时才会封杀，下面是一个来自老外的稍微复杂一点的例子： 123456789101112131415set $add 1; location /index.php &#123; limit_except GET POST &#123; deny all; &#125; set $ban ""; if ($http_referer = "" ) &#123;set $ban $ban$add;&#125; if ($request_method = POST ) &#123;set $ban $ban$add;&#125; if ($query_string = "action=login" )&#123;set $ban $ban$add;&#125; if ($ban = 111 ) &#123; access_log /var/log/[133]nginx/ban IP; return 404; &#125; proxy_pass http://127.0.0.1:8000; #here is a patch &#125; 其它方法 封杀IP 定时做日志分析，手动将恶意IP加入 iptables 拒绝名单，推荐使用 ipset 模块。 12yum install -y ipset ipset-serviceipset create badip hash:net maxelem 65535iptables -I INPUT -m set --match-set badip src -p tcp --dport 80 -j DROP/etc/init.d/iptables saveipset add badip 1.1.1.2ipset add badip 2.2.2.0/24/etc/init.d/ipset save ipset 还支持 timeout，类似 redis 的 TTL，timeout 之后会自动删除，比较人性化。比如下面的例子就是 timeout 默认 3600 秒，支持自定义 timeout 12ipset destroy badipipset create badip hash:net maxelem 65535 timeout 3600ipset add badip 1.1.1.1ipset add badip 2.2.2.0/24 timeout 60ipset add badip 3.3.3.0/24 timeout 7200 在日志分析的自动化程度比较高，准确率比较好的情况下，可以考虑通过条件触发 ipset。 限速 适当限制客户端的请求带宽，请求频率，请求连接数，这里不展开论述。根据具体需求，阀值应当稍稍宽泛一点。特别要注意办公室/网吧场景的用户，他们的特点是多人使用同一个网络出口。 目录只读 如果没有上传需求，完全可以把网站根目录弄成只读的，加固安全。做了一点小动作，给网站根目录搞了一个只读的挂载点。这里假设网站根目录为 /var/www/html 1234mkdir -pv /datamkdir -pv /var/www/htmlmount --bind /data /var/www/htmlmount -o remount,ro --bind /data /var/www/html 网站内容实际位于/data，网站内容更新就往/data里更新，目录/var/www/html无法执行任何写操作，否则会报错“Read-only file system”，极大程度上可以防止提权篡改。 overlayfs 这种方法跟上面的方法类似，但是有所区别假设网站根目录/var/www/html有一个目录upload是要求可读写的，其他只读即可，那么仔细看下面的操作 123456mkdir -pv /data/lowermkdir -pv /data/uppermkdir -pv /data/workermv /var/www/html/upload /data/upper/mv /var/www/html/* /data/lower/mount -t overlayfs overlay -o lower=/data/lower,upper=/data/upper,workdir=/data/worker /var/www/html 这样就完美实现了读写分离，底层目录只读，上层目录可写。如果程序被篡改，上层目录 /data/upper 除了 upload 内容之外，还会生成其他文件。overlayfs 因为特殊的机制，建议使用 Linux 内核4.0+，否则比较消耗硬盘的 inode。 定时总结和丰富过滤规则]]></content>
      <categories>
        <category>Nginx笔记</category>
      </categories>
      <tags>
        <tag>Nginx安全加固心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置阅读全文]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FNext%E8%AE%BE%E7%BD%AE%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[如何设置「阅读全文」？ 在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。NexT 提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在 主题配置文件 中添加： 123auto_excerpt: enable: true # 改成 true length: 150 # 默认展示的高度 默认截取的长度为 150 字符，可以根据需要自行设定建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外，这种方式也可以让 Hexo 中的插件更好的识别。 需要注意的是，点击「阅读全文」之后，文章会自动定位到 所在位置，想要修改成从头阅读需要修改 主题配置文件 _config.yml 文件： 12# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: false]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置阅读全文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next开启站内搜索]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FNext%E5%BC%80%E5%90%AF%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[Next 如何开启站内搜索？ NexT 主题支持集成 Swiftype、微搜索、Local Search 和 Algolia,Swiftype 和 Algolia 都只有一段时间的试用期，可以采用 Hexo 提供的Local Search，原理是通过 hexo-generator-search 插件在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 Local Search 由 flashlab 贡献 安装步骤安装 hexo-generator-search 在站点的根目录下执行以下命令 1npm install hexo-generator-search --save 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令1npm install hexo-generator-searchdb --save 启用搜索 编辑 站点配置 文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置 文件，启用本地搜索功能 123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next开启站内搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Hexo 简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 安装 进入 D:\Blog\gmlyo\ 自定义目录，右键鼠标，点击 Git Bash Here，输入 npm 命令即可安装 12345678910111213141516右击 Git Bash Herecd /d/Blog/gmlyo/npm install hexo -g 或 npm install hexo-cli -ghexo init 或 hexo init blog; cd blog/# 第一句是安装 hexo# 第二句是安装 hexo 部署到 git page 的 deployer# 两个都需要安装# Hexo 初始化配置（有点漫长的等待。。。）npm initHexo 初始化完成后，Hexo 将会在指定文件夹中新建所需要的文件hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # 或 hexo generatehexo s # 或 hexo server 可以在打开浏览器访问 http://localhost:4000/ 查看 查看 hexo 版本信息12345678910111213141516171819# 查看 hexo 版本信息hexo -vhexo: 3.7.1hexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64http_parser: 2.8.0node: 10.3.0v8: 6.6.346.32-node.9uv: 1.20.3zlib: 1.2.11ares: 1.14.0modules: 64nghttp2: 1.29.0napi: 3openssl: 1.1.0hicu: 61.1unicode: 10.0cldr: 33.0tz: 2018c 常用 Hexo 命令123456# 生成静态文件，会在当前目录下生成一个新的叫做 public 的文件夹hexo generate (hexo g)# 启动本地 Web 服务，用于博客的预览hexo server (hexo s)# 部署播客到远端（比如github, heroku等平台）hexo deploy (hexo d) 其他常用命令12hexo new "postName" # 新建文章hexo new page "pageName" # 新建页面 常用简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 常用组合12hexo d -g # 生成部署hexo s -g # 生成预览]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kickstart自动应答文件]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FKickstart%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Kickstart 自动应答文件 Cobbler vim /var/lib/cobbler/kickstarts/centos7.5-ks.cfg1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Cobbler for Kickstart Configurator for CentOS 7 by clsninstallurl --url=$treetextlang en_US.UTF-8keyboard uszerombrbootloader --location=mbr --driveorder=sda --append="crashkernel=auto rhgb quiet"#Network information$SNIPPET('network_config')#network --bootproto=dhcp --device=eth0 --onboot=yes --noipv6 --hostname=CentOS7timezone --utc Asia/Shanghaiauthconfig --enableshadow --passalgo=sha512rootpw --iscrypted $default_password_cryptedclearpart --all --initlabel# Disk partitioning informationpart pv.374 --fstype="lvmpv" --ondisk=sda --size=2052part pv.671 --fstype="lvmpv" --ondisk=sda --size=20484part pv.639 --fstype="lvmpv" --ondisk=sda --size=1 --growpart /boot --fstype="xfs" --ondisk=sda --size=500volgroup vgswap --pesize=4096 pv.374volgroup vgroot --pesize=4096 pv.671volgroup vgdata --pesize=4096 pv.639logvol / --fstype="xfs" --size=20480 --name=lvroot --vgname=vgrootlogvol swap --fstype="swap" --size=2048 --name=lvswap --vgname=vgswaplogvol /data --fstype="xfs" --size=1 --grow --name=lvdata --vgname=vgdatafirstboot --disableselinux --disabledfirewall --disabledlogging --level=inforeboot%pre$SNIPPET('log_ks_pre')$SNIPPET('kickstart_start')$SNIPPET('pre_install_network_config')# Enable installation monitoring$SNIPPET('pre_anamon')%end%packages@^minimal@compat-libraries@core@debugging@developmentbash-completionchronydos2unixkexec-toolslrzsznmapsysstattelnettreevimwgetnet-tools%end%postsystemctl disable postfix.service%end]]></content>
      <categories>
        <category>Cobbler笔记</category>
      </categories>
      <tags>
        <tag>Kickstart自动应答文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 绑定自定义域名]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[如何将自己购买的域名连接到 Github Pages？ 12345678在 source 目录下新建 CNAME 文件，在首行添加网站域名如：www.gmlyo.com注意前面没有 https://，http:// 等信息，然后重新重新生成并部署站点hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # hexo generadehexo d # hexo deploy或hexo d -g 设置域名解析1234561、先添加一个CNAME，主机记录写@，后面记录值写上你的 xxx.github.io2、再添加一个CNAME，主机记录写www，后面记录值也是 xxx.github.io这样别人用 www 和不用 www 都能访问你的网站其实 www 的方式，会先解析成 https://xxx.github.io，然后根据 CNAME 再变成 http://www.gmlyo.com，即中间是经过一次转换的。注：除了使用 CNAME 记录也有人使用 A 记录，后面的记录值是写 Github Page 里面的 IP 地址，但有时候 IP 地址会更改，导致最后解析不正确，所以还是推荐用 CNAME 别名记录要好些，不建议用 IP。3、等待10分钟左右，域名生效后刷新浏览器，使用自定义域名访问网站即可 Hexo 部署后，CNAME 会被自动删除，如何解决？123将需要上传至 Github 的文件放在 source 目录下如：CNAME, README.md, favicon.ico, images 目录等将这些都放在 source 目录下，每次上传就不会消失了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 绑定自定义域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 删除文章]]></title>
    <url>%2F%2Fblog%2F2018%2F06%2F03%2FHexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hexo 如何删除文章？ 1234567891011删除文章的过程很简单，先删除本地文件，然后通过生成和部署命令将远程仓库中的文件也一并删除。以最开始默认形成的 hello-world.md 这篇文章为例首先进入 D:\Blog\gmlyo\source\_posts\ 文件夹中找到 hello-world.md 文件，在本地直接执行删除。然后依次执行hexo cleanhexo ghexo d再去主页查看就会发现博客上面已经什么都没有了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 删除文章</tag>
      </tags>
  </entry>
</search>
