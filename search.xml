<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Next 解决 Busuanzi 统计浏览失效]]></title>
    <url>%2F2018%2F12%2F02%2FNext-%E8%A7%A3%E5%86%B3-Busuanzi-%E7%BB%9F%E8%AE%A1%E6%B5%8F%E8%A7%88%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[Hexo Next 解决 Busuanzi 统计浏览失效 由于 busuanzi（不蒜子）的网址更新，导致了使用 Hexo Next 主题时统计浏览数失效。 不蒜子官网http://ibruce.info/2015/04/04/busuanzi/ 解决方法到 hexo 的 themes 目录下进入 1cd themes/next/layout/_third-party/analytics/ 打开 busuanzi-counter.swig将1src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" 修改为1src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" 参考文档https://blog.csdn.net/ddydavie/article/details/83020549]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next 解决 Busuanzi 统计浏览失效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志统计常用技巧]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[日志统计常用技巧 按时间截取 截取指定时间段日志 1sed -n '/^2018-10-29 14:30/,/^2018-10-29 14:32/p' server.log | more 按标识截取 截取特定标识日志的内容（仅特定标识日志行、或标识附近日志行）过滤包含特定标识（忽略大小写）的日志、并显示前后 10 行 12345grep -i -A 10 -B 10 "error" access.log | moregrep -i -A 10 -B 10 "error" access.log &gt; access_error.txtgrep -i -C 10 "error" access.log | moregrep -i -C 10 "error" access.log &gt; access_error.txt 按指定列截取 截取第7列为 ‘/test’ 的行 1cat access.log | awk 'if($7=="/test"&#123;print $0&#125;' | more 日志统计 分时访问量统计对日志中的时间列进行拆分，根据时间格式取 YYYY-mm-DD HH:MM 部分、进行排序、汇总，即可获得每分钟的访问量统计。 按分钟汇总统计访问量1cat access.log | grep "^2012-" | awk -F\: '&#123;print $1" "$2":"$3&#125;' | sort | uniq -c | more 按小时汇总统计访问量1cat access.log | grep "^2012-" | awk -F\: '&#123;print $1" "$2"&#125;' | sort | uniq -c | more 日志中的 IP 地址 Web服务器日志(Nginx)中，通常第一列为客户端IP地址，取该段值进行排序、汇总，即可得到IP:访问次数的统计。 从日志中统计 IP 访问次数1cat access.log | awk '&#123;print $1&#125;' | sort | uniq -c | more 统计来访唯一 IP 数1cat access.log | awk '&#123;print $1&#125;' | sort | uniq | wc -l 网络连接状态netstat 命令可获取系统当前的侦听、连接状态，包括协议、源IP:端口、目标IP:端口、连接状态信息，取关注的列进行排序、汇总，即可获得连接数、状态等统计。 TCP连接数1234567netstat -antp | grep ^tcp | awk '&#123;print $5&#125;' | awk -F\: '&#123;print $1&#125;' | sort | uniq -c | sort -nr 5 0.0.0.0 2 192.217.199.215 1 91.189.89.144 1 172.16.17.4 1 172.16.17.3 1 172.16.17.27 TCP 连接状态1234netstat -antp | grep ^tcp | awk '&#123;print $6&#125;' | sort | uniq -c | sort -nr 17 ESTABLISHED 8 LISTEN 1 CLOSE_WAIT 使用 awk 的正则匹配进行过滤，减少前面的 grep 指令不过 grep 的过滤处理速度似乎比 awk 的正则匹配速度更快，因此对大日志分析时可能还是先用 grep 过滤效率更高 123456789101112131415161718192021time cat netstat.txt | awk '/^tcp/ &#123;print $6&#125;' | sort | uniq -c | sort -nr 2713 TIME_WAIT 203 ESTABLISHED 29 FIN_WAIT1 18 LISTEN 17 FIN_WAIT2real 0m0.017suser 0m0.014ssys 0m0.002stime cat netstat.txt | grep ^tcp | awk '&#123;print $6&#125;' | sort | uniq -c | sort -nr 2713 TIME_WAIT 203 ESTABLISHED 29 FIN_WAIT1 18 LISTEN 17 FIN_WAIT2real 0m0.008suser 0m0.005ssys 0m0.001s 其他 awk 匹配方式12345678910111213cat netstat.txt | awk '&#123;if($1=="tcp")print $6&#125;' | sort | uniq -c | sort -nr 2713 TIME_WAIT 203 ESTABLISHED 29 FIN_WAIT1 18 LISTEN 17 FIN_WAIT2cat netstat.txt | awk '$1=="tcp" &#123;print $6&#125;' | sort | uniq -c | sort -nr 2713 TIME_WAIT 203 ESTABLISHED 29 FIN_WAIT1 18 LISTEN 17 FIN_WAIT2 多条件匹配1234567891011121314151617181920212223242526272829303132333435cat netstat.txt | awk '/^tcp|^udp/ &#123;print $1"-"$6&#125;' | sort | uniq -c | sort -nr 2713 tcp-TIME_WAIT 203 tcp-ESTABLISHED 29 tcp-FIN_WAIT1 18 tcp-LISTEN 17 tcp-FIN_WAIT2 4 udp-32366/rpcbind 4 udp-- 3 udp-32526/rpc.statd 2 udp-19339/rpc.mountd 1 udp-ESTABLISHED 1 udp-38143/gmond 1 udp-19335/rpc.rquotad 1 udp-1282/portreservecat netstat.txt | awk '&#123;if($1~"^tcp" || $1~"^udp")print $1"-"$6&#125;' | sort | uniq -c | sort -nr 2713 tcp-TIME_WAIT 203 tcp-ESTABLISHED 29 tcp-FIN_WAIT1 18 tcp-LISTEN 17 tcp-FIN_WAIT2 4 udp-32366/rpcbind 4 udp-- 3 udp-32526/rpc.statd 2 udp-19339/rpc.mountd 1 udp-ESTABLISHED 1 udp-38143/gmond 1 udp-19335/rpc.rquotad 1 udp-1282/portreservecat netstat.txt | awk '&#123;if($1=="tcp" &amp;&amp; $6!~"ESTABLISHED")print $6&#125;' | sort | uniq -c | sort -nr 2713 TIME_WAIT 29 FIN_WAIT1 18 LISTEN 17 FIN_WAIT2 示例示例一 扫描 gz 压缩文件，从中寻找带有 dianping_reply 的行，将改行按照[进行拆分，然后直接使用if条件进行判断，比较，最终输出想要的结果。 1zcat access.log.tar.gz | grep 'dianping_reply.log' | awk '&#123;split($4,array,"[");if(array[2]&gt;="29/May/2016:00:00:26" &amp;&amp; array[2]&lt;="29/May/2016:00:01:14")&#123;print $0&#125;&#125;' 命令解释zcat 直接读取压缩文件的内容grep 过滤特定字符的行awk 用于执行命令split 用于切分字符串 示例二 过滤 22/Feb/2017-18:52:59 之前的日志 123456789test.log[22/Feb/2017-18:51:58] api.momo.com /api/feed HTTP/1.1 121.0.0.1 android1.2[22/Feb/2017-18:51:59] api.momo.com /api/follow HTTP/1.1 121.0.0.2 iphone1.1[22/Feb/2017-18:52:58] api.momo.com /api/user HTTP/1.1 121.0.0.3 iphone1.1[22/Feb/2017-18:52:41] api.momo.com /api/feed HTTP/1.1 121.0.0.4 android1.2[22/Feb/2017-18:56:30] api.momo.com /api/follow HTTP/1.1 121.0.0.2 android1.2[22/Feb/2017-18:51:21] api.momo.com /api/user HTTP/1.1 121.0.0.3 iphone1.1[22/Feb/2017-18:59:58] api.momo.com /api/user HTTP/1.1 121.0.0.3 android1.2[22/Feb/2017-18:51:21] api.momo.com /api/feed HTTP/1.1 121.0.0.1 iphone1.1 1cat test.log | awk '&#123;split($1,array,"[");split(array[2],array2,"]");if(array2[1] &gt;= "22/Feb/2017-18:52:59")&#123;print($0)&#125;&#125;' 参考文档http://xstarcd.github.io/wiki/shell/logview_tips.html]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>日志统计常用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 按时间截取日志]]></title>
    <url>%2F2018%2F10%2F29%2FShell-%E6%8C%89%E6%97%B6%E9%97%B4%E6%88%AA%E5%8F%96%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[Shell 按时间截取日志截取查看某时间段内的日志 sed 截取 精确到 时分秒 1sed -n '/2018-10-22|10:23:44/,/2018-10-22|11:23:44/' access.log &gt; 10-11_access.log 精确到小时 1sed -n '/2018-10-22|10/,/2018-10-22|11/' access.log &gt; 10-11_access.log sed -n &#39;/开始时间/,/结束时间/&#39; 被截取日志原文件 &gt; 截取后日志新文件$p 显示到最后一行 1234# 查看某时间段到当前的 messages 系统日志sed -n '/May 20 17/,$p' /var/log/messages | lesssed -n '/2018-10-29 09:00:00/,$p' access.log &gt; /tmp/access.log sed 截取 10:00:00 到 现在的 catalina.out 日志内容 1sed -n '/2018-04-11 10:[0-9][0-9]:[0-9][0-9]/,$p' catalina.out | less sed 截取 2018-04-11 这天 到 现在的 catalina.out 日志内容 1sed -n '/2018-04-11 [0-9][0-9]:[0-9][0-9]:[0-9][0-9]/,$p' catalina.out | less sed 截取 2018-03-14 09:00:00 2018-03-14 12:00:00 的日志 1sed -n '/2018-03-14 09:[0][0]:[0][0]/,/2018-03-14 12:[0][0]:[0][0]/p' catalina.out &gt; /tmp/catalina.log grep 截取 egrep 截取 13:38 到 14:00 之间的日志内容 1egrep '13:3[8-9]:[0-9][0-9]|13:[4-5][0-9]:[0-9][0-9]' catalina.out | less egrep 截取 2018-04-11 到 2018-04-12 之间的日志内容 1egrep '2018-04-11 [0-9][0-9]:[0-9][0-9]:[0-9][0-9]|2018-04-12 [0-9][0-9]:[0-9][0-9]:[0-9][0-9]' catalina.out | less 截取 Nginx 访问日志 查看 21/Jul/2014:14:37:50 到 21/Jul/2014:14:38:00 时间段内 access.log 的访问日志 1cat access.log | awk '$4 &gt;="[21/Jul/2014:14:37:50" &amp;&amp; $4 &lt;="[21/Jul/2014:14:38:00"' 时间转换在线工具地址https://tool.lu/timestamp/]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell 按时间截取日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换]]></title>
    <url>%2F2018%2F10%2F24%2FPython-%E8%AF%A6%E8%A7%A3time%E6%A8%A1%E5%9D%97%E4%B8%ADUTC%E4%B8%96%E7%95%8C%E6%97%B6%E9%97%B4%E3%80%81%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%89%E8%80%85%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换 本地时间 转换 为时间戳123456789101112import timeimport pytzimport datetimedate_=datetime.datetime(2018,6,19,20,55,00)timestamp2=time.mktime(date_.timetuple()) # date_.timetuple() 将datetime 格式的转化为 time 模块的 tuple 格式print(timestamp2)# 时间戳转换为本地时间ltime=time.localtime(1529112900) #time.struct_time(tm_year=2018, tm_mon=6, tm_mday=16, tm_hour=9, tm_min=35, tm_sec=0, tm_wday=5, tm_yday=167, tm_isdst=0)timeStr=time.strftime("%Y-%m-%d %H:%M:%S", ltime)print(timeStr) UTCS 时间转换为时间戳 2018-07-13T16:00:00Z123456789def utc_to_local(utc_time_str, utc_format='%Y-%m-%dT%H:%M:%SZ'): local_tz = pytz.timezone('Asia/Chongqing') # 定义本地时区 local_format = "%Y-%m-%d %H:%M:%S" # 定义本地时间format utc_dt = datetime.datetime.strptime(utc_time_str, utc_format) # 讲世界时间的格式转化为 datetime.datetime 格式 local_dt = utc_dt.replace(tzinfo=pytz.utc).astimezone(local_tz) # 想将 datetime 格式添加上世界时区，然后 astimezone 切换时区：世界时区 ==&gt; 本地时区 # time_str = local_dt.strftime(local_format) # 将 datetime 格式转化为 str—format 格式 # return int(time.mktime(time.strptime(time_str, local_format))) # 运用 mktime 方法将 date—tuple 格式的时间转化为时间戳; time.strptime() 可以得到 tuple 的时间格式 return int(time.mktime(local_dt.timetuple())) # 返回当地时间戳 本地时间转换为 UTC 传入的本地时间戳 1531411200123456789101112def local_to_utc(local_ts, utc_format='%Y-%m-%dT%H:%MZ'): local_tz = pytz.timezone('Asia/Chongqing') # 定义本地时区 local_format = "%Y-%m-%d %H:%M:%S" # 定义本地时间 format time_str = time.strftime(local_format, time.localtime(local_ts)) # 首先将本地时间戳转化为时间元组，用 strftime 格式化成字符串 dt = datetime.datetime.strptime(time_str, local_format) # 将字符串用 strptime 转为为 datetime 中 datetime 格式 local_dt = local_tz.localize(dt, is_dst=None) # 给时间添加时区，等价于 dt.replace(tzinfo=pytz.timezone('Asia/Chongqing')) utc_dt = local_dt.astimezone(pytz.utc) # astimezone 切换时区 return utc_dt.strftime(utc_format) # 返回世界时间格式print(utc_to_local('2018-07-13T16:00:00Z', utc_format='%Y-%m-%dT%H:%M:%SZ'))print(local_to_utc(1531411200, utc_format='%Y-%m-%dT%H:%MZ')) 123456'''1529412900.02018-06-16 09:35:0015314976002018-07-12T16:00Z''' 参考文档https://blog.csdn.net/brucewong0516/article/details/81100242]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 详解time模块中 UTC世界时间、时间戳、字符串三者的转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 软件开发的目录规范]]></title>
    <url>%2F2018%2F09%2F24%2FPython-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Python 软件开发的目录规范 目录规范项目目录规范 bin 存放执行文件，整个程序的入口文件，比如启动功能conf 配置文件lib 存放自定义的共享库，经常使用的一些功能core 存放整个代码程序的核心逻辑db 存放数据库相关的log 日志相关的Readme 记录整个项目的描述信息 项目文件规范 src.py12345678910111213141516171819202122232425262728293031323334def register(): print('注册。。。')def pay(): print('支付。。。')def transfer(): print('转账。。。')def withdraw(): print('提现。。。')func_dic = &#123; '1': register, '2': pay, '3': transfer, '4': withdraw&#125;# 核心功能，和用户交互def run(): while True: print(""" 1 注册 2 支付 3 转账 4 提现 """) choice = input('&gt;&gt;&gt;: ').strip() if choice in func_dic: func_dic[choice]() else: print('输入错误指令') 获取项目根路径 强调：只有被导入的模块才能使用 . 或 .. 的语法编辑 start.py123import syssys.path.append(r'E:\Project\core') 这样写会有问题，在程序给别人使用时，别人的路径不可能和程序开发者的目录路径一样 改进 __file__ 表示当前文件的绝对路径abspath() 规范路径格式1234567891011import sysimport osprint(__file__)print(os.path.abspath(__file__))# sys.path.append(r'E:\Project\core')# os.path.dirname()# 执行结果E:/Project/bin/start.pyE:\Project\bin\start.py 123456789import sysimport osprint(os.path.dirname(os.path.abspath(__file__)))print(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))# 执行结果E:\Project\binE:\Project 123456789101112import sysimport osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.append(BASE_DIR)from core import srcif __name__ == '__main__': src.run()# 执行结果 获取 db 目录文件的路径 编辑 setting.py123456789import osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))DB_PATH = '%s\%s\%s' % (BASE_DIR, 'db', 'db.txt')print(DB_PATH)# 执行结果E:\Project\db\db.txt 这种拼接方式有缺陷，如果是 Linux 系统，\ 右斜杠就不能用了 解决跨平台路径格式的问题 使用 os.path.join123456789import osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))DB_PATH = os.path.join(BASE_DIR, 'db', 'db.txt')print(DB_PATH)# 执行结果E:\Project\db\db.txt Linux 系统输出格式123456789import osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))DB_PATH = os.path.join(BASE_DIR, 'db', 'db.txt')print(DB_PATH)# 执行结果/data/Project/db/db.txt 获取 log 目录路径 编辑 settings.py 123456LOG_PATH = os.path.join(BASE_DIR, 'log', 'access.log')print(LOG_PATH)# 执行结果E:\Project\log\access.log 项目目录规范示例项目名/core/src.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546from conf import settingsfrom lib import commondef register(): print('注册。。。') uname = input('用户名：').strip() pwd = input('密码：').strip() with open(settings.DB_PATH, 'a', encoding='utf-8') as f: f.write('%s:%s\n' % (uname, pwd)) common.logger(uname) print('注册成功')def pay(): print('支付。。。')def transfer(): print('转账。。。')def withdraw(): print('提现。。。')func_dic = &#123; '1': register, '2': pay, '3': transfer, '4': withdraw&#125;# 核心功能，和用户交互def run(): while True: print(""" 1 注册 2 支付 3 转账 4 提现 按 q 退出 """) choice = input('请选择相应的操作: ').strip() if choice == 'q': break if choice not in func_dic: print('输入错误指令，请重新输入') continue func_dic[choice]() 项目名/conf/settings.py12345import osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))DB_PATH = os.path.join(BASE_DIR, 'db', 'db.txt')LOG_PATH = os.path.join(BASE_DIR, 'log', 'access.log') 项目名/lib/common.py12345678from conf import settingsimport time# print(time.strftime('%Y-%m-%d %X'))def logger(msg): with open(settings.LOG_PATH, 'a', encoding='utf-8') as f: f.write('%s, %s, 注册成功\n' % (time.strftime('%Y-%m-%d %X', time.localtime()), msg)) 项目名/bin/start.py12345678910import sysimport osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.append(BASE_DIR)from core import srcif __name__ == '__main__': src.run() 运行 start.py 12345cat db.txtegon:123tail access.log2018-09-24 01:08:11, egon, 注册成功]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 软件开发的目录规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 模块的使用]]></title>
    <url>%2F2018%2F09%2F23%2FPython-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python 模块的使用 模块介绍什么是模块？模块就是一组功能的集合体，我们的程序可以导入模块来复用模块里的功能。模块分为三大类： 自定义模块 内置模块：time, sys 等 第三方模块 常见的场景一个模块就是一个包含了一组功能的 python 文件，比如 spam.py，模块名为 spam，可以通过 import spam 使用。 模块四种表现形式在 Python 中，模块的使用方式都是一样的，但其实细说的话，模块可以分为四个通用类别 使用 Python 编写的 .py 文件 已被编译为共享库或 DLL 的 C 或 C++ 扩展 把一系列模块组织到一起的文件夹（注：文件夹下有一个 __init__.py 文件，该文件夹称之为包） 使用 C 编写并链接到 python 解释器的内置模块 12345678import timeprint(time)import sysprint(sys)# 执行结果&lt;module 'time' (built-in)&gt;&lt;module 'sys' (built-in)&gt; 为什么要用模块？ 可以将程序中频繁使用的一些公共功能可以拿内置的、第三方的模块，然后直接使用，这种拿来主义，可以极大地提高开发效率 将程序中公用的一些功能组织到一个文件中，然后程序各部分组件可以重用该文件中的功能 优点：减少代码冗余，增强程序的组织结构性与可维护性 如何使用模块？ 被导入的文件123456789101112131415vim spam.pyprint('from the spam.py')money = 1000def read1(): print('spam模块：', money)def read2(): print('spam模块') read1()def change(): global money money = 0 执行文件 123456vim run.pyimport spam# 执行结果from the spam.py 导入模块：import 模块名首次导入模块都发生了哪些事？ 先产生一个模块的名称空间 会执行模块文件的代码，将产生的名字放到模块的名称空间中 会在当前名称空间中拿到一个模块名，该模块名指向模块的名称空间 示例1 123456789101112131415# 如何使用模块？import spam# 模块名.名字，是在向模块的名称空间中拿名字print(spam.money)print(spam.read1)print(spam.read2)print(spam.change)# 执行结果from the spam.py1000&lt;function read1 at 0x000002629B29B6A8&gt;&lt;function read2 at 0x000002629B29B620&gt;&lt;function change at 0x000002629B29B840&gt; 12345678import spammoney = 0print(spam.money)# 执行结果from the spam.py1000 示例2 123456789101112131415vim spam.py# print('from the spam.py')money = 1000def read1(): print('spam模块：', money)def read2(): print('spam模块') read1()def change(): global money money = 0 1234567891011121314import spamspam.read1()# 执行结果spam模块： 1000############################################################################import spam# 凡是来自于 spam 名称空间中的功能，执行时都是模块自己的名称空间为准的money = 0spam.read1()# 执行结果spam模块： 1000 示例3 观察 spam.py 里的 change() 12345import spammoney = 1111111111111111111111spam.change()print(money) 12345678import spammoney = 1111111111111111111111spam.change()spam.read1()# 执行结果spam模块： 0 示例4 123456789101112import spammoney = 1111111111111111111111def read1(): print('run.py read1')spam.read2()# 执行结果spam模块spam模块： 1000 import 导入模块的方式，在引用模块名称空间中改名字时，必须加上前缀：模块名.名字优点：指定前缀地访问模块名称空间中的名字，不会与当前名称空间中名字冲突缺点：每次引用模块名称空间中的名字都需要加上前缀，模块名过长时，前缀会显得非常臃肿 起别名可以缩短 模块名.名字 的长度1234# 起别名方式import spam as smprint(sm.money) 模块用逗号分隔，一次导入多个模块1import spam, os, time 推荐多行导入123import spamimport osimport time from...import... 导入模块 可以在调用模块名称空间中的名字时，不需要在名字前加前缀模块名 123456x = 1y = 2from spam import money# 执行结果from the spam.py from...import...首次导入模块都发生了哪些事？ 先产生一个模块的名称空间 会执行模块文件的代码，将产生的名字放到模块的名称空间中 会在当前名称空间中直接拿到一个模块名称空间中的名字 12345678x = 1y = 2from spam import moneyprint(money)# 执行结果1000 12345678910111213x = 1y = 2from spam import money, read1, read2# 使用：可以不用加前缀直接使用print(money)print(read1)print(read2)# 执行结果1000&lt;function read1 at 0x000002384886B6A8&gt;&lt;function read2 at 0x000002384886B620&gt; 使用：可以不用加前缀直接使用优点：简洁缺点：容易与当前名称空间中的名字冲突 强调：来自于模块名称空间中的函数一定是模块的名称空间为准的 12345678910x = 1y = 2from spam import money, read1, read2, changemoney = 1change()print(money)# 执行结果1 12345678910x = 1y = 2from spam import money, read1, read2, changemoney = 1change()read1()# 执行结果spam模块： 0 模块名称空间里的名字可以不用一个个导入但是不推荐使用 &#39;*&#39;，因为不知道会导入哪些功能名字，最好需要哪一个导入哪一个，这样比较清楚123456789101112from spam import *print(money)print(read1)print(read2)print(change)# 执行结果1000&lt;function read1 at 0x000001F14E00B6A8&gt;&lt;function read2 at 0x000001F14E00B620&gt;&lt;function change at 0x000001F14E00B840&gt; 起别名12345from spam import money as mprint(m)# 执行结果1000 控制 &#39;*&#39; 所导入的名字 123vim spam.py__all__ = ['money', 'read1'] # 控制的就是 '*' 所导入的名字...省略... 123456789101112131415from spam import *print(money, read1)# 执行结果1000 &lt;function read1 at 0x000002035A6DB8C8&gt;###############################################################################from spam import *print(money, read1)print(read2)# 执行结果NameError: name 'read2' is not defined 模块的嵌套（循环）导入 在 Python 中，一个模块凡是被导入过一次，下一次导入就会直接引用上一次导入的结果，即不会重新执行模块的文件 1234vim m1.pyprint('正在导入m1')from m2 import yx = 'm1' 1234vim m2.pyprint('正在导入m2')from m1 import xy = 'm2' 1234567891011vim run.pyimport m1# 执行结果正在导入m1Traceback (most recent call last):正在导入m2 import m1 from m2 import y from m1 import xImportError: cannot import name 'x' from 'm1' 以上代码执行过程 先运行 run.py，产生 run.py 的名称空间，开始运行 run.py 里的代码。 运行到 import m1 这行代码时，会产生一个 m1 的名称空间，开始运行 m1.py 里的代码。 运行到 from m2 import y 会发现需要导入 m2，会产生一个 m2 的名称空间，开始运行 m2.py 里的代码，但是 m1.py 里的代码 还没有完全运行完。 m2.py 里需要 from m1 import x 导入 m1 里的 x，需要导入 m1。 此时会产生一个问题，m1 已经被导入过了，此时不会再执行 m1 里的代码了，它只会直接引用 m1 的名称空间，直接向这个名称空间寻求 x，然而 m1 的名称空间中并没有 x。 解决方法1 1234vim m1.pyprint('正在导入m1')x = 'm1'from m2 import y 1234vim m2.pyprint('正在导入m2')y = 'm2'from m1 import x 123456vim run.pyimport m1# 执行结果正在导入m1正在导入m2 解决方法：把名字放在导入模块代码的上面，保证在导入之前先产生名字 先运行 run.py，产生 run.py 的名称空间，开始运行 run.py 里的代码。 运行到 import m1 代码，产生一个 m1 的名称空间，开始运行 m1.py 里的代码，把 x=&#39;m1&#39; 放进去 运行到 from m2 import y 代码，需要导入 m2，产生一个 m2 的名称空间，开始运行 m2.py 里的代码，造一个 y=&#39;m2&#39;，然后运行到 from m1 import x 代码，需要导入 m1，m1 名称空间已经存在，寻求 x，此时寻找到了 x 解决方法2（推荐） 写代码尽量避免循环导入如果必须面对这种场景，可以使用第三个模块把共享的模块做统一导入 解决方法3 示例一 12345678vim m1.pyprint('正在导入m1')def f1(): from m2 import y print(y)x = 'm1' 12345678vim m2.pyprint('正在导入m2')def f2(): from m1 import x print(x)y = 'm2' 123456789vim run.pyimport m1m1.f1()# 执行结果正在导入m1正在导入m2m2 解决思路定义函数时，只检测语法，不执行代码在哪个函数中使用，就在哪个函数当中去 import 导入运行 run.py，产生 run.py 的名称空间，开始运行 run.py 里的代码。运行到 import m1 代码，产生一个 m1 的名称空间，开始运行 m1.py 里的代码，把 f1、x=&#39;m1&#39; 放进去在 run.py，里执行 m1.f1()，调用 m1 里 f1 方法，导入 m2，产生 m2 的名称空间导入 m2 后，运行 m2.py 的代码，m2 里把 f2、y=&#39;m2&#39; 放进去 示例二 12345678vim m1.pyprint('正在导入m1')def f1(): from m2 import y, f2 f2()x = 'm1' 12345678vim m2.pyprint('正在导入m2')def f2(): from m1 import x print(x)y = 'm2' 123456789vim run.pyimport m1m1.f1()# 执行结果正在导入m1正在导入m2m1 区分Python文件两种用途方式 直接运行，当做运行文件 被当做模块导入使用 需求：在文件运行的时候执行一种代码被当做模块导入的时候运行另一种代码 当文件被直接执行时 __name__ == &#39;__main__&#39;12345vim m1.pyprint(__name__)# 执行结果__main__ 当文件被导入时 __name__ == &#39;模块名&#39;模块的使用者1234import m1# 执行结果m1 模块开发者 12345678910111213141516171819vim m1.pydef f1(): print('f1')def f2(): print('f2')def f3(): print('f3')if __name__ == '__main__': f1() f2() f3()# 执行结果f1f2f3 该行代码用于区分 Python 文件的两种不同用途，应该写在文件末尾 模块的使用者123456import m1m1.f1() # 使用哪个模块就调用哪个# 执行结果f1 模块的搜索路径 模块的查找有限顺序： 内存中已经加载的模块 内置模块 sys.path 路径中包含的模块 内存中已经加载的模块 操作方式：在 20秒内 把 spam.py 文件删除123vim spam.pydef f1(): print('from f1') 12345678910vim run.pyimport timeimport spamtime.sleep(20)import spamspam.f1()# 执行结果from f1 发现 还是能输出 from f1，说明在删除文件之前，内存已经加载到了 spam.py 内置模块12345import timeprint(time)# 执行结果&lt;module 'time' (built-in)&gt; PS：我们自定义的模块名不应该与系统内置模块重名。 sys.path 路径中包含的模块 sys.path 的值是以当前执行文件为准 12345import sysprint(sys.path)# 执行结果['E:\\PycharmProjects\\SH_weekend_s1\\day05\\08 模块的使用\\模块的搜索路径', 'E:\\PycharmProjects\\SH_weekend_s1', 'D:\\Program Files (x86)\\Python37\\python37.zip', 'D:\\Program Files (x86)\\Python37\\DLLs', 'D:\\Program Files (x86)\\Python37\\lib', 'D:\\Program Files (x86)\\Python37', 'D:\\Program Files (x86)\\Python37\\lib\\site-packages', 'D:\\Program Files (x86)\\JetBrains\\PyCharm 2018.2.3\\helpers\\pycharm_matplotlib_backend'] 示例 123vim spam.pydef f1(): print('from spam') 12345678910vim run.pyimport syssys.path.append(r'E:\PycharmProjects\SH_weekend_s1\day05\08 模块的使用\模块的搜索路径\dir')import spamspam.f1()# 执行结果from spam 也可以在当前目录寻找 from ... import ... 123456789import sysprint(sys.path)from dir import spamspam.f1()# 执行结果['E:\\PycharmProjects\\SH_weekend_s1\\day05\\08 模块的使用\\模块的搜索路径', 'E:\\PycharmProjects\\SH_weekend_s1', 'D:\\Program Files (x86)\\Python37\\python37.zip', 'D:\\Program Files (x86)\\Python37\\DLLs', 'D:\\Program Files (x86)\\Python37\\lib', 'D:\\Program Files (x86)\\Python37', 'D:\\Program Files (x86)\\Python37\\lib\\site-packages', 'D:\\Program Files (x86)\\JetBrains\\PyCharm 2018.2.3\\helpers\\pycharm_matplotlib_backend']from spam 示例 123456789import sysprint(sys.path)from dir.dir2 import spamspam.f1()# 执行结果['E:\\PycharmProjects\\SH_weekend_s1\\day05\\08 模块的使用\\模块的搜索路径', 'E:\\PycharmProjects\\SH_weekend_s1', 'D:\\Program Files (x86)\\Python37\\python37.zip', 'D:\\Program Files (x86)\\Python37\\DLLs', 'D:\\Program Files (x86)\\Python37\\lib', 'D:\\Program Files (x86)\\Python37', 'D:\\Program Files (x86)\\Python37\\lib\\site-packages', 'D:\\Program Files (x86)\\JetBrains\\PyCharm 2018.2.3\\helpers\\pycharm_matplotlib_backend']from spam 示例 123456vim m1.pyimport m2def f1(): print('m1.f1') m2.f2() 123vim m2.pydef f2(): print('m2.f2') 12345678vim run.pyfrom dir1 import m1m1.f1()# 执行结果 from dir1 import m1 import m2ModuleNotFoundError: No module named 'm2' 示例修改1 12345vim m1.pyfrom dir1 import m2def f1(): print('m1.f1') m2.f2() 123vim m2.pydef f2(): print('m2.f2') 1234567vim run.pyfrom dir1 import m1m1.f1()# 执行结果m1.f1m2.f2 示例修改2 12345vim m1.pyfrom . import m2def f1(): print('m1.f1') m2.f2() 123vim m2.pydef f2(): print('m2.f2') 1234567vim run.pyfrom dir1 import m1m1.f1()# 执行结果m1.f1m2.f2]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 模块的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数的递归调用]]></title>
    <url>%2F2018%2F09%2F20%2FPython-%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python 函数的递归调用 函数的嵌套调用12345678def bar(): print('from bar')def foo(): print('from foo') bar()foo() 函数递归 函数的递归调用，就是函数嵌套调用的一种特殊格式函数递归调用，在调用一个函数的过程中又直接或间接地调用了自己本质就是一个重复的过程，递归必须要有一个明确的结束条件，在满足该条件的情况下，会终止递归每一次重复问题的规模都应该有所减少 直接调用1234567891011def bar(): print('from bar')def foo(): print('from foo') foo()foo()# 执行结果RecursionError: maximum recursion depth exceeded while calling a Python object 注：Python 中没有伪递归优化这一说 间接调用123456789101112def bar(): print('from bar') foo()def foo(): print('from foo') bar()foo()# 执行结果RecursionError: maximum recursion depth exceeded while calling a Python object Python 限制递归调用最大层级是多少？123456789def foo(n): print('from foo', n) foo(n+1)foo(0)# 执行结果from foo 997 # 这里看到的并不精准RecursionError: maximum recursion depth exceeded while calling a Python object 使用 sys.getrecursionlimit() 可以查看到 12345import sysprint(sys.getrecursionlimit())# 执行结果1000 递归的最大层级这个值是可以修改的，但是没有多大的意义sys.setrecursionlimit(10000) 递归必须满足两个阶段 回溯：一层一层地递归调用下去 递推：递归必须要有一个明确的结束条件，在满足该条件的情况下，会终止递归，往回一层一层地结束调用 练习 猜年龄 第一个人 18 岁第二个人比第一个人大2岁第三个人比第二个人大2岁第四个人比第三个人大2岁第五个人比第四个人大2岁问第五个人的年龄是多少岁？ 12345678age(5) = age(4) + 2age(4) = age(3) + 2age(3) = age(2) + 2age(2) = age(1) + 2age(1) = 18age(n) = age(n-1) + 2 # n &gt; 1age(n) = 18 # n = 1 123456789def age(n): if n == 1: return 18 return age(n-1) + 2print(age(5))# 执行结果26 递归是一次重复的过程，每一次重复问题的规模都应该有所减少 123456789101112131415161718192021l = [1, [2, [3, [4, [5, [6, [7, [8, [9, ]]]]]]]]]def tell(l): for item in l: if type(item) is not list: print(item) else: tell(item)tell(l)# 执行结果123456789 递归 vs while循环 递归只需要把控住结束或进入递归的条件，至于循环次数无需考虑 123456789101112131415161718192021222324l = [1, [2, [3, [4, [5, [6, [7, [8, [9, ]]]]]]]]]def tell(l): for item in l: if type(item) is list: # item 是列表 # 再次调用本身的逻辑，传入item tell(item) else: # item 是单独的元素 print(item)tell(l)# 执行结果123456789 递归的应用二分法 数字列表，数字从小打大排列需求：判断某一个值是否存在于这个列表中123456789101112nums = [3, 11, 13, 15, 23, 27, 43, 51, 72, 81, 93, 101]find_num = 27for num in nums: if find_num == num: print('find it') break else: continue# 执行结果find it 以上方式效率较低 算法：就是高效解决某个问题的方法二分法是算法中的其中之一1234567891011121314151617181920212223242526nums = [3, 11, 13, 15, 23, 27, 43, 51, 72, 81, 93, 101]# l1 = [3, 11, 13, 15, 23, 27]# l2 = [23, 27]# l3 = [23]def binary_search(nums, find_num): mid_index = len(nums) // 2 if find_num &gt; nums[mid_index]: # in the right # 从一个大列表中取出一个子列表 nums = nums[mid_index+1:] # 重复调用本身的逻辑，传入切分之后的结果 binary_search(nums, find_num) elif find_num &lt; nums[mid_index]: # in the left nums = nums[:mid_index] # 重复调用本身的逻辑，传入切分之后的结果 binary_search(nums, find_num) else: print('find it')binary_search(nums, 23)# 执行结果find it 123456789101112131415161718192021222324252627nums = [3, 11, 13, 15, 23, 27, 43, 51, 72, 81, 93, 101]def binary_search(nums, find_num): print(nums) # 获取查找次数 mid_index = len(nums) // 2 if find_num &gt; nums[mid_index]: # in the right # 从一个大列表中取出一个子列表 nums = nums[mid_index+1:] # 重复调用本身的逻辑，传入切分之后的结果 binary_search(nums, find_num) elif find_num &lt; nums[mid_index]: # in the left nums = nums[:mid_index] # 重复调用本身的逻辑，传入切分之后的结果 binary_search(nums, find_num) else: print('find it')binary_search(nums, 23)# 执行结果[3, 11, 13, 15, 23, 27, 43, 51, 72, 81, 93, 101][3, 11, 13, 15, 23, 27][23, 27][23]find it 传入一个不存在的值，会抛超出列表索引超出范围异常 123456789101112131415161718nums = [3, 11, 13, 15, 23, 27, 43, 51, 72, 81, 93, 101]def binary_search(nums, find_num): print(nums) mid_index = len(nums) // 2 if find_num &gt; nums[mid_index]: nums = nums[mid_index+1:] binary_search(nums, find_num) elif find_num &lt; nums[mid_index]: nums = nums[:mid_index] binary_search(nums, find_num) else: print('find it')binary_search(nums, 94) # 传入一个不存在的值，会抛超出列表索引超出范围异常# 执行结果IndexError: list index out of range 改进 1234567891011121314151617181920212223242526nums = [3, 11, 13, 15, 23, 27, 43, 51, 72, 81, 93, 101]def binary_search(nums, find_num): print(nums) if len(nums) == 0: print('not exists') return mid_index = len(nums) // 2 if find_num &gt; nums[mid_index]: nums = nums[mid_index+1:] binary_search(nums, find_num) elif find_num &lt; nums[mid_index]: nums = nums[:mid_index] binary_search(nums, find_num) else: print('find it')binary_search(nums, 94)# 执行结果[3, 11, 13, 15, 23, 27, 43, 51, 72, 81, 93, 101][51, 72, 81, 93, 101][93, 101][93][]not exists]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数的递归调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 匿名函数]]></title>
    <url>%2F2018%2F09%2F18%2FPython-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python 匿名函数 有名函数123456789def f1(): print('from f1')f1()f1()# 执行结果from f1from f1 匿名函数123456789101112131415def func(x, y): return x + yprint(func) # 通过函数名拿到内存地址# 执行结果&lt;function func at 0x000001D493372EA0&gt;########################################################################################## 通过 函数+() 的方式来调用函数func(1, 2)print(func(1, 2))# 执行结果3 针对这种简单形式的函数，可以用匿名函数简写成一行匿名函数本身自带 return1234567891011121314151617181920print(lambda x, y: x + y)# 执行结果&lt;function &lt;lambda&gt; at 0x000001DA1A6A2EA0&gt;########################################################################################## 以下方式不是正规的匿名函数使用方式res = (lambda x, y: x + y)(1, 2)print(res)# 执行结果3#########################################################################################f = lambda x, y: x + yres = f(1, 2)print(res)# 执行结果3 不会单独使用，会与其他函数配合使用 匿名函数在于没有名字，如果没有名字表示用一次就立即回收 匿名函数的应用场景仅应用于只使用使用一次的场景 匿名函数与其他函数配合使用 配合常用的内置函数：max，min，sorted，map, filter max() 函数获取薪资最高的人名 max 默认比较的是字典的 key12345678910salaries = &#123; 'egon': 3000, 'alex': 100000000, 'wupeiqi': 10000, 'yuanhao': 2000&#125;print(max(salaries))# 执行结果yuanhao max() 的结果一定是字典的 key可以更改比较依据max(比较对象，key=比较依据)1234567891011121314salaries = &#123; 'egon': 3000, 'alex': 100000000, 'wupeiqi': 10000, 'yuanhao': 2000&#125;def func(k): return salaries[k]print(max(salaries, key=func)) # key=指定比较依据# 执行结果alex 工作原理：max() 拿到 salaries 的 key结果，传给 key=func ，把 func 的返回值当做比较依据 func 就是一次性的函数，可以用 lambda 替换1234567891011salaries = &#123; 'egon': 3000, 'alex': 100000000, 'wupeiqi': 10000, 'yuanhao': 2000&#125;print(max(salaries, key=lambda x: salaries[x]))# 执行结果alex 获取薪资最小的人名 1234567891011salaries = &#123; 'egon': 3000, 'alex': 100000000, 'wupeiqi': 10000, 'yuanhao': 2000&#125;print(min(salaries, key=lambda x: salaries[x]))# 执行结果yuanhao sorted() 排序 默认从小到大排序1234print(sorted([2, 4, 1, 5]))# 执行结果[1, 2, 4, 5] 按照薪资排序，从小到大排队 sorted 默认也是比较字典的 key如果不给比较依据的话，就按默认的字典key字符串做比较1234567891011salaries = &#123; 'egon': 3000, 'alex': 100000000, 'wupeiqi': 10000, 'yuanhao': 2000&#125;print(sorted(salaries))# 执行结果['alex', 'egon', 'wupeiqi', 'yuanhao'] 所以也要通过所获取的字典key，给予 比较依据，然后再做排序123456789101112131415161718salaries = &#123; 'egon': 3000, 'alex': 100000000, 'wupeiqi': 10000, 'yuanhao': 2000&#125;print(sorted(salaries, key=lambda x: salaries[x]))# 执行结果['yuanhao', 'egon', 'wupeiqi', 'alex']########################################################################################## 反序排列print(sorted(salaries, key=lambda x: salaries[x], reverse=True))# 执行结果['alex', 'wupeiqi', 'egon', 'yuanhao'] map() 函数 映射：把一个值映射成一个新的值 需求：把 人名 都映射成 人名_PY123456names = ['alex', 'wupeiqi', 'yuanhao', 'liuqingzheng']l = [name + "_PY" for name in names]print(l)# 执行结果['alex_PY', 'wupeiqi_PY', 'yuanhao_PY', 'liuqingzheng_PY'] map(映射规则, 可迭代对象)123456789names = ['alex', 'wupeiqi', 'yuanhao', 'liuqingzheng']obj = map(lambda x:x+"_PY", names) # map 的结果其实就是一个迭代器print(obj)# 执行结果&lt;map object at 0x00000230B9BDCA90&gt;print(list(obj))# 执行结果['alex_PY', 'wupeiqi_PY', 'yuanhao_PY', 'liuqingzheng_PY'] 工作原理：会把可迭代对象作为迭代器传给第一个值，作为结果返回出来 filter() 函数 把 人名_sb 结尾的留下123456names = ['alex_sb', 'wupeiqi_sb', 'egon', 'yuanhao_sb', 'liuqingzheng_sb']l = [name for name in names if name.endswith('sb')]print(l)# 执行结果['alex_sb', 'wupeiqi_sb', 'yuanhao_sb', 'liuqingzheng_sb'] filter(过滤规则, 可迭代对象)filter 会得到 names 的迭代器对象obj，然后 next(obj)，将得到的值传给函数 12345678910names = ['alex_sb', 'wupeiqi_sb', 'egon', 'yuanhao_sb', 'liuqingzheng_sb']res = filter(lambda x: x.endswith('sb'), names) # filte 将函数返回值为 True 的那个值留下print(res)# 执行结果&lt;filter object at 0x000001867584C9B0&gt;#########################################################################################print(list(res))# 执行结果['alex_sb', 'wupeiqi_sb', 'yuanhao_sb', 'liuqingzheng_sb'] 也可以用 生成器表达式 来做12345678910names = ['alex_sb', 'wupeiqi_sb', 'egon', 'yuanhao_sb', 'liuqingzheng_sb']l = (name for name in names if name.endswith('sb'))print(l)# 执行结果&lt;generator object &lt;genexpr&gt; at 0x00000209162E55C8&gt;#########################################################################################print(list(l))# 执行结果['alex_sb', 'wupeiqi_sb', 'yuanhao_sb', 'liuqingzheng_sb']]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 生成器表达式]]></title>
    <url>%2F2018%2F09%2F17%2FPython-%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python 生成器表达式 () 小括号用来生成 生成器把列表推导式的 [] 换成 () 就是生成器表达式12345g = (i for i in range(10))print(g)# 执行结果&lt;generator object &lt;genexpr&gt; at 0x000001719E5E3EB8&gt; 用生成器表达式，可以用来造一个无限个值的数据1234567891011g = (i for i in range(10))print(next(g))print(next(g))print(next(g))print(next(g))# 执行结果0123 生一筐鸡蛋变成给你一只老母鸡，用的时候就下蛋，这也是生成器的特性123456789101112131415161718192021chicken = ('鸡蛋%s' % i for i in range(5))print(chicken)# 执行结果&lt;generator object &lt;genexpr&gt; at 0x10143f200&gt;#############################################################################################chicken = ('鸡蛋%s' % i for i in range(10))print(next(chicken))print(next(chicken))print(next(chicken))print(next(chicken))# 执行结果鸡蛋0鸡蛋1鸡蛋2鸡蛋3#############################################################################################chicken = ('鸡蛋%s' % i for i in range(5))print(list(chicken)) # 因 chicken 可迭代，因而可以转成列表['鸡蛋0', '鸡蛋1', '鸡蛋2', '鸡蛋3', '鸡蛋4'] 优点：省内存，一次只产生一个值在内存中 1234567891011chicken = ('egg%s' % for i in range(3))print(next(chicken))print(next(chicken))print(next(chicken))print(next(chicken))# 执行结果egg0egg1egg2StopIteration 小练习 求文件 a.txt 中最长的行的长度（长度按字符个数算，需要使用 max 函数）123456789101112131415161718192021222324252627282930313233# 获取文件内每一行的字符长度with open('a.txt', 'r', encoding='utf-8') as f: nums = [len(line) for line in f] print(nums)# 执行结果[2, 3, 4, 5, 66, 54, 54, 54, 54, 53]############################################################################################## 获取最长那一行的长度with open('a.txt', 'r', encoding='utf-8') as f: nums = [len(line) for line in f] # 这里用列表生成器会有问题，如果文件内容非常多，这个列表会变得非常大，我们可以换成生成器表达式 print(max(nums))# 执行结果66############################################################################################## 获取最长那一行的长度with open('a.txt', 'r', encoding='utf-8') as f: nums = (len(line) for line in f) print(nums)# 执行结果&lt;generator object &lt;genexpr&gt; at 0x00000153AFF855C8&gt;#############################################################################################with open('a.txt', 'r', encoding='utf-8') as f: nums = (len(line) for line in f) print(max(nums))# 执行结果66]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 生成器表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 面向过程编程]]></title>
    <url>%2F2018%2F09%2F15%2FPython-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python 面向过程编程 首先强调：面向过程编程绝对不是用函数编程这么简单，面向过程是一种编程思路、思想，而编程思路是不依赖于具体的语言或语法的。言外之意是即使我们不依赖于函数，也可以基于面向过程的思想编写程序 定义面向过程的核心是过程二字，过程指的是解决问题的步骤，即先干什么再干什么基于面向过程设计程序就好比在设计一条流水线，是一种机械式的思维方式 优点：复杂的问题流程化，进而简单化 缺点：可扩展性差，修改流水线的任意一个阶段，都会牵一发而动全身 应用：扩展性要求不高的场景，典型案例如 Linux 内核，git，httpd 举例流水线1：用户输入用户名、密码 —&gt; 用户验证—&gt;欢迎界面流水线2：用户输入sql —&gt; sql解析 —&gt; 执行功能 PS：函数的参数传入，是函数吃进去的食物，而函数 return 的返回值，是函数拉出来的结果，面向过程的思路就是，把程序的执行当做一串首尾相连的功能，该功能可以是函数的形式，然后一个函数吃，拉出的东西给另外一个函数吃，另外一个函数吃了再继续拉给下一个函数吃。。。 注册功能1234567891011121314151617181920212223242526272829303132333435# 阶段1: 接收用户输入账号与密码,完成合法性校验def talk(): while True: username = input('请输入你的用户名: ').strip() if username.isalpha(): break else: print('用户必须为字母') while True: password1 = input('请输入你的密码: ').strip() password2 = input('请再次输入你的密码: ').strip() if password1 == password2: break else: print('两次输入的密码不一致') return username,password1# 阶段2: 将账号密码拼成固定的格式def register_interface(username, password): format_str = '%s:%s\n' %(username, password) return format_str# 阶段3: 将拼好的格式写入文件def handle_file(format_str, filepath): with open(r'%s' % filepath, 'at', encoding='utf-8') as f: f.write(format_str)def register(): user, pwd = talk() format_str = register_interface(user, pwd) handle_file(format_str, 'user.txt')register() 扩展功能麻烦 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 阶段1: 接收用户输入账号与密码，完成合法性校验def talk(): while True: username = input('请输入你的用户名: ').strip() if username.isalpha(): break else: print('用户必须为字母') while True: password1 = input('请输入你的密码: ').strip() password2 = input('请再次输入你的密码: ').strip() if password1 == password2: break else: print('两次输入的密码不一致') role_dic = &#123; '1':'user', '2':'admin' &#125; while True: for k in role_dic: print(k,role_dic[k]) choice = input('请输入您的身份&gt;&gt;: ').strip() if choice not in role_dic: print('输入的身份不存在') continue role = role_dic[choice] return username, password1, role# 阶段2: 将账号密码拼成固定的格式def register_interface(username, password, role): format_str = '%s:%s:%s\n' % (username, password, role) return format_str# 阶段3: 将拼好的格式写入文件def handle_file(format_str, filepath): with open(r'%s' % filepath, 'at', encoding='utf-8') as f: f.write(format_str)def register(): user, pwd, role = talk() format_str = register_interface(user, pwd, role) handle_file(format_str, 'user.txt')register() PS：talk 内对 用户名 \ 密码 \ 角色 的合法性校验也可以摘出来做成单独的功能，但本例就写到一个函数内了，力求用更少的逻辑来为大家说明过程式编程的思路 认证功能12345678910111213141516171819202122232425262728def interactive(): """接收用户输入的用户名、密码""" uname = input('username: ').strip() pwd = input('password: ').strip() return uname, group, pwddef auth(uname, group, pwd): """认证用户名与密码是否正确""" if uname == 'egon' and pwd == '123': return True, uname else: return False, unamedef index(res): """如果认证成功，则打印欢迎界面""" if res[0]: print('%s 登录成功' % res[1]) else: print('%s 登录失败' % res[1])uname, pwd = interactive()res = auth(uname, pwd)index(res)# 执行结果username: egonpassword: 123egon 登录成功 扩展功能麻烦123456789101112131415161718192021222324252627282930def interactive(): """接收用户输入的用户名、密码""" uname = input('username: ').strip() group = input('group: ').strip() pwd = input('password: ').strip() return uname, group, pwddef auth(uname, group, pwd): """认证用户名与密码是否正确""" if uname == 'egon' and pwd == '123' and group == 'group1': return True, uname, group else: return False, uname, groupdef index(res): """如果认证成功，则打印欢迎界面""" if res[0]: print('部门：%s 员工：%s 登录成功' % (res[2], res[1])) else: print('部门：%s 员工：%s 登录失败' % (res[2], res[1]))uname, group, pwd = interactive()res = auth(uname, group, pwd)index(res)# 执行结果username: egongroup: group1password: 123部门：group1 员工：egon 登录成功]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 面向过程编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 生成器]]></title>
    <url>%2F2018%2F09%2F12%2FPython-%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Python 生成器 什么是生成器？ 在函数体内凡是有 yield 关键字，再调用函数就不会执行函数体代码，得到的返回值就是一个生成器对象。 为什么要用生成器？ 为了掌握一种自定义迭代器的方式12345678910def func(): print('first') print('second') print('third')func()# 执行结果firstsecondthird 在函数体内凡是有 yield 关键字，再调用函数就不会执行函数体代码，得到的返回值是一个生成器对象。123456789101112def func(): print('first') yield 1 print('second') yield 2 print('third')g = func()print(g)# 执行结果&lt;generator object func at 0x000002C5C3A05EB8&gt; 用 yield 的目的就是为了使用自定义迭代器为什么要自定义迭代器？优点：更加节省内存，可以生成一个无限大的迭代器 123456789101112def func(): print('first') yield 1 print('second') yield 2 print('third')g = func()next(g) # 等于 g.__next__()# 执行结果first next(g) 会去执行一次，才会去执行 g 所对应的函数体内的代码运行过程：会触发生成器 g 所对应函数的执行，直到遇到 yield 才停止，然后把 yield 后的返回值当做本次 next 操作的结果12345678910111213141516171819202122232425def func(): print('first') yield 1 # 暂停 print('second') yield 2 # 暂停 print('third')g = func()res1 = next(g) # g.__next__()print(res1)res2 = next(g) # g.__next__()print(res2)res3 = next(g) # g.__next__()# 执行结果first1second2thirdTraceback (most recent call last): res3 = next(g)StopIteration 1234567891011121314151617181920def func(): print('first') yield 1 # 暂停 print('second') yield 2 # 暂停 print('third')# g = func()# for item in g:# print(item)for item in func(): print(item)# 执行结果first1second2third 示例 模拟 range() 函数功能自定义一个 range() 函数range(1, 100, 2) Python2 的做法123456789101112def my_range(start, stop, step=1): res = [] while start &lt; stop: res.append(start) start += step return resres = my_range(1, 100, 2)print(res)# 执行结果[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99] Python3 的做法12345678910def my_range(start, stop, step=1): while start &lt; stop: yield start start += stepres = my_range(1, 1000, 2)print(res)# 执行结果&lt;generator object my_range at 0x00000294DBE75EB8&gt; 只要函数体内出现 yield 再去调函数，就不会运行函数体代码再调用函数会得到一个返回值，这个返回值就是我们所需要的生成器对象（迭代器对象）123456789101112def my_range(start, stop, step=1): print('开始运行') while start &lt; stop: yield start start += step print('结束运行')obj = my_range(1, 1000, 2)print(obj)# 执行结果&lt;generator object my_range at 0x00000294DBE75EB8&gt; 123456789101112131415161718def my_range(start, stop, step=1): print('开始运行') while start &lt; stop: yield start start += step print('结束运行')obj = my_range(1, 1000, 2)res1 = next(obj)print(res1)res2 = next(obj)print(res2)# 执行结果开始运行13 123456789101112131415161718def my_range(start, stop, step=1): print('开始运行') while start &lt; stop: yield start start += step print('结束运行')for item in my_range(1, 10, 2): print(item)# 执行结果开始运行13579结束运行 1234567891011121314def my_range(start, stop, step=1): while start &lt; stop: yield start start += stepfor item in my_range(1, 10, 2): print(item)# 执行结果13579 总结 yield 提供了一种自定义迭代器的方式。与 return 对比，都能返回值，都能返回多个值，都没有类型限制。return 只能返回一次值，yield 能暂停住函数，把函数体暂停在某一个位置，可以返回多次值。yield 可以帮我们保存函数的执行状态。 yield 表达式形式应用示例1 1234567891011def dog(name): print('%s 准备开吃' % name) while True: food = yield print('%s 吃了 %s' % (name, food))g = dog('来福')print(g)# 执行结果&lt;generator object dog at 0x000001A607255F68&gt; 示例2 1234567891011def dog(name): print('%s 准备开吃' % name) while True: food = yield print('%s 吃了 %s' % (name, food))g = dog('来福')next(g) # 让来福准备好，即让生成器对象先暂停到一个位置，准备接收# 执行结果来福 准备开吃 示例3 12345678910111213def dog(name): print('%s 准备开吃' % name) while True: food = yield # 暂停 food = yield = None print('%s 吃了 %s' % (name, food))g = dog('来福')next(g) # 让来福准备好，即让生成器对象先暂停到一个位置，准备接收next(g)# 执行结果来福 准备开吃来福 吃了 None 示例4 1234567891011121314151617def dog(name): print('%s 准备开吃' % name) while True: food = yield # 暂停 food = yield = '骨头' print('%s 吃了 %s' % (name, food))g = dog('来福')next(g) # 让来福准备好，即让生成器对象先暂停到一个位置，准备接收g.send('骨头')g.send('肉')g.send('包子')# 执行结果来福 准备开吃来福 吃了 骨头来福 吃了 肉来福 吃了 包子 上面方式是只调用了一次函数 下面方式是每次都要调用一次函数123456def dog(food): print('%s 吃了 %s' % (food))dog('来福1')dog('来福2')dog('来福3') 两者的区别执行函数体代码，会产生一个内存空间每调用一次函数，就要申请一次内存空间 示例512345678910111213141516171819202122232425262728def dog(name): print('%s 准备开吃' % name) while True: food = yield 123123 # 暂停 food = yield = None print('%s 吃了 %s' % (name, food))g = dog('来福')res1 = next(g)print(res1)res2 = g.send('骨头') # food = yield 123123 &lt;== 暂停 food = yield = '骨头'print(res2)res3 = g.send('骨头1') # food = yield 123123 &lt;== 暂停 food = yield = '骨头1'print(res3)res4 = next(g) # food = yield 123123 &lt;== 暂停 food = yield = Noneprint(res4)# 执行结果来福 准备开吃123123来福 吃了 骨头123123来福 吃了 骨头1123123来福 吃了 None123123 示例7 123456789101112131415161718192021222324252627282930def dog(name): print('%s 准备开吃' % name) food_list = [] while True: food = yield food_list print('%s 吃了 %s' % (name, food)) food_list.append(food)g = dog('来福')res1 = next(g)print(res1)res2 = g.send('骨头')print(res2)res3 = g.send('骨头1')print(res3)res4 = g.send('骨头2')print(res4)# 执行结果来福 准备开吃[]来福 吃了 骨头['骨头']来福 吃了 骨头1['骨头', '骨头1']来福 吃了 骨头2['骨头', '骨头1', '骨头2'] 不能 send 一个不为 None 的值， 给一个刚刚开始的 生成器 TypeError: can&#39;t send non-None value to a just-started generator不能 send 一个不为 None 的值， 给一个刚刚开始的 生成器 123456789101112131415def dog(name): print('%s 准备开吃' % name) food_list = [] while True: food = yield food_list print('%s 吃了 %s' % name) food_list.append(food)g = dog('来福')g.send('包子')# 执行结果Traceback (most recent call last): g.send('包子')TypeError: can't send non-None value to a just-started generator g.send(None) 等同于 next(g)强调：对于表达式形式 yield 的生成器，在使用前必须先用 next(g) 或 g.send(None) 初始化一次12345678910111213141516def dog(name): print('%s 准备开吃' % name) food_list = [] while True: food = yield food_list print('%s 吃了 %s' % (name, food)) food_list.append(food)g = dog('来福')next(g)# g.send(None)g.send('包子')# 执行结果来福 准备开吃来福 吃了 包子 练习 编写装饰器，实现初始化协程函数的功能12345678910111213141516171819202122def init(func): def wrapper(*args, **kwargs): g = func(*args, **kwargs) next(g) return g return wrapper@initdef eater(name): print('%s 准备开始吃饭啦' % name) food_list = [] while True: food = yield food_list print('%s 吃了 %s' % (name, food)) food_list.append(food)g = eater('张三')g.send('蒸羊羔')# 执行结果张三 准备开始吃饭啦张三 吃了 蒸羊羔 实现功能：grep -rl &#39;python&#39; /etc注意：target.send(...) 在拿到 target 的返回值后才算执行结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import osdef init(func): def wrapper(*args,**kwargs): g=func(*args,**kwargs) next(g) return g return wrapper@initdef search(target): while True: filepath=yield g=os.walk(filepath) for dirname,_,files in g: for file in files: abs_path=r'%s\%s' %(dirname,file) target.send(abs_path)@initdef opener(target): while True: abs_path=yield with open(abs_path,'rb') as f: target.send((f,abs_path))@initdef cat(target): while True: f,abs_path=yield for line in f: res=target.send((line,abs_path)) if res: break@initdef grep(pattern,target): tag=False while True: line,abs_path=yield tag tag=False if pattern.encode('utf-8') in line: target.send(abs_path) tag=True@initdef printer(): while True: abs_path=yield print(abs_path)g=search(opener(cat(grep('你好',printer()))))# g.send(r'E:\CMS\aaa\db')g=search(opener(cat(grep('python',printer()))))g.send(r'E:\CMS\aaa\db')]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prometheus Operator]]></title>
    <url>%2F2018%2F09%2F10%2FPrometheus-Operator%2F</url>
    <content type="text"><![CDATA[Prometheus Operator Prometheus介绍Prometheus是继Kubernetes之后CNCF基金会的第二个项目，最早也是孵化于Google内部的Brogmon监控系统，后来由前Google工程师在SoundCloud开源，现在已经成为云原生生态的标准监控系统。 Prometheus是一个开源的完整监控解决方案，涵盖数据采集、查询、告警、展示整个监控流程，下图是Prometheus的架构图： Prometheus ServerPrometheus server是整个方案的核心组件，负责监控数据的获取、存储和查询，它本身就是一个时序数据库，将采集到的监控数据按照时间序列的方式存储在本地，Prometheus Server对外提供了自定义的PromQL语言，实现对数据的查询以及分析。 Prometheus server可以通过静态配置监控目标，也可以通过服务发现的方式动态监控目标，Prometheus server采用pull的方式到target暴露出的对应http接口获取监控数据。 ExportersExporters将数据采集的target通过http的形式暴露给Prometheus server，Prometheus server通过访问该exporter提供的endpoints端点，获取到需要采集的监控数据。 Exporters分为两类： 直接采集：这类的exporters内置在了相应的应用中，能够直接提供target端点，比如etcd、kubernetes组件，都直接内置了用于向Prometheus暴露监控数据的端点。 间接采集：原有的监控目标不支持prometheus，需要通过prometheus提供的Client Library编写该监控目标的监控采集程序，比如redis、tomcat、mysql等应用，需要有外置的exporters先采集应用的监控项，再通过exporters的http接口把metrics暴露给prometheus server PushGateway因为prometheus数据采集采用pull模式，需要prometheus server能直接访问到exporters，当网络环境无法满足时，需要通过PushGateway中转，内部网络的监控数据主动pushl到Gateway当中，而Prometheus Server则可以采用同样Pull的方式从PushGateway中获取到监控数据。 AlertManager在prometheus server的配置文件中可以配置相应的告警规则，一旦达到告警规则，就会触发AlertManager，至于之后的操作由AlertManager自定义，可以是邮箱、微信、钉钉或webhook等。 promethus的告警被分成两个部分： 通过在Prometheus中定义告警触发条件规则，并向Alertmanager发送告警信息 Alertmanager作为一个独立的组件，负责接收并处理来自Prometheus Server(也可以是其它的客户端程序)的告警信息 在Prometheus全局配置文件中prometheus.yml通过rule_files指定一组告警规则文件的访问路径。Prometheus启动后会自动扫描这些路径下规则文件中定义的内容，并且根据这些规则计算是否向外部发送通知 在prometheus.yml中添加监控告警文件 12rule_files: - /etc/prometheus/rules/*.rules 在目录/etc/prometheus/rules/下创建告警文件hoststats-alert.rules，重启promethus后这个告警文件就能被promethus读取。 在promethus.yml中添加关联alertmanager配置： 1234alerting: alertmanagers: - static_configs: targets: ['localhost:9093'] 成功后就可以在alertmanager中查看promethus中触发的告警，之后的操作可以由alertmanager自定义 alertmanager是独立的服务，配置文件默认在/etc/prometheus/alertmanager.yml，配置文件中目前只写入基础配置： 1234route: receiver: 'default-receiver'receivers: - name: default-receiver route：所有的告警信息都会从配置中的顶级路由(route)进入路由树，根据路由规则将告警信息发送给相应的接收器 receivers：告警信息会根据路由发送给对应receivers，接收器可以关联邮件，Slack以及其它方式接收告警信息 Prometheus Operator对于云原生基础的Kubernetes，Prometheus对其有着代码级别的支持，Kubernetes中的组件原生支持Prometheus的metrics路径，而且能够通过服务发现的形式自动监控集群。在Kubernetes中部署Prometheus可以通过operator的框架，下图是prometheus-operator的架构： 其中operator是其核心，作为一个控制器，operator首先会创建Prometheus、ServiceMonitor、AlertManager三个CRD资源对象，并且监控并维持这三种资源对象的状态。 创建的Prometheus资源对象就是作为Prometheus server，ServiceMonitor就是exporters的抽象，通过ServiceMonitor，Prometheus server能够pull到对应target的监控metrics。 在prometheus的yaml文件中会指定需要采集的ServiceMonitor： 123serviceMonitorSelector: matchExpressions: - &#123;key: k8s-app, operator: Exists&#125; 只有在ServiceMonitor的yaml文件中匹配上了k8s-app的ServiceMonitor才能被Prometheus server采集： 1234567891011121314151617apiVersion: monitoring.coreos.com/v1kind: ServiceMonitormetadata: name: kube-controller-manager labels: k8s-app: kube-controller-manager ##Prometheus中的ServiceMonitor选择器spec: jobLabel: k8s-app endpoints: - port: http-metrics ##对应service的端口名 interval: 30s selector: matchLabels: k8s-app: kube-controller-manager ##选择对应label的service namespaceSelector: matchNames: - kube-system ##选择对应namespace 也就是Prometheus server选取对应的ServiceMonitor进行监控，而ServiceMonitor会对应到相应的service，service会对应到endpoints，Prometheus server通过选择ServiceMonitor就能访问到最终的监控目标。 在Kubernetes中部署Prometheus Operator因为这是部署在非原生的k8s集群，所以需要做一些额外操作才能监控整个集群 下载源码123$ wget https://codeload.github.com/coreos/prometheus-operator/tar.gz/v0.16.0 -O prometheus-operator-0.16.0.tar.gz$ tar -zxvf prometheus-operator-0.16.0.tar.gz$ cd prometheus-operator-0.16.0/contrib/kube-prometheus 创建单独的namespace： 1$ kubectl create ns monitoring 安装 Prometheus Operator删除RBAC相关配置： 12345678910$ tree manifests/prometheus-operatormanifests/prometheus-operator├── prometheus-operator-cluster-role-binding.yaml├── prometheus-operator-cluster-role.yaml├── prometheus-operator-service-account.yaml├── prometheus-operator-service.yaml└── prometheus-operator.yaml0 directories, 5 files$ rm -rf manifests/prometheus-operator/prometheus-operator-cluster-role*$ rm -rf manifests/prometheus-operator/prometheus-operator-service-account.yaml 删除 prometheus-operator.yaml 中的 serviceAccountName: prometheus-operator： 12345678910111213apiVersion: extensions/v1beta1kind: Deploymentmetadata:...spec: replicas: 1 template: metadata: ... spec: containers: ... # serviceAccountName: prometheus-operator # 将这一行删除 部署Prometheus Operator 1234567$ tree manifests/prometheus-operator/manifests/prometheus-operator├── prometheus-operator-service.yaml└── prometheus-operator.yaml0 directories, 2 files$ kubectl apply -f manifests/prometheus-operator/ -n monitoringprometheus-operator-599487016-39w9m 1/1 Running 0 1d 部署完成后，operator会自动创建三个CRD： 12345$ kubectl get crdNAME KINDalertmanagers.monitoring.coreos.com CustomResourceDefinition.v1beta1.apiextensions.k8s.ioprometheuses.monitoring.coreos.com CustomResourceDefinition.v1beta1.apiextensions.k8s.ioservicemonitors.monitoring.coreos.com CustomResourceDefinition.v1beta1.apiextensions.k8s.io 安装Node ExporterPrometheus监控主机需要Node Exporter提供相应的target删除与 RBAC 相关的 yaml 文件： 12345678910$ tree manifests/node-exportermanifests/node-exporter├── node-exporter-cluster-role-binding.yaml├── node-exporter-cluster-role.yaml├── node-exporter-daemonset.yaml├── node-exporter-service-account.yaml└── node-exporter-service.yaml0 directories, 5 files$ rm -rf manifests/node-exporter/node-exporter-cluster-role*$ rm -rf manifests/node-exporter/node-exporter-service-account.yaml 删除node-exporter-daemonset.yaml中的serviceAccountName: node-exporter 123456789101112apiVersion: extensions/v1beta1kind: DaemonSetmetadata:...spec: ... template: metadata: ... spec: # serviceAccountName: node-exporter # 将这一行删除 ... 部署 node-exporter 1234567891011$ tree manifests/node-exportermanifests/node-exporter├── node-exporter-daemonset.yaml└── node-exporter-service.yaml0 directories, 2 files$ kubectl apply -f manifests/node-exporter -n monitoring$ kubectl -n monitoring get pods -l app=node-exporterNAME READY STATUS RESTARTS AGEnode-exporter-3mnvn 2/2 Running 0 1dnode-exporter-lwbjm 2/2 Running 0 1dnode-exporter-p2bw5 2/2 Running 0 1d 安装 Kube-state-metrics删除与 RBAC 相关的 yaml 文件： 123456789101112$ tree manifests/kube-state-metricsmanifests/kube-state-metrics├── kube-state-metrics-cluster-role-binding.yaml├── kube-state-metrics-cluster-role.yaml├── kube-state-metrics-deployment.yaml├── kube-state-metrics-role-binding.yaml├── kube-state-metrics-role.yaml├── kube-state-metrics-service-account.yaml└── kube-state-metrics-service.yaml0 directories, 7 files$ rm -rf manifests/kube-state-metrics/*role*$ rm -rf manifests/kube-state-metrics/kube-state-metrics-service-account.yaml 删除kube-state-metrics-deployment.yaml中的serviceAccountName: kube-state-metrics。 123456789101112apiVersion: extensions/v1beta1kind: Deploymentmetadata:...spec: ... template: metadata: ... spec: # serviceAccountName: kube-state-metrics # 将这一行删除 ... 部署 kube-state-metrics： 123456789$ tree manifests/kube-state-metricsmanifests/kube-state-metrics├── kube-state-metrics-deployment.yaml└── kube-state-metrics-service.yaml0 directories, 2 files$ kubectl apply -f manifests/kube-state-metrics -n monitoring$ kubectl -n monitoring get pods -l app=kube-state-metricsNAME READY STATUS RESTARTS AGEkube-state-metrics-3424261376-hcvd5 4/4 Running 0 1d 安装 Prometheus 和 ServiceMonitor删除与 RBAC 相关的 yaml 文件： 123456789101112131415161718$ tree manifests/prometheusmanifests/prometheus├── prometheus-k8s-role-bindings.yaml├── prometheus-k8s-roles.yaml├── prometheus-k8s-rules.yaml├── prometheus-k8s-service-monitor-alertmanager.yaml├── prometheus-k8s-service-monitor-apiserver.yaml├── prometheus-k8s-service-monitor-kube-controller-manager.yaml├── prometheus-k8s-service-monitor-kubelet.yaml├── prometheus-k8s-service-monitor-kube-scheduler.yaml├── prometheus-k8s-service-monitor-kube-state-metrics.yaml├── prometheus-k8s-service-monitor-node-exporter.yaml├── prometheus-k8s-service-monitor-prometheus-operator.yaml├── prometheus-k8s-service-monitor-prometheus.yaml├── prometheus-k8s-service.yaml└── prometheus-k8s.yaml0 directories, 14 files$ rm -rf manifests/prometheus/*role* 删除 prometheus-k8s.yaml 中的 serviceAccountName: prometheus-k8s： 12345678910apiVersion: monitoring.coreos.com/v1kind: Prometheusmetadata: name: k8s labels: prometheus: k8sspec: replicas: 2 version: v2.0.0# serviceAccountName: prometheus-k8s # 将这一行删除 部署 Prometheus 和 ServiceMonitor： 1234567891011121314151617$ kubectl -n monitoring apply -f manifests/prometheus/$ kubectl -n monitoring get prometheusesNAME KINDk8s Prometheus.v1.monitoring.coreos.com$ kubectl -n monitoring get servicemonitorNAME KINDalertmanager ServiceMonitor.v1.monitoring.coreos.cometcd-k8s ServiceMonitor.v1.monitoring.coreos.comkube-apiserver ServiceMonitor.v1.monitoring.coreos.comkube-controller-manager ServiceMonitor.v1.monitoring.coreos.comkube-scheduler ServiceMonitor.v1.monitoring.coreos.comkube-state-metrics ServiceMonitor.v1.monitoring.coreos.comkubelet ServiceMonitor.v1.monitoring.coreos.comnode-exporter ServiceMonitor.v1.monitoring.coreos.comprometheus ServiceMonitor.v1.monitoring.coreos.comprometheus-operator ServiceMonitor.v1.monitoring.coreos.com 监控kube-controller-manager kube-scheduler查看的kube-controller-manager的ServiceMonitor的yaml文件： 1234567891011121314151617apiVersion: monitoring.coreos.com/v1kind: ServiceMonitormetadata: name: kube-controller-manager labels: k8s-app: kube-controller-managerspec: jobLabel: k8s-app endpoints: - port: http-metrics interval: 30s selector: matchLabels: k8s-app: kube-controller-manager namespaceSelector: matchNames: - kube-system 这个ServiceMonitor对应指定的是kube-system命名空间的打了k8s-app: kube-controller-manager标签的service，不是对应的endpoint的标签，对应endpoint端口名是http-metrics 因为kube-controller-manager和kube-scheduler在kube-system的命名空间中没有相应的service和endpoints，所以需要手动创建： 123456789101112131415161718192021222324252627282930313233343536# kube-controller-managerapiVersion: v1kind: Servicemetadata: namespace: kube-system name: kube-controller-manager-prometheus-discovery labels: k8s-app: kube-controller-managerspec: type: ClusterIP clusterIP: None ports: - name: http-metrics port: 10252 targetPort: 10252 protocol: TCP---apiVersion: v1kind: Endpointsmetadata: namespace: kube-system name: kube-controller-manager-prometheus-discovery labels: k8s-app: kube-controller-managersubsets:- addresses: - ip: 192.168.2.191 - ip: 192.168.2.194 - ip: 192.168.2.183 ports: - name: http-metrics port: 10252 protocol: TCP 123456789101112131415161718192021222324252627282930313233343536#kube-schedulerapiVersion: v1kind: Servicemetadata: namespace: kube-system name: kube-scheduler-prometheus-discovery labels: k8s-app: kube-schedulerspec: type: ClusterIP clusterIP: None ports: - name: http-metrics port: 10251 targetPort: 10251 protocol: TCP---apiVersion: v1kind: Endpointsmetadata: namespace: kube-system name: kube-scheduler-prometheus-discovery labels: k8s-app: kube-schedulersubsets:- addresses: - ip: 192.168.2.191 - ip: 192.168.2.194 - ip: 192.168.2.183 ports: - name: http-metrics port: 10251 protocol: TCP 监控api-server在原生的k8s集群中，是可以直接监控api-server的，但是在dce集群中，部署多个控制节点后kubernetes的endpoint对应的ip会一直在各个主机ip中变化，所以新建api-server的service和endpoints。在prometheus的配置文件中，通过label来过滤api-server的target： 1234567891011relabel_configs:- source_labels: [__meta_kubernetes_service_label_component] separator: ; regex: apiserver replacement: $1 action: keep- source_labels: [__meta_kubernetes_service_label_provider] separator: ; regex: kubernetes replacement: $1 action: keep 能看到service的label的值只能是apiserver和kubernetes，所以新建api-server的service和endpoint如下： 123456789101112131415161718192021222324252627282930313233apiVersion: v1kind: Servicemetadata: labels: component: apiserver provider: kubernetes name: kubernetes-dce namespace: defaultspec: clusterIP: None ports: - name: https port: 443 protocol: TCP targetPort: 16443 type: ClusterIP---apiVersion: v1kind: Endpointsmetadata: name: kubernetes-dce namespace: defaultsubsets:- addresses: - ip: 192.168.2.191 - ip: 192.168.2.194 - ip: 192.168.2.183 ports: - name: https port: 16443 protocol: TCP 监控ETCDETCD作为kubernetes集群的数据持久化的后端，是集群所有数据的存储点，也需要对其有相应监控。CoreOS给出了监控ETCD的方法监控ETCD 创建ETCD对应访问证书因为监控ETCD不像监控kubernetes组件是通过api-server或直接使用http访问组件的target，需要使用https双向证书验证，所以要先创建可访问ETCD的secret，供prometheus server使用： 1kubectl -n monitoring create secret generic etcd-certs --from-file=/etc/cni/net.d/calico-tls/etcd-cert --from-file=/etc/cni/net.d/calico-tls/etcd-key --from-file=/etc/cni/net.d/calico-tls/etcd-ca 证书、私钥及ca证书是可访问ETCD的，路径是主机本地存储证书的目录。在prometheus的yaml文件中挂载证书： 1234567891011apiVersion: monitoring.coreos.com/v1kind: Prometheusmetadata: name: k8s labels: prometheus: k8sspec: replicas: 2 secrets: - etcd-certs version: v1.7.1 如果已创建，可以直接edit该对象. 创建ETCD的ServiceMonitor 12345678910111213141516171819202122232425apiVersion: monitoring.coreos.com/v1kind: ServiceMonitormetadata: name: etcd-k8s labels: k8s-app: etcd-k8sspec: jobLabel: k8s-app endpoints: - port: api interval: 30s scheme: https tlsConfig: caFile: /etc/prometheus/secrets/etcd-certs/etcd-ca certFile: /etc/prometheus/secrets/etcd-certs/etcd-cert keyFile: /etc/prometheus/secrets/etcd-certs/etcd-key #use insecureSkipVerify only if you cannot use a Subject Alternative Name insecureSkipVerify: true #serverName: ETCD_DNS_OR_ALTERNAME_ selector: matchLabels: k8s-app: etcd namespaceSelector: matchNames: - monitoring 其中tlsConfig的文件位置是prometheus容器里面挂载证书的位置，不确定的话可以进入容器内部验证一下当证书serverName和etcd中签发的不匹配可以使用insecureSkipVerify: true 创建ETCD对应的service和endpoints 1234567891011121314151617181920212223242526272829303132apiVersion: v1kind: Servicemetadata: name: etcd-k8s labels: k8s-app: etcdspec: type: ClusterIP clusterIP: None ports: - name: api port: 12379 protocol: TCP---apiVersion: v1kind: Endpointsmetadata: name: etcd-k8s labels: k8s-app: etcdsubsets:- addresses: - ip: 192.168.2.191 nodeName: dcemaster1 - ip: 192.168.2.194 nodeName: dcemaster2 - ip: 192.168.2.183 nodeName: dcemaster3 ports: - name: api port: 12379 protocol: TCP 登录prometheus的UI查看对应target是不是都是up状态，up状态说明数据pull正常 安装Grafana作为prometheus前端展示页面，Grafana提供了强大的数据聚合和展示的功能，可以通过自定义前端配置修改dashboard，官方社区有很多kubernetes的前端json文件供使用 1234$ ls manifests/grafana/grafana-credentials.yaml grafana-dashboards.yaml grafana-deployment.yaml grafana-service.yaml$ kubectl -n monitoring apply -f manifests/grafana/ 部署后就能通过Grafana监控整个kubernetes集群 配置AlertManager1234$ ls manifests/alertmanager/alertmanager-config.yaml alertmanager-service.yaml alertmanager.yaml$ kubectl -n monitoring apply -f manifests/alertmanager/ 告警接收器可以通过以下形式进行配置： 12receivers: - &lt;receiver&gt; ... 每一个receiver具有一个全局唯一的名称，并且对应一个或者多个通知方式： 1234567891011121314151617name: &lt;string&gt;email_configs: [ - &lt;email_config&gt;, ... ]hipchat_configs: [ - &lt;hipchat_config&gt;, ... ]pagerduty_configs: [ - &lt;pagerduty_config&gt;, ... ]pushover_configs: [ - &lt;pushover_config&gt;, ... ]slack_configs: [ - &lt;slack_config&gt;, ... ]opsgenie_configs: [ - &lt;opsgenie_config&gt;, ... ]webhook_configs: [ - &lt;webhook_config&gt;, ... ]victorops_configs: [ - &lt;victorops_config&gt;, ... ] 目前官方内置的第三方通知集成包括：邮件、 即时通讯软件（如Slack、Hipchat）、移动应用消息推送(如Pushover)和自动化运维工具（例如：Pagerduty、Opsgenie、Victorops）。Alertmanager的通知方式中还可以支持Webhook，通过这种方式开发者可以实现更多个性化的扩展支持。 以下是集成SMTP邮件的示例每一个receiver可以对应一组邮件通知配置email_configs，如下所示： 123name: &lt;string&gt;email_configs: [ - &lt;email_config&gt;, ... ] email_config配置： 123456789101112131415161718192021222324252627# Whether or not to notify about resolved alerts.[ send_resolved: &lt;boolean&gt; | default = false ]# The email address to send notifications to.to: &lt;tmpl_string&gt;# The sender address.[ from: &lt;tmpl_string&gt; | default = global.smtp_from ]# The SMTP host through which emails are sent.[ smarthost: &lt;string&gt; | default = global.smtp_smarthost ]# SMTP authentication information.[ auth_username: &lt;string&gt; | default = global.smtp_auth_username ][ auth_password: &lt;secret&gt; | default = global.smtp_auth_password ][ auth_secret: &lt;secret&gt; | default = global.smtp_auth_secret ][ auth_identity: &lt;string&gt; | default = global.smtp_auth_identity ]# The SMTP TLS requirement.[ require_tls: &lt;bool&gt; | default = global.smtp_require_tls ]# The HTML body of the email notification.[ html: &lt;tmpl_string&gt; | default = '&#123;&#123; template "email.default.html" . &#125;&#125;' ]# Further headers email header key/value pairs. Overrides any headers# previously set by the notification implementation.[ headers: &#123; &lt;string&gt;: &lt;tmpl_string&gt;, ... &#125; ] 如果所有的邮件配置使用了相同的SMTP配置，则可以直接定义全局的SMTP配置： 12345678global: [ smtp_from: &lt;tmpl_string&gt; ] [ smtp_smarthost: &lt;string&gt; ] [ smtp_auth_username: &lt;string&gt; ] [ smtp_auth_password: &lt;secret&gt; ] [ smtp_auth_secret: &lt;secret&gt; ] [ smtp_auth_identity: &lt;string&gt; ] [ smtp_require_tls: &lt;bool&gt; | default = true ] 以Gmail邮箱为例: 1234567891011global: smtp_smarthost: smtp.gmail.com:587 smtp_from: &lt;smtp mail from&gt; smtp_auth_username: &lt;usernae&gt; smtp_auth_identity: &lt;username&gt; smtp_auth_password: &lt;password&gt;receivers: - name: default-receiver email_configs: - to: &lt;mail to address&gt; 手动拉高CPU使用量后会触发告警并发送告警邮件： 1cat /dev/zero&gt;/dev/null 参考文档https://www.troyying.xyz/index.php/operate/15.html]]></content>
      <categories>
        <category>Kubernetes笔记</category>
      </categories>
      <tags>
        <tag>Prometheus Operator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 帮助查看]]></title>
    <url>%2F2018%2F09%2F10%2FSaltStack-%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[SaltStack 查看帮助 查看所有 module 列表查看 Minion端 支持的所有 module 列表&#39;*&#39; sys.list.module1salt &apos;*&apos; sys.list.module 查看指定 module 的所有 function查看 cmd module 的所有 function 的命令1salt '*' sys.list_functions cmd 查看 所有 模块函数帮助信息1salt '*' sys.doc | less 查看指定 module 用法查看 cmd module 的详细用法与示例1salt '*' sys.doc cmd 查看所有 states 列表查看 Minion端 支持的所有 states 列表1salt '*' sys.list_state_modules 查看指定 states 的所有 function查看 file.states 的所有 function1salt '*' sys.list_state_functions file 查看指定 states 用法查看 file.states 的详细用法与示例1salt '*' sys.state_doc file 查看指定 states 指定 function 用法查看 file.managed states 的详细用法与示例1salt '*' sys.state_doc file.managed]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack 帮助查看</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab持续集成-(.gitlab-ci.yml)]]></title>
    <url>%2F2018%2F09%2F08%2FGitLab%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-(.gitlab-ci.yml)%2F</url>
    <content type="text"><![CDATA[GitLab持续集成-(.gitlab-ci.yml) 从7.12版本开始，GitLab CI使用YAML文件(.gitlab-ci.yml)来管理项目配置。该文件存放于项目仓库的根目录，它定义该项目如何构建。 stages stages用来定义可以被job调用的stages。stages的规范允许有灵活的多级pipelines。stages中元素的顺序决定了对应job的执行顺序： 相同stage的job是并行执行的； 下一个stage的job在前一个stage的job成功完成后才开始执行； 如果.gitlab-ci.yml中没有定义stages，那么stages默认定义为build、test和deploy； 如果一个job没有指定stage，那么这个任务会分配到test stage。 variables variables用来定义变量，全局变量作用于所有job，也可以在指定的job中定义变量（优先级高于全局变量）如果在job中想禁用全局定义的变量，可通过variables: {}定义一个空的哈希值。 GitLab CI/CD内置变量 variables 变量值 CI_JOB_NAME 对应的job_name GIT_STRATEGY 指定git获取代码的方式（clone,fetch,none） jobs jobs用来定义了一组作业，其中必须包含script语句。 job.stage（默认：test） job中指定的stage必须是stages中存在的元素 job.tags 指定该job所允许运行的Runner，必须在注册Runner时设置Runner的tag job.allow_failure 用于指定该job允许执行失败，则如果执行失败也不会影响下一个stage的执行。 job.script script是job中必须指定的语句，指定Runner所要执行的命令 job.before_script、job.after_script 指定script执行前/后所执行的命令，也可定义在全局模式，则在所有job中的script执行前/后都会执行。 job.artifacts 用于指定job执行成功后，将会被发送到Gitlab中的文件，且默认情况下job之间会根据stage的优先级自动下载之前所有stage中的artifacts。 artifacts.paths：必选 artifacts.name：指定artifact的名称，同时Gitlab上下载的文件名即为artifact_name.zip artifacts.when：指定artifact上传到Gitlab的条件（on_success[默认],on_failure,always） artifacts.expire_in：指定artifact的过期时间（默认为30天），使用keep可永久保存 job.dependencies dependencies用于在不同的job之间指定在不同的job之间传递artifacts，dependencies: []可禁止该job下载artifacts job.only、job.except only和except是两个参数用分支策略来限制jobs构建 only和except可同时使用。如果在一个job配置中同时存在，则同时有效； only和except可以使用正则表达式； only和except允许使用特殊的关键字：branches，tags和triggers； job.environment environment用于定义job部署到指定的运行环境中。 environment.name：必选，指定environment名称 environment.url：可选，指定environment对应的URL，将在指定的environment页面中添加一个链接按钮指向该URL 特殊的YAML特性 Hidden keys（jobs） 如果想临时disable某个job，不必注释整个job定义的行，只需在job name前加一个.即可 123456.compile_centos: stage: build_centos tags: - centos script: - echo "##### build library" Anchors 锚点可用于在文件中复制或继承配置，一般与Hidden keys（jobs）提供的job模版搭配使用。 12345678910111213.job_template: &amp;job_definition #job中定义一个anchor:job_definition image: ruby:2.1 services: - postgres - redistest1: &lt;&lt;: *job_definition #合并anchor:job_definition中的模版内容 script: - test1 projecttest2: &lt;&lt;: *job_definition script: - test2 project 最终实现的效果如下： 12345678910111213141516171819.job_template: image: ruby:2.1 services: - postgres - redistest1: image: ruby:2.1 services: - postgres - redis script: - test1 projecttest2: image: ruby:2.1 services: - postgres - redis script: - test2 project Skipping jobs 如果你的commit信息中包含[ci skip]或者[skip ci]，不论大小写，那么这个commit将会创建但是jobs也会跳过。 example: 以下示例为编译nginx的上传模块nginx-upload并测试验证上传功能，验证成功后将自动将编译好的文件打包通过curl上传到指定的文件服务器。其中只有在非master的branches中提交代码才会执行build和test的stage，只有在打tag后才会执行deploy，且需要手动在gitlab上执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102variables: DIR: nginx TOPNODE: package.function: &amp;function | function build() &#123; echo "execute function:build" chmod +x auto/configure sh build.sh &#125; function changelog() &#123; echo "execute function:changelog" git log --graph -n 3 --name-status --pretty="%h -[%cd] - &lt;%an&gt; %s" &gt; CHANGELOG &#125; function test() &#123; echo "execute function:test" sudo \cp modules/nginx-upload-module-master/nginx.conf /etc/nginx/nginx.conf sudo sed -i '/error_log/,/working_directory/d' /etc/nginx/nginx.conf if [ -f /run/nginx.pid ];then sudo nginx -s reload;else sudo nginx;fi sudo rm -rf /tmp/&#123;0,1,2,3,4,5,6,7,8,9&#125; &amp;&amp; sudo mkdir /tmp/&#123;0,1,2,3,4,5,6,7,8,9&#125; &amp;&amp; sudo chown -R nginx. /tmp/&#123;0,1,2,3,4,5,6,7,8,9&#125; sudo echo nginx_upload &gt; test &amp;&amp; curl -F "filename=@test" http://localhost/upload sudo find /tmp/&#123;0,1,2,3,4,5,6,7,8,9&#125; -type f -exec grep nginx_upload &#123;&#125; \; &#125; function artifacts() &#123; echo "execute function:artifacts" URL="https://xxx.com/upload?dir=$&#123;DIR&#125;/$&#123;VERSION&#125;&amp;override=1&amp;topNode=$&#123;TOPNODE&#125;" echo "push the artifacts:nginx_$&#123;VERSION&#125;.tar.gz to $URL" tar zcf /tmp/nginx_$&#123;VERSION&#125;.tar.gz --exclude=".git*" --exclude=build . curl -F "filename=@/tmp/$&#123;DIR&#125;_$&#123;VERSION&#125;.tar.gz" "$URL" echo "push the CHANGELOG to $URL" curl -F "filename=@CHANGELOG" "$URL" &#125; function deploy() &#123; echo "execute function:deploy" &#125; function clean() &#123; echo "execute function:clean" if [ -f /run/nginx.pid ];then sudo kill `cat /run/nginx.pid`;fi sudo rm -rf /tmp/&#123;0,1,2,3,4,5,6,7,8,9&#125; /tmp/nginx_$&#123;version&#125;.tar.gz &#125;#########only the section above need to be modify #################before_script: - VERSION=`head -n1 version` - *functionstages: - build - test - deploybuild: stage: build only: - branches except: - master script: - build - changelogtest: stage: test variables: GIT_STRATEGY: none only: - branches except: - master script: - test - artifacts - clean.job_template: &amp;deploy_template stage: deploy variables: GIT_STRATEGY: none only: - tags script: - deploy - delete when: manualstaging: &lt;&lt;: *deploy_template environment: name: stagingproduction: &lt;&lt;: *deploy_template environment: name: production 参考文档http://blog.51cto.com/vnimos/2122951]]></content>
      <categories>
        <category>Git笔记</category>
      </categories>
      <tags>
        <tag>GitLab持续集成-(.gitlab-ci.yml)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab-CI 与 GitLab-Runner]]></title>
    <url>%2F2018%2F09%2F08%2FGitLab-CI-%E4%B8%8E-GitLab-Runner%2F</url>
    <content type="text"><![CDATA[GitLab-CI 与 GitLab-Runner 持续集成（Continuous Integration）要了解 GitLab-CI 与 GitLab Runner，我们得先了解持续集成是什么。 持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。 看完这段话，估计还是有点懵。怎么理解呢？我是这样理解的： 软件集成 是软件开发过程中的一个环节，这个环节的工作一般会包括以下流程：合并代码 —-&gt; 安装依赖 —-&gt; 编译 —-&gt; 测试 —-&gt; 发布。软件集成的工作一般会比较细碎繁琐，为了不影响开发效率，以前软件集成这个环节一般不会经常进行或者只会等到项目后期再进行。但是有些问题，如果等到后期才发现，解决问题的代价很大，有可能导致项目延期或者失败。因此，为了尽早发现软件集成错误，鼓励团队成员应该经常集成他们的工作，通常每个成员每天应该至少集成一次。这就是所说的 持续集成。所以说，持续集成是一种软件开发实践。 软件集成的工作细碎繁琐，以前是由人工完成的。但是现在鼓励持续集成，那岂不是要累死人，还影响开发效率。所以，应该考虑将软件集成这个工作自动化，这就出现了所谓的 持续集成系统。 持续集成详情见百度百科-持续集成 GitLab-CIGitLab-CI 就是一套配合 GitLab 使用的持续集成系统（当然，还有其它的持续集成系统，同样可以配合 GitLab 使用，比如 Jenkins）。而且 GitLab8.0 以后的版本是默认集成了 GitLab-CI 并且默认启用的。 GitLab-Runner那 GitLab-Runner 又是什么？和 GitLab-CI 有什么关系？ GitLab-Runner 是配合 GitLab-CI 进行使用的。一般地，GitLab 里面的每一个工程都会定义一个属于这个工程的软件集成脚本，用来自动化地完成一些软件集成工作。当这个工程的仓库代码发生变动时，比如有人 push 了代码，GitLab 就会将这个变动通知 GitLab-CI。这时 GitLab-CI 会找出与这个工程相关联的 Runner，并通知这些 Runner 把代码更新到本地并执行预定义好的执行脚本。 所以，GitLab-Runner 就是一个用来执行软件集成脚本的东西。可以想象一下：Runner 就像一个个的工人，而 GitLab-CI就是这些工人的一个管理中心，所有工人都要在 GitLab-CI 里面登记注册，并且表明自己是为哪个工程服务的。当相应的工程发生变化时，GitLab-CI 就会通知相应的工人执行软件集成脚本。如下图所示： GitLab-CI 与 GitLab-Runner 关系示意图 Runner 可以分布在不同的主机上，同一个主机上也可以有多个Runner。 Runner类型GitLab-Runner 可以分类两种类型：Shared Runner（共享型） 和 Specific Runner（指定型）。Shared Runner： 这种 Runner（工人）是所有工程都能够用的。只有系统管理员能够创建Shared Runner。Specific Runner： 这种 Runner（工人）只能为指定的工程服务。拥有该工程访问权限的人都能够为该工程创建 Shared Runner。 GitLab-Runner 的安装与使用操作系统：Centos 7.0 64位 安装 gitlab-ci-multi-runner 添加 yum 源 1curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash 安装 1yum -y install gitlab-ci-multi-runner 这里是官网的安装教程，其它操作系统的请参考 https://gitlab.com/gitlab-org/gitlab-ci-multi-runner 使用 gitlab-ci-multi-runner 注册 Runner安装好 gitlab-ci-multi-runner 这个软件之后，我们就可以用它向 GitLab-CI 注册 Runner 了。 向 GitLab-CI 注册一个 Runner 需要两样东西：GitLab-CI的url 和 注册token。其中，token 是为了确定你这个 Runner 是所有工程都能够使用的 Shared Runner 还是具体某一个工程才能使用的Specific Runner。 如果要注册 Shared Runner，你需要到管理界面的 Runners 页面里面去找注册 token。如下图所示： Shared Runner 如果要注册 Specific Runner，你需要到项目的设置的 Runner 页面里面去找注册 token。如下图所示： Specific Runner 找到 token 之后，运行下面这条命令注册 Runner（当然，除了 url 和 token 之外，还需要其他的信息，比如执行器 executor、构建目录 builds_dir 等）。 gitlab-ci-multi-runner register 注册完成之后，GitLab-CI 就会多出一条 Runner 记录，如下图所示： GitLab-CI Runner GitLab-CI 会为这个 Runner 生成一个唯一的 token，以后 Runner 就通过这个 token 与 GitLab-CI 进行通信。 那么，问题来了。注册好了的 Runner 的信息存放在哪儿了呢？原来，Runner 的信息是存放在一个配置文件里面的，配置文件的格式一般是 .toml。这个配置文件的存放位置有以下几种情况： 在类Unix操作系统下（0.5.0之后版本） 如果是以 root 用户身份运行 gitlab-ci-multi-runner register，那么配置文件默认是 /etc/gitlab-runner/config.toml 如果是以非 root 用户身份运行 gitlab-ci-multi-runner register，那么配置文件默认是 ~/.gitlab-runner/config.toml 在其他操作系统下以及 0.5.0 之前版本配置文件默认在当前工作目录下./config.toml 一般情况下，使用默认的配置文件存放 Runner 的配置信息就可以了。当然，如果你有更细化的分类需求，你也可以在注册的时候通过 -c 或 --config 选项指定配置文件的位置。具体查看register 命令的使用方法：gitlab-ci-multi-runner register --help。 问题： 如果不运行 gitlab-ci-multi-runner register 命令，直接在配置文件里面添加 Runner 的配置信息可以吗？回答： 当然不可以。因为 gitlab-ci-multi-runner register 的作用除了把 Runner 的信息保存到配置文件以外，还有一个很重要的作用，那就是向 GitLab-CI 发出请求，在 GitLab-CI 中登记这个 Runner 的信息并且获取后续通信所需要的 token。 让注册好的 Runner 运行起来Runner 注册完成之后还不行，还必须让它运行起来，否则它无法接收到 GitLab-CI 的通知并且执行软件集成脚本。怎么让 Runner 运行起来呢？gitlab-ci-multi-runner 提供了这样一条命令gitlab-ci-multi-runner run-single，详情如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost ~]# gitlab-ci-multi-runner run-single --helpNAME: run-single - start single runnerUSAGE: command run-single [command options] [arguments...]OPTIONS: --name, --description Runner name [$RUNNER_NAME] --limit Maximum number of builds processed by this runner [$RUNNER_LIMIT] --ouput-limit Maximum build trace size [$RUNNER_OUTPUT_LIMIT] -u, --url Runner URL [$CI_SERVER_URL] -t, --token Runner token [$CI_SERVER_TOKEN] --tls-ca-file File containing the certificates to verify the peer when using HTTPS [$CI_SERVER_TLS_CA_FILE] --executor Select executor, eg. shell, docker, etc. [$RUNNER_EXECUTOR] --builds-dir Directory where builds are stored [$RUNNER_BUILDS_DIR] --cache-dir Directory where build cache is stored [$RUNNER_CACHE_DIR] --env Custom environment variables injected to build environment [$RUNNER_ENV] --shell Select bash, cmd or powershell [$RUNNER_SHELL] --ssh-user User name [$SSH_USER] --ssh-password User password [$SSH_PASSWORD] --ssh-host Remote host [$SSH_HOST] --ssh-port Remote host port [$SSH_PORT] --ssh-identity-file Identity file to be used [$SSH_IDENTITY_FILE] --docker-host Docker daemon address [$DOCKER_HOST] --docker-cert-path Certificate path [$DOCKER_CERT_PATH] --docker-tlsverify Use TLS and verify the remote [$DOCKER_TLS_VERIFY] --docker-hostname Custom container hostname [$DOCKER_HOSTNAME] --docker-image Docker image to be used [$DOCKER_IMAGE] --docker-privileged Give extended privileges to container [$DOCKER_PRIVILEGED] --docker-disable-cache Disable all container caching [$DOCKER_DISABLE_CACHE] --docker-volumes Bind mount a volumes [$DOCKER_VOLUMES] --docker-cache-dir Directory where to store caches [$DOCKER_CACHE_DIR] --docker-extra-hosts Add a custom host-to-IP mapping [$DOCKER_EXTRA_HOSTS] --docker-links Add link to another container [$DOCKER_LINKS] --docker-services Add service that is started with container [$DOCKER_SERVICES] --docker-wait-for-services-timeout How long to wait for service startup [$DOCKER_WAIT_FOR_SERVICES_TIMEOUT] --docker-allowed-images Whitelist allowed images [$DOCKER_ALLOWED_IMAGES] --docker-allowed-services Whitelist allowed services [$DOCKER_ALLOWED_SERVICES] --docker-image-ttl [$DOCKER_IMAGE_TTL] --parallels-base-name VM name to be used [$PARALLELS_BASE_NAME] --parallels-template-name VM template to be created [$PARALLELS_TEMPLATE_NAME] --parallels-disable-snapshots Disable snapshoting to speedup VM creation [$PARALLELS_DISABLE_SNAPSHOTS] --virtualbox-base-name VM name to be used [$VIRTUALBOX_BASE_NAME] --virtualbox-disable-snapshots Disable snapshoting to speedup VM creation [$VIRTUALBOX_DISABLE_SNAPSHOTS] 要让一个 Runner 运行起来，--url、--token 和 --executor 选项是必要的。其他选项可根据具体情况和需求进行设置。我们可以看出来，这个命令里面的选项跟配置文件中 Runner 的配置项基本上是一样的。那这个命令的运行和配置文件有没有什么关系呢？从我的试验和思考来看，应该是没有什么关系的。因为： 这个命令里面并没有指定配置文件位置的选项，如果读取配置文件难道去读取默认位置吗？但是配置文件的位置是可以指定的，不一定在默认位置，这不符合逻辑，所以它应该不会去读配置文件。 我删掉配置文件，这个命令依然能够运行 所以，这个命令应该只是一个能让 Runner 运行起来的基础命令。但这个命令运行起来的前提是，GitLab-CI 中必须事先注册有这个 Runner。 那配置文件有毛用？配置文件的作用在后面，但是从这里我们知道一点：配置文件里面有 Runner运行时所需要的信息。 可能你还有一个问题：我用 root 的用户注册 Runner 时，注册完 Runner 就可以用了，并没有手动地去运行 Runner 啊？这个后面讲。 批量地运行 Runner正常情况下，如果我有多个 Runner，我并不想手动一个个地运行，要是能一次运行多个 Runner 多爽啊！嗯哼，gitlab-ci-multi-runner 就提供了这样一个命令 gitlab-ci-multi-runner run，详情如下： 12345678910111213[root@localhost gitlab-runner]# gitlab-ci-multi-runner run --helpNAME: run - run multi runner serviceUSAGE: command run [command options] [arguments...]OPTIONS: -c, --config "/etc/gitlab-runner/config.toml" Config file [$CONFIG_FILE] -n, --service "gitlab-runner" Use different names for different services -d, --working-directory Specify custom working directory -u, --user Use specific user to execute shell scripts --syslog Log to syslog 这个命令总共有 5 个选项，让我们从选项来理解一下这个命令： -c, --config 选项这个选项是用来指定配置文件路径的。如果你想同时运行多个 Runner，你必须得知道你要运行哪些 Runner 以及这些 Runner 运行时所需要的信息。而前面我们说过，配置文件里面就存放着 Runner 运行时所需要的信息。而且一个配置文件是可以存放多个 Runner 的信息的。如果不指定这个选项，就会使用默认的配置文件。 -n, --service 选项这个选项是用来指定服务的别名的。为什么要有这个选项呢？指定别名有什么意义呢？我们从上一个选项可以看出来，一次只能运行一批 Runner，因为一次只能指定一个配置文件。那如果我有多个配置文件，我要运行多批 Runner，那是不是给每一次批量运行服务取不同的别名来区分更好一点呢。 -d, --working-directory 选项这个选项是用来指定此次批量运行服务的工作目录的。如果自己没有指定 builds_dir 的话，此次运行起来的 Runner 会把 builds_dir 放到这个目录里面。 -u, --user 选项这个选项很重要，它指定了该以什么用户权限来运行 Runner。为了安全，我认为不应该给运行 Runner 的用户过高的权限，更不应该以 root 用户来运行 Runner。 --syslog 选项如果指定了这个选项，则把日志记录到系统日志。 使用服务能够批量地运行 Runner 已经很好了，但是还不够好，为什么呢？ 首先，gitlab-ci-multi-runner run 默认是前台运行的，使用体验不好；其次，当 gitlab-ci-multi-runner run 在后台运行的时候，要查看其运行状态不方便，而且也没有提供停止 gitlab-ci-multi-runner run 的命令。 所以，要是能将批量运行Runner这个功能安装为一项服务，就更爽了！ gitlab-ci-multi-runner 确实就提供了这样的功能。install、uninstall、start、stop、restart、status 这 6 个命令就是和服务相关的。我一开始对 gitlab-ci-multi-runner 的服务概念感觉比较懵，让我们来看看安装服务 install 这个命令到底干了一件什么事情。 123456789101112[root@localhost ~]# gitlab-ci-multi-runner install --helpNAME: install - install serviceUSAGE: command install [command options] [arguments...]OPTIONS: --service, -n "gitlab-runner" Specify service name to use --working-directory, -d "/root" Specify custom root directory where all data are stored --config, -c "/etc/gitlab-runner/config.toml" Specify custom config file --user, -u Specify user-name to secure the runner 从选项可以看出，一项服务的信息有 4 个：服务名、工作目录、配置文件和用户。这个命令的选项和 gitlab-ci-multi-runner run 的选项基本一样。可见，批量运行 Runner 和服务之间的关系暧昧。至于是什么关系，往下看 gitlab-ci-multi-runner start 这个命令。 123456789[root@localhost ~]# gitlab-ci-multi-runner start --helpNAME: start - start serviceUSAGE: command start [command options] [arguments...]OPTIONS: --service, -n "gitlab-runner" Specify service name to use 启动一项服务，只要指定服务的名称就行了（默认服务名称是 gitlab-runner）。启动服务后，运行命令 ps -aux | grep gitlab-runner 查看后台程序，发现启动服务其实就是在后台执行了一个批量运行Runner的任务，所以服务安装命令的选项才会和批量运行 Runner 命令的选项基本一样。 1root 18219 0.0 0.1 331872 5332 ? Ssl 00:06 0:00 /usr/bin/gitlab-ci-multi-runner run --working-directory /home/gitlab-runner --config /etc/gitlab-runner/config.toml --service gitlab-runner --user gitlab-runner --syslog 还有 stop 命令用于停止服务，restart 命令用于重启服务，status 用于查看服务状态。这三个命令的使用方法和 start 类似，就不一一介绍了。 其他一些思考 什么情况下需要注册 Shared Runner？比如，GitLab 上面所有的工程都有可能需要在公司的服务器上进行编译、测试、部署等工作，这个时候注册一个Shared Runner 供所有工程使用就很合适。 什么情况下需要注册 Specific Runner？比如，我可能需要在我个人的电脑或者服务器上自动构建我参与的某个工程，这个时候注册一个 Specific Runner 就很合适。 什么情况下需要在同一台机器上注册多个 Runner？比如，我是 GitLab 的普通用户，没有管理员权限，我同时参与多个项目，那我就需要为我的所有项目都注册一个 Specific Runner，这个时候就需要在同一台机器上注册多个 Runner。 参考文档https://www.jianshu.com/p/2b43151fb92e]]></content>
      <categories>
        <category>Git笔记</category>
      </categories>
      <tags>
        <tag>GitLab-CI 与 GitLab-Runner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack states sls 状态管理]]></title>
    <url>%2F2018%2F09%2F06%2FSaltStack-states-sls-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[SaltStack states sls 状态管理 开启 file_roots 状态管理123456789101112131415161718192021222324[root@master01 ~]# cd /etc/salt/[root@master01 salt]# vim /etc/salt/master...省略...# file_roots:# base:# - /srv/salt/# dev:# - /srv/salt/dev/services# - /srv/salt/dev/states# prod:# - /srv/salt/prod/services# - /srv/salt/prod/states#file_roots: # 打开这段注释 base: - /srv/salt...省略...:wq保存退出# 创建 mkdir -pv /srv/salt 目录[root@master01 ~]# mkdir -pv /srv/salt# 重启 Master端服务systemctl restart salt-master 默认必须有一个 base 环境可以指定多个环境：基准环境(base)，开发环境(dev)，生产环境(prod) 编辑 sls 状态配置123456789101112[root@master01 ~]# cd /srv/salt/[root@master01 salt]# vim /srv/salt/nginx.slsnginx-install: # 自定义名称 pkg.installed: # 模块.方法 - names: - nginxnginx-servcice: # 自定义名称 service.running: # 模块.方法 - name: nginx # nginx 服务名 - enable: True # 开机自启 - reload: True # 开启重新加载 执行salt &#39;*&#39; 模块.方法 sls文件1[root@master01 ~]# salt '*' state.sls nginx salt ‘*’ 意思是在所有机器上执行 nginx 这个状态(sls) 如果没有指定 -name: nginx 服务名，会报 Result 失败命名服务 nginx-service 不可用，因为会把 nginx-service 当成服务名另一个办法是把 nginx-service 改成 nginx，-name: nginx 就不用写了12345678---------- ID: nginx-service Function: service.running Result: False Comment: The named service nginx-service is not available Started: 01:38:22.609850 Duration: 108.528 ms Changes: salt ‘minion01’ 指定在 minion01 机器上执行 nginx 这个状态(sls)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970[root@master01 ~]# salt 'minion01' state.sls nginxminion01:---------- ID: nginx-install Function: pkg.installed Name: nginx Result: True Comment: The following packages were installed/updated: nginx Started: 01:40:29.448702 Duration: 8950.813 ms Changes: ---------- nginx: ---------- new: 1:1.12.2-2.el7 old: nginx-all-modules: ---------- new: 1:1.12.2-2.el7 old: nginx-mod-http-geoip: ---------- new: 1:1.12.2-2.el7 old: nginx-mod-http-image-filter: ---------- new: 1:1.12.2-2.el7 old: nginx-mod-http-perl: ---------- new: 1:1.12.2-2.el7 old: nginx-mod-http-xslt-filter: ---------- new: 1:1.12.2-2.el7 old: nginx-mod-mail: ---------- new: 1:1.12.2-2.el7 old: nginx-mod-stream: ---------- new: 1:1.12.2-2.el7 old:---------- ID: nginx Function: service.running Result: True Comment: Service nginx has been enabled, and is running Started: 01:40:38.412396 Duration: 732.741 ms Changes: ---------- nginx: TrueSummary------------Succeeded: 2 (changed=2)Failed: 0------------Total states run: 2 在 Minion 端查看 12[root@minion01 ~]# watch 'ps -ef | grep yum'[root@minion01 ~]# lsof -i:80 一台机器可能不止一种状态(sls)配置，可能有多个状态(sls)配置可以使用高级状态(sls)配置写一个入口文件 topfile一般入口文件名为 top.sls1234[root@master01 ~]# vim /srv/salt/top.slsbase: # 在 base 下 '*': # 在 '*' 所有主机上 - nginx # 执行 nginx 这个 sls 1234[root@master01 ~]# vim /srv/salt/top.slsbase: # 在 base 下 'minion01': # 在 minion01 主机上 - nginx # 执行 nginx 这个 sls 执行salt &#39;*&#39; 模块.高级状态 1[root@master01 ~]# salt '*' state.highstate 从入口文件开始读，从 topfile 开始读topfile 里包含了哪些普通状态(sls)，就执行哪些状态(sls)远程执行，状态管理]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack states sls 状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 数据系统 Pillar]]></title>
    <url>%2F2018%2F09%2F06%2FSaltStack-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F-Pillar%2F</url>
    <content type="text"><![CDATA[SaltStack 数据系统 Pillar 名称 存储位置 数据类型 数据采集更新方式 应用 Grains Minion端 静态数据 Minion启动时收集，也可以使用 saltutil.sync_grains 进行刷新 存储 Minion 基本数据，比如用于匹配 Minion，自身数据可以用来作资产管理等。 Pillar Master端 动态数据 在Master端定义，指定给对应的Minion。可以使用 saltutil.refresh_pillar 刷新 存储 Master 指定的数据，只有指定的 Minion 可以看到。用于敏感数据保存。 Pillar 是在 Master端 设置的Pillar 给 Minion端 指定它想要的数据安全性比较高 查看 Pillar 信息默认是 False 状态12345[root@master01 ~]# salt '*' pillar.itemsdbfw01: ----------minion01: ---------- 开启查看 Pillar 状态，一般不用打开 1234567891011[root@master01 ~]# cd /etc/salt/[root@master01 ~]# vim /etc/salt/master...省略...#pillar_opts: False改成pillar_opts: True...省略...:wq保存退出# 重启 salt-master 服务systemctl restart salt-master 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342[root@master01 salt]# salt 'minion01' pillar.itemsminion01: ---------- master: ---------- __role: master auth_mode: 1 auto_accept: False cache_sreqs: True cachedir: /var/cache/salt/master cli_summary: False client_acl: ---------- client_acl_blacklist: ---------- cluster_masters: cluster_mode: paranoid con_cache: False conf_file: /etc/salt/master config_dir: /etc/salt cython_enable: False daemon: False default_include: master.d/*.conf enable_gpu_grains: False enforce_mine_cache: False enumerate_proxy_minions: False environment: None event_return: event_return_blacklist: event_return_queue: 0 event_return_whitelist: ext_job_cache: ext_pillar: extension_modules: /var/cache/salt/extmods external_auth: ---------- failhard: False file_buffer_size: 1048576 file_client: local file_ignore_glob: None file_ignore_regex: None file_recv: False file_recv_max_size: 100 file_roots: ---------- base: - /srv/salt fileserver_backend: - roots fileserver_followsymlinks: True fileserver_ignoresymlinks: False fileserver_limit_traversal: False gather_job_timeout: 10 gitfs_base: master gitfs_env_blacklist: gitfs_env_whitelist: gitfs_insecure_auth: False gitfs_mountpoint: gitfs_passphrase: gitfs_password: gitfs_privkey: gitfs_pubkey: gitfs_remotes: gitfs_root: gitfs_user: hash_type: md5 hgfs_base: default hgfs_branch_method: branches hgfs_env_blacklist: hgfs_env_whitelist: hgfs_mountpoint: hgfs_remotes: hgfs_root: id: minion01 interface: 0.0.0.0 ioflo_console_logdir: ioflo_period: 0.01 ioflo_realtime: True ioflo_verbose: 0 ipv6: False jinja_lstrip_blocks: False jinja_trim_blocks: False job_cache: True keep_jobs: 24 key_logfile: /var/log/salt/key keysize: 2048 log_datefmt: %H:%M:%S log_datefmt_logfile: %Y-%m-%d %H:%M:%S log_file: /var/log/salt/master log_fmt_console: [%(levelname)-8s] %(message)s log_fmt_logfile: %(asctime)s,%(msecs)03.0f [%(name)-17s][%(levelname)-8s][%(process)d] %(message)s log_granular_levels: ---------- log_level: warning loop_interval: 60 maintenance_floscript: /usr/lib/python2.7/site-packages/salt/daemons/flo/maint.flo master_floscript: /usr/lib/python2.7/site-packages/salt/daemons/flo/master.flo master_job_cache: local_cache master_pubkey_signature: master_pubkey_signature master_roots: ---------- base: - /srv/salt-master master_sign_key_name: master_sign master_sign_pubkey: False master_tops: ---------- master_use_pubkey_signature: False max_event_size: 1048576 max_minions: 0 max_open_files: 100000 minion_data_cache: True minionfs_blacklist: minionfs_env: base minionfs_mountpoint: minionfs_whitelist: nodegroups: ---------- open_mode: False order_masters: False outputter_dirs: peer: ---------- permissive_pki_access: False pidfile: /var/run/salt-master.pid pillar_opts: True pillar_roots: ---------- base: - /srv/pillar pillar_safe_render_error: True pillar_source_merging_strategy: smart pillar_version: 2 pillarenv: None ping_on_rotate: False pki_dir: /etc/salt/pki/master preserve_minion_cache: False pub_hwm: 1000 publish_port: 4505 publish_session: 86400 queue_dirs: raet_alt_port: 4511 raet_clear_remotes: False raet_main: True raet_mutable: False raet_port: 4506 range_server: range:80 reactor: reactor_refresh_interval: 60 reactor_worker_hwm: 10000 reactor_worker_threads: 10 renderer: yaml_jinja ret_port: 4506 root_dir: / rotate_aes_key: True runner_dirs: saltversion: 2015.5.10 search: search_index_interval: 3600 serial: msgpack show_jid: False show_timeout: True sign_pub_messages: False sock_dir: /var/run/salt/master sqlite_queue_dir: /var/cache/salt/master/queues ssh_passwd: ssh_port: 22 ssh_scan_ports: 22 ssh_scan_timeout: 0.01 ssh_sudo: False ssh_timeout: 60 ssh_user: root state_aggregate: False state_auto_order: True state_events: False state_output: full state_top: salt://top.sls state_top_saltenv: None state_verbose: True sudo_acl: False svnfs_branches: branches svnfs_env_blacklist: svnfs_env_whitelist: svnfs_mountpoint: svnfs_remotes: svnfs_root: svnfs_tags: tags svnfs_trunk: trunk syndic_dir: /var/cache/salt/master/syndics syndic_event_forward_timeout: 0.5 syndic_jid_forward_cache_hwm: 100 syndic_master: syndic_max_event_process_time: 0.5 syndic_wait: 5 timeout: 5 token_dir: /var/cache/salt/master/tokens token_expire: 43200 transport: zeromq user: root verify_env: True win_gitrepos: - https://github.com/saltstack/salt-winrepo.git win_repo: /srv/salt/win/repo win_repo_mastercachefile: /srv/salt/win/repo/winrepo.p worker_floscript: /usr/lib/python2.7/site-packages/salt/daemons/flo/worker.flo worker_threads: 5 zmq_filtering: False Pillar 应用场景用于敏感数据，给某一个配置文件设置一个密码，这个密码只希望指定 minion 能看到使用 Pillar 来处理变量差异性 定义 Pillar 数据 打开 pillar_roots 配置12345678910[root@master01 ~]# vim /etc/salt/master...省略...pillar_roots: base: - /srv/pillar...省略...:wq 保存退出# 重启 salt-master 服务systemctl restart salt-master 注意：base 环境是必须有的基础环境，和 topfile 里是对应的可以配置多个环境存放在 /srv/pillar 目录下Pillar 也有 topfile，可以指定哪个 Minion 能看到哪一个topfile 必须放在 base 环境下 123456789[root@master01 ~]# mkdir -pv /srv/pillar[root@master01 ~]# cd /srv/pillar/[root@master01 pillar]# vim /srv/pillar/apache.sls&#123;% if grains['os'] == 'CentOS' %&#125;apache: httpd&#123;% elif grains['os'] == 'Debian' %&#125;apache: apache2&#123;% endif %&#125;:wq 保存退出 将 apache.sls 指定哪个 Minion 能看到12345[root@master01 ~]# cd /srv/pillar/[root@master01 pillar]# vim /srv/pillar/top.slsbase: '*': - apache 让所有机器都能看到这个 apache.sls 的 Pillar 123456789[root@master01 pillar]# salt '*' pillar.itemsdbfw01: ---------- apache: httpdminion01: ---------- apache: httpd 获取到了 apache 的 pillar，值都是 httpd，因为都是 CentOS 的机器，如果是 Ubuntu 的机器就会显示 apache2 Pillar 主要用于做配置管理，用来定义一些变量和参数，比如：主机名，IP Pillar 定位主机 -I, --pillar 表示使用 Pillar 来匹配设置完 Pillar 后，需要刷新 Pillar 数据信息，使其生效salt &#39;*&#39; saltutil.refresh_pillar 1234567891011[root@master01 pillar]# salt '*' saltutil.refresh_pillardbfw01: Trueminion01: True[root@master01 pillar]# salt -I 'apache:httpd' test.pingdbfw01: Trueminion01: True]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack 数据系统 Pillar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 数据系统 Grains]]></title>
    <url>%2F2018%2F09%2F06%2FSaltStack-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F-Grains%2F</url>
    <content type="text"><![CDATA[SaltStack 数据系统 Grains 名称 存储位置 数据类型 数据采集更新方式 应用 Grains Minion端 静态数据 Minion启动时收集，也可以使用 saltutil.sync_grains 进行刷新 存储 Minion 基本数据，比如用于匹配 Minion，自身数据可以用来作资产管理等。 Pillar Master端 动态数据 在Master端定义，指定给对应的Minion。可以使用 saltutil.refresh_pillar 刷新 存储 Master 指定的数据，只有指定的 Minion 可以看到。用于敏感数据保存。 Grains 存放 minion 启动时收集的系统信息Grains 是存储在 minion 端的只有在 minion 启动时才会进行收集，收集完之后就不变了，等下一次 minion 重启，才会变Grains 收集的数据信息称之为静态数据，重启才会收集，不重启就不变 Grains 在做配置部署的过程中会经常使用到它，Grains 是 SaltStack 记录 Minion 的一些静态信息的组件，我们可以简单地理解为 Grains 里面记录着每台 Minion 的一些常用属性，比如 CPU、内存、磁盘、网络信息等，我们可以通过 granis.items 查看某台 Minion 的所有 Grains 信息，Minion 的 Grains 信息是 Minion 启动的时候采集汇报给 Master 的，在实际应用环境中我们需要根据自己的业务需求去自定义一些 Grains，关于自定义 Grains 的常用方法有以下几种： 通过 Minion 配置文件定义 通过 Grains 相关模块定义 通过 Python 脚本定义 查看 Grains 方法列表1234567891011121314[root@master01 ~]# salt 'minion*' sys.list_functions grainsminion01: - grains.append - grains.delval - grains.filter_by - grains.get - grains.get_or_set_hash - grains.has_value - grains.item - grains.items - grains.ls - grains.remove - grains.setval - grains.setvals 详细用法与例子可以通过以下命令查看 123456789101112131415161718192021222324[root@master01 ~]# salt 'minion*' sys.doc grains'grains.append:' New in version 0.17.0 Append a value to a list in the grains config file. If the grain doesn't exist, the grain key is added and the value is appended to the new grain as a list item. key The grain key to be appended to val The value to append to the grain key...省略...'grains.setvals:' Set new grains values in the grains config file :param Destructive: If an operation results in a key being removed, delete the key, too. Defaults to False. CLI Example: salt '*' grains.setvals "&#123;'key1': 'val1', 'key2': 'val2'&#125;" 通过 sys.doc 查看 grains模块.items方法 的使用方法 123456789101112[root@master01 ~]# salt 'minion*' sys.doc grains.items'grains.items:' Return all of the minion's grains CLI Example: salt '*' grains.items Sanitized CLI Example: salt '*' grains.items sanitize=True Grains 应用场景信息收集列出 Grains 所有的 key123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[root@master01 ~]# salt 'minion*' grains.lsminion01: - SSDs - biosreleasedate - biosversion - cpu_flags - cpu_model - cpuarch - domain - fqdn - fqdn_ip4 - fqdn_ip6 - gpus - host - hwaddr_interfaces - id - init - ip4_interfaces - ip6_interfaces - ip_interfaces - ipv4 - ipv6 - kernel - kernelrelease - locale_info - localhost - lsb_distrib_id - machine_id - manufacturer - master - mdadm - mem_total - nodename - num_cpus - num_gpus - os - os_family - osarch - oscodename - osfinger - osfullname - osmajorrelease - osrelease - osrelease_info - path - productname - ps - pythonexecutable - pythonpath - pythonversion - saltpath - saltversion - saltversioninfo - selinux - serialnumber - server_id - shell - systemd - virtual - zmqversion 显示 grains 所有内容信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195[root@master01 ~]# salt 'minion*' grains.itemsminion01: ---------- SSDs: biosreleasedate: 04/01/2014 biosversion: 1.11.0-2.el7 cpu_flags: - fpu - de - pse - tsc - msr - pae - mce - cx8 - apic - sep - mtrr - pge - mca - cmov - pse36 - clflush - mmx - fxsr - sse - sse2 - ht - syscall - nx - lm - rep_good - nopl - pni - cx16 - x2apic - hypervisor - lahf_lm cpu_model: QEMU Virtual CPU version 2.5+ cpuarch: x86_64 domain: fqdn: minion01 fqdn_ip4: - 192.168.50.208 fqdn_ip6: gpus: |_ ---------- model: GD 5446 vendor: unknown host: minion01 hwaddr_interfaces: ---------- eth0: fa:57:ad:54:77:00 lo: 00:00:00:00:00:00 id: minion01 init: systemd ip4_interfaces: ---------- eth0: - 192.168.50.171 lo: - 127.0.0.1 ip6_interfaces: ---------- eth0: lo: ip_interfaces: ---------- eth0: - 192.168.50.171 lo: - 127.0.0.1 ipv4: - 127.0.0.1 - 192.168.50.171 ipv6: kernel: Linux kernelrelease: 3.10.0-862.el7.x86_64 locale_info: ---------- defaultencoding: UTF-8 defaultlanguage: en_US detectedencoding: UTF-8 localhost: minion01 lsb_distrib_id: CentOS Linux machine_id: 2e1eda950cd34bdd9dc04c8df9294ae0 manufacturer: Red Hat master: 192.168.35.223 mdadm: mem_total: 3772 nodename: minion01 num_cpus: 2 num_gpus: 1 os: CentOS os_family: RedHat osarch: x86_64 oscodename: Core osfinger: CentOS Linux-7 osfullname: CentOS Linux osmajorrelease: 7 osrelease: 7.5.1804 osrelease_info: - 7 - 5 - 1804 path: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin productname: KVM ps: ps -efH pythonexecutable: /usr/bin/python pythonpath: - /usr/bin - /usr/lib64/python27.zip - /usr/lib64/python2.7 - /usr/lib64/python2.7/plat-linux2 - /usr/lib64/python2.7/lib-tk - /usr/lib64/python2.7/lib-old - /usr/lib64/python2.7/lib-dynload - /usr/lib64/python2.7/site-packages - /usr/lib/python2.7/site-packages pythonversion: - 2 - 7 - 5 - final - 0 saltpath: /usr/lib/python2.7/site-packages/salt saltversion: 2015.5.10 saltversioninfo: - 2015 - 5 - 10 - 0 selinux: ---------- enabled: False enforced: Disabled serialnumber: Not Specified server_id: 1223839238 shell: /bin/sh systemd: ---------- features: +PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 -SECCOMP +BLKID +ELFUTILS +KMOD +IDN version: 219 virtual: kvm zmqversion: 3.2.5 显示某个信息内容 显示 fqdn 信息 12345[root@master01 ~]# salt 'minion*' grains.item fqdnminion01: ---------- fqdn: minion01 123[root@master01 ~]# salt 'minion*' grains.get fqdnminion01: minion01 注意：item 和 get 显示的效果不同 查询 eth0 网卡信息123[root@master01 ~]# salt 'minion*' grains.get ip_interfaces:eth0minion01: - 192.168.50.171 在 远程执行里 匹配 Minion 在所有 CentOS 的机器上执行命令 123456789[root@master01 ~]# salt 'minion*' grains.item osminion01: ---------- os: CentOS[root@master01 ~]# salt 'minion*' grains.get osminion01: CentOS 12345[root@master01 ~]# salt '*' grains.get osfingerdbfw01: CentOS-6minion01: CentOS Linux-7 -G： 表示使用 Grains 来匹配1234[root@master01 ~]# salt -G os:CentOS cmd.run 'w'minion01: 23:59:26 up 27 days, 3:00, 0 users, load average: 0.01, 0.03, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT 1234[root@master01 ~]# salt -G osfinger:'CentOS Linux-7' cmd.run 'w'minion01: 00:43:03 up 27 days, 3:44, 0 users, load average: 0.00, 0.01, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT 使用 Grains 可以来匹配主机 自定义 Grains 当内置 Grains 满足不了需求时，可以自定义 Grains。SaltStack 支持在 Minion 端通过配置文件的方式来自定义 Grains 通过 Minion 配置文件定义 Grains 在 minion 端，编辑 /etc/salt/minion打开 grains: roles: 添加一行自定义 Grains 内容 1234&gt; grains:&gt; roles:&gt; - minion01-server&gt; 123456789101112[root@master01 ~]# vim /etc/salt/minion...省略...grains: roles: # 角色 - minion-server # 配置一个角色 - webserver # 可以配置多个 - memcache...省略...:wq保存退出# 重启 salt-minion[root@master01 ~]# systemctl restart salt-minion 在 Master 端，在 roles 是 minion-server 的机器上，执行 echo hello minion01 123[root@master01 ~]# salt -G 'roles:minion-server' cmd.run 'echo hello minion01'minion01: hello minion01 当配置 /etc/salt/minion 主配置文件，配置信息过多的情况下，可读性就会变差我们可以另做一个配置 /etc/salt/grains 文件，专门来配置自定义 Grains123456[root@minion01 salt]# vim /etc/salt/grainsroles: - minion-server - minion-java - minion-springboot - minion-tomcat Salt 默认会读取这个文件 推荐使用这种方式 /etc/salt/minion.d/grains.conf123456789101112[root@minion01 salt]# vim /etc/salt/minion.d/grains.confgrains: Server_business: Java, Web Site Soft: - Tomcat - Spring Boot roles: - minion-server restful: - minion-springboot web: - minion-tomcat 在 master 端执行1234567891011[root@master01 ~]# salt '*' grains.item rolesdbfw01: ---------- roles:minion01: ---------- roles: - minion-server - minion-java - minion-springboot - minion-tomcat 12345678910111213141516[root@master01 hosts]# salt 'minion01' grains.item rolesminion01: ---------- roles: - minion-server[root@master01 hosts]# salt 'minion01' grains.item Softminion01: ---------- Soft: - Tomcat - Spring Boot[root@master01 hosts]# salt 'minion01' grains.item Server_businessminion01: ---------- Server_business: Java, Web Site 注意：如果 minion 配置文件开着 roles，这里的 roles 名字就不能开着，否则会冲突我们可以换个名字12345[root@minion01 salt]# vim /etc/salt/grainsrestful: - minion-springbootweb: - minion-tomcat 在 master 端执行1234567891011121314151617181920212223242526272829303132[root@master01 ~]# salt '*' grains.item rolesdbfw01: ---------- roles:minion01: ---------- roles: - minion-server[root@master01 ~]# salt '*' grains.item restfuldbfw01: ---------- restful:minion01: ---------- restful: - minion-springboot[root@master01 ~]# salt '*' grains.item webdbfw01: ---------- web:minion01: ---------- web: - minion-tomcat[root@master01 ~]# salt -G web:minion-tomcat cmd.run 'w'minion01: 01:22:54 up 27 days, 4:23, 1 user, load average: 0.00, 0.02, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT luming pts/0 192.168.35.219 00:50 1:18 0.10s 0.00s sshd: luming [priv] 在 topfile 里匹配 Minion12345678910[root@master01 salt]# vim nginx.slsnginx-install: pkg.installed: - names: - nginxnginx: service.running: - enable: True - reload: True 123456789[root@master01 ~]# vim /srv/salt/top.slsbase: 'roles:minion-server': # 'restful:minion-springboot': # 'web:minion-tomcat': - match: grain - nginx[root@master01 salt]# salt '*' state.highstate]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack 数据系统 Grains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 基本架构]]></title>
    <url>%2F2018%2F09%2F04%2FSaltStack-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[SaltStack 基本架构 SaltStack 是一种基于 C/S 架构的服务模式。在 SaltStack 架构中服务端叫作 Master，客户端叫作 Minion。客户端发送请求给服务端，服务端接收到请求并且处理完成后再返回给客户端。 在 Master 和 Minion 端都是以守护进程的模式运行，一直监听配置文件里面定义的 ret_port（接受 minion 请求）和 publish_port（发布消息）的端口。当 Minion 运行时会自动连接到配置文件里面定义的 Master 地址 ret_port 端口进行连接认证。默认客户端请求 id 是 socket.getfqdn() 取到的值，也可以在 Minion 启动之前修改 Minion 的 id 值。关于整个启动通信过程，可以使用 debug 查看详细记录。 Master端12salt-master -l debugss -a | egrep '4505|4506' Minion端1salt-minion -l debug 4505(publish_port) 为 salt 的消息发布专用端口为 Salt Master pub 接口，提供远程执行命令发送功能 4506(ret_port) 为客户端与服务端通信的端口。监控此端口可以监控哪些 minion 收到的消息，并回复了结果为 Salt Master Ret 接口，支持认证(auth)，文件服务，结果收集等功能要确保 客户端 能跟 服务端 的这 2 个端口通信，需要保证防火墙对于这两个端口是放开的 Salt 架构中最主要的角色是 Salt master 和 Salt minion另外一种角色是 syndic顾名思义master 是中心控制系统minion 是被管理的客户端 Salt 部署架构可以分为三种第一种：master -&gt; minion这种架构中 master 和所有 minion 都直接连接，minion 接收来自 master 的指令，完成命令执行或配置管理 第二种：master -&gt; syndic -&gt; minion这种架构中 master 通过 syndic 对 minion 进行管理，同时该架构可以进行多级扩展 第三种：无 master 的 minionMasterless 架构，就不需要单独安装一台 SaltStack Master 机器，只需要在每台机器上安装 Minion，然后采用本机只负责对本机的配置管理工作机制服务模式。这种架构中 minion 不受任何 master 控制，通过本地运行即可完成相关功能 Salt 的两个主要设计理念是 远程执行 和 配置管理。Salt 中的 配置管理系统 可以称作 state，也是基于远程执行系统之上，通过 master 的定义可以让对应的 minion 达到想要的系统状态。 SaltStack 软件依赖SaltStack 有两种消息系统，一种是 RAET，另一种是 ZeroMQ，默认使用 ZeroMQ。 组件名 注释 msgpack-python SaltStack 消息交换库 YAML SaltStack 配置解析定义语法 Jinja2 SaltStack states 配置模板 MarkupSafe Python unicode 转换库 apache-libcloud SaltStack 对云架构编排库 Requests HTTP Python 库 ZeroMQ SaltStack 消息系统 pyzmq ZeroMQ Python 库 PyCrypto Python 密码库 M2Crypto Openssl Python 包装库]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack 基本架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 认证配置]]></title>
    <url>%2F2018%2F09%2F04%2FSaltStack-%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SaltStack 认证配置 Salt 证书管理 SaltStack 使用 SSL 签发证书的方式进行安全认证。在签发证书之前，可以在 Master 端看到 Minion 的证书签证请求。Salt 和 minion 之间的认证关系是通过 salt-key 在 master 端管理的，生成证书记录在 /etc/salt/pki/master/ 目录下 salt-minion 启动后生成秘钥文件1234[root@minion01 ~]# cd /etc/salt/pki/minion/[root@minion01 minion]# ll -h-r-------- 1 root root 1.7K Sep 4 16:19 minion.pem # 私钥文件-rw-r--r-- 1 root root 451 Sep 4 16:19 minion.pub # 公钥文件 然后 salt-minion 会把公钥发送给 salt-master salt-master 启动后生成秘钥文件12345678910[root@master01 ~]# cd /etc/salt/pki/master/[root@master01 master]# ll -htotal 8.0K-r-------- 1 root root 1.7K Aug 27 09:03 master.pem # 私钥文件-rw-r--r-- 1 root root 451 Aug 27 09:03 master.pub # 公钥文件drwxr-xr-x 2 root root 23 Sep 5 15:59 minionsdrwxr-xr-x 2 root root 6 Aug 27 09:03 minions_autosigndrwxr-xr-x 2 root root 6 Aug 27 09:03 minions_denieddrwxr-xr-x 2 root root 6 Sep 5 15:49 minions_predrwxr-xr-x 2 root root 6 Aug 27 09:03 minions_rejected 授权前，在获取到 minion端后，公钥文件会存放在 minions_pre 目录下 12345678910[root@master01 master]# tree.├── master.pem├── master.pub├── minions├── minions_autosign├── minions_denied├── minions_pre│ └── minion01 # minion端的公钥文件└── minions_rejected 授权后，minion的公钥文件会被存放在 minions 目录下 12345678910[root@master01 master]# tree.├── master.pem├── master.pub├── minions│ └── minion01 # minion端的公钥文件├── minions_autosign├── minions_denied├── minions_pre└── minions_rejected 123456789101112131415161718[root@master01 master]# cd minions/[root@master01 minions]# ll -h-rw-r--r-- 1 root root 451 Sep 5 15:46 minion01[root@master01 minions]# file minion01minion01: ASCII text[root@master01 minions]# cat minion01-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0DP70JjbCaGB47qsTxn9I0M46rRv5HEUcEyaRBRehA+DvuZjjV1ud63WxrvMcRXq/M86EURVyjFDcNaZywi3SO2K70J+wWxD0HDCV0k8SFR/i83n7nPUVmy+PLlSO+ADl8aWogwUw2wZB4JxZ+OSgWfwvfFZ41yxIlS+Eteb5SkQtRp/OfZrVyEgY6xp4biURsKzP9kFNvOJHW27fcQ9/XI4JmX2aKYk4LJRVvudkkLzYBW1NeYRv0kMAVGpMm8SiAkIwi+7CJnEWorqAmc0TNLGhtDyhV51cbG5Wbt/vbg6N/NX5BOmErXibEsh7679Wph0mJ1fq5jKjn1fYu/JrwIDAQAB-----END PUBLIC KEY----- minion 端也会保存一份 master的公钥 123456[root@minion01 ~]# cd /etc/salt/pki/minion/[root@minion01 minion]# ll -htotal 12K-rw-r--r-- 1 root root 451 Sep 4 16:19 minion_master.pub # master端的公钥文件-r-------- 1 root root 1.7K Sep 4 16:19 minion.pem-rw-r--r-- 1 root root 451 Sep 4 16:19 minion.pub salt-key 命令和参数123格式：salt-key 参数 [minion端ID(可以是IP，也可以是主机名) [-y]-h, --help # 帮助-y # 该参数可免去证书操作的交互（除非对 minion 端很信任，一般不建议使用） 显示所有 public keys12345678910111213-l ARG, --list=ARG # 显示指定状态的 key（支持正则表达式）-L, --list-all # 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected KeysAccepted Keys: # 已经接受的keyDenied Keys: # 未被允许的keyUnaccepted Keys: # 未被接受的keyRejected Keys: # 被拒绝的key[root@master01 ~]# salt-key -LAccepted Keys:Denied Keys:Unaccepted Keys:minion01Rejected Keys: 接受等待认证的 key1234567891011121314151617181920212223242526-a ACCEPT, --accept=ACCEPT # 接受指定等待认证的key（支持正则表达式） # 添加某个或某些个未接受(Unaccepted Keys)认证-A, --accept-all # 接受所有等待认证的key(Unaccepted Keys)下所有的minion # 添加所有未接受(Unaccepted Keys)认证[root@master01 ~]# salt-key -a minion01The following keys are going to be accepted:Unaccepted Keys:minion01Proceed? [n/Y] yKey for minion minion01 accepted.#################################################################################################[root@master01 ~]# salt-key -A -yThe following keys are going to be accepted:Unaccepted Keys:minion01Key for minion minion01 accepted.#################################################################################################[root@master01 ~]# salt-key -LAccepted Keys:minion01Denied Keys:Unaccepted Keys:Rejected Keys: 拒绝等待认证的 key123-r REJECT, --reject=REJECT # 拒绝指定等待认证的key（支持正则表达式）-R, --reject-all # 拒绝所有等待认证的key--include-all # 显示所有状态的key（包含non-pending状态） 打印 public key1234567891011121314151617181920212223242526-p PRINT, --print=PRINT # 打印指定的 public key（支持正则表达式）-P, --print-all # 打印所有的 public key[root@master01 ~]# salt-key -p "minion01"Unaccepted Keys:minion01: -----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0DP70JjbCaGB47qsTxn9I0M46rRv5HEUcEyaRBRehA+DvuZjjV1ud63WxrvMcRXq/M86EURVyjFDcNaZywi3SO2K70J+wWxD0HDCV0k8SFR/i83n7nPUVmy+PLlSO+ADl8aWogwUw2wZB4JxZ+OSgWfwvfFZ41yxIlS+Eteb5SkQtRp/OfZrVyEgY6xp4biURsKzP9kFNvOJHW27fcQ9/XI4JmX2aKYk4LJRVvudkkLzYBW1NeYRv0kMAVGpMm8SiAkIwi+7CJnEWorqAmc0TNLGhtDyhV51cbG5Wbt/vbg6N/NX5BOmErXibEsh7679Wph0mJ1fq5jKjn1fYu/JrwIDAQAB-----END PUBLIC KEY-----[root@master01 ~]# salt-key -PUnaccepted Keys:minion01: -----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0DP70JjbCaGB47qsTxn9I0M46rRv5HEUcEyaRBRehA+DvuZjjV1ud63WxrvMcRXq/M86EURVyjFDcNaZywi3SO2K70J+wWxD0HDCV0k8SFR/i83n7nPUVmy+PLlSO+ADl8aWogwUw2wZB4JxZ+OSgWfwvfFZ41yxIlS+Eteb5SkQtRp/OfZrVyEgY6xp4biURsKzP9kFNvOJHW27fcQ9/XI4JmX2aKYk4LJRVvudkkLzYBW1NeYRv0kMAVGpMm8SiAkIwi+7CJnEWorqAmc0TNLGhtDyhV51cbG5Wbt/vbg6N/NX5BOmErXibEsh7679Wph0mJ1fq5jKjn1fYu/JrwIDAQAB-----END PUBLIC KEY----- 删除已接受的 key12345678-d DELETE, --delete=DELETE # 删除某个或某些个已接受(Accepted Keys)认证-D, --delete-all # 删除所有已接受(Accepted Keys)认证[root@master01 ~]# salt-key -d minion01 -yDeleting the following keys:Accepted Keys:minion01Key for minion minion01 deleted. 显示 key 的指纹信息12345678910111213141516171819202122232425-f FINGER, --finger=FINGER # 显示指定 key 的指纹信息（正则表达式）-F, --finger-all # 显示所有 key 的指纹信息[root@master01 ~]# salt-key -f "minion01"Unaccepted Keys:minion01: c0:e4:83:48:ef:f7:38:70:c7:1d:47:41:df:9c:03:f0[root@master01 ~]# salt-key -FLocal Keys:master.pem: db:5a:f0:25:13:50:94:b9:e0:61:1d:b9:fe:bc:62:b6master.pub: b9:bd:58:90:01:f2:61:7f:03:be:e1:51:f5:0b:4f:08Unaccepted Keys:minion01: c0:e4:83:48:ef:f7:38:70:c7:1d:47:41:df:9c:03:f0#################################################################################################[root@master01 ~]# salt-key -f "minion01"Accepted Keys:minion01: c0:e4:83:48:ef:f7:38:70:c7:1d:47:41:df:9c:03:f0[root@master01 ~]# salt-key -FLocal Keys:master.pem: db:5a:f0:25:13:50:94:b9:e0:61:1d:b9:fe:bc:62:b6master.pub: b9:bd:58:90:01:f2:61:7f:03:be:e1:51:f5:0b:4f:08Accepted Keys:minion01: c0:e4:83:48:ef:f7:38:70:c7:1d:47:41:df:9c:03:f0 检测主机是否存活123[root@master01 ~]# salt 'minion01' test.pingminion01: True 我们发送一条消息给一个或所有的 minion，并告诉它们运行 salt 内置的一个模块中的一条命令（也可以说是模块中的一个函数）。该示例中，miniion 返回 true。这个命令能查询有哪些 minion 是存活的。]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack 认证配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 安装]]></title>
    <url>%2F2018%2F09%2F04%2FSaltStack-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[SaltStack 安装 SaltStack 官网官网：https://repo.saltstack.com/#rhelGitHub：https://github.com/saltstack/salt 最新版本(Pin to Latest Release)123456789# Redhat/CentOS 7 PY2yum -y install https://repo.saltstack.com/yum/redhat/salt-repo-latest-2.el7.noarch.rpm# Redhat/CentOS 7 PY3# Redhat Python3 支持要求先安装EPELyum -y install https://repo.saltstack.com/py3/redhat/salt-py3-repo-latest-2.el7.noarch.rpm# Redhat/CentOS 6 PY2yum -y install https://repo.saltstack.com/yum/redhat/salt-repo-latest-2.el6.noarch.rpm 主版本(Pin to Major Version)12345678# Redhat/CentOS 7 PY2yum -y install https://repo.saltstack.com/yum/redhat/salt-repo-2018.3-1.el7.noarch.rpm# Redhat/CentOS 7 PY3yum -y install https://repo.saltstack.com/py3/redhat/salt-py3-repo-2018.3-1.el7.noarch.rpm# Redhat/CentOS 6 PY2yum -y install https://repo.saltstack.com/yum/redhat/salt-repo-2018.3-1.el6.noarch.rpm 次版本(Pin to Minor Release)12345678910# 安装指定 SaltStack yum仓库文件 和 key文件rpm --import https://repo.saltstack.com/yum/redhat/6/x86_64/archive/2018.3.2/SALTSTACK-GPG-KEY.pubcat /etc/yum.repos.d/saltstack.repo[saltstack-repo]name=SaltStack repo for RHEL/CentOS $releaseverbaseurl=https://repo.saltstack.com/yum/redhat/$releasever/$basearch/archive/2018.3.2enabled=1gpgcheck=1gpgkey=https://repo.saltstack.com/yum/redhat/$releasever/$basearch/archive/2018.3.2/SALTSTACK-GPG-KEY.pub 安装 Salt 组件 获取完以上的仓库源后，执行以下命令，开始安装 1234567yum clean expire-cacheyum -y install salt-masteryum -y install salt-minionyum -y install salt-sshyum -y install salt-syndicyum -y install salt-cloudyum -y install salt-api 启停 salt-master 服务1234567systemctl start salt-mastersystemctl -l status salt-mastersystemctl enable salt-mastersystemctl restart salt-mastersystemctl stop salt-masterjournalctl -fu salt-masterps -ef | grep salt-master 启停 salt-minion 服务1234567systemctl start salt-minionsystemctl -l status salt-minionsystemctl enable salt-minionsystemctl restart salt-minionsystemctl stop salt-minionjournalctl -fu salt-minionps -ef | grep salt-minion]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 可迭代对象与迭代器对象]]></title>
    <url>%2F2018%2F09%2F03%2FPython-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Python 可迭代对象与迭代器对象 什么是迭代器？ 迭代的工具什么是迭代？迭代是一个重复的过程，迭代不是单纯的重复，每一次重复都是基于上一次结果而进行的单纯的重复，并不是迭代 为什么要用迭代器？ 找到一种可以不依赖索引的迭代取值方式12345678910l = ['a', 'b', 'c']i = 0while i &lt; len(i): print(l[i]) i += 1# 执行结果abc 依赖于列表的的索引而进行的索引的取值方式只适用于 字符串，列表，元组 的序列数据类型 针对没有索引的数据类型：字典，集合，文件用迭代器，不依赖于索引 怎么用迭代器？ 可迭代对象在 Python 中，凡是内置有 __iter__ 方法对象，都是可迭代的对象12345678910a = 1b = 1.1# 以下都是可迭代的对象c = 'hello'l = [1, 2, 3]t = (1, 2, 3)d = &#123;'a': 1&#125;g = &#123;1, 2, 3&#125;f = open('aa.py', 'rb') # 文件类型是迭代器对象 迭代器对象？执行可迭代对象下 __iter__ 方法得到的返回值是一个迭代器对象迭代器对象是内置有 __next__ 方法 123456l = ['a', 'b', 'c']iter_obj = l.__iter__()print(iter_obj)# 执行结果&lt;list_iterator object at 0x00000252754AD080&gt; 如何拿到迭代器？执行可迭代对象下的 __iter__() 方法，就能拿到迭代器对象 迭代器对象是内置有 __next__ 方法列表类型1234567891011l = ['a', 'b', 'c']iter_obj = l.__iter__()print(iter_obj.__next__())print(iter_obj.__next__())print(iter_obj.__next__())# 执行结果abc 字典类型1234567891011dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;iter_obj = dic.__iter__()print(iter_obj.__next__())print(iter_obj.__next__())print(iter_obj.__next__())# 执行结果k1k2k3 这种取值方式，不依赖于索引 迭代器拿到了以后，就可以想可以把所有可迭代对象全都变成迭代器对象，然后再按照迭代器的方式，一点一点取值就完全可以脱离索引对我们取值的一种限制12345678910111213dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;iter_obj = dic.__iter__()print(iter_obj.__next__())print(iter_obj.__next__())print(iter_obj.__next__())print(iter_obj.__next__())# 执行结果k1k2k3StopIteration # 结束信号 结束信号：StopIteration，一旦这个信号出现后，就应该知道，迭代器里的值已经被取完了按照索引依次排开称为有序，有索引的类型，才是有序的（字符串，列表，元组）字典是无序的，字典取值是按照 key取值的，和顺序没有关系 123456789101112131415161718vim aa.pydef f1(): def f2(): def f3(): def f4(): iff = open('aa.py', 'rt', encoding='utf-8')iter_obj = f.__iter__()print(iter_obj.__next__(), end='')print(iter_obj.__next__(), end='')print(iter_obj.__next__(), end='')# 执行结果def f1(): def f2(): def f3(): 对文件来说，特点是什么？也能够按照迭代器的方式，把里面的值，一个个取出来可以完全不依赖于索引，仍然能把一个数据类型里面的值，一次次取出来 把字典里的多个值取出来12345678910111213dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;iter_obj = dic.__iter__()while True: try: # 检测有可能抛异常的代码块 print(iter_obj.__next__()) except StopIteration: break# 执行结果k1k2k3 总结 内置有 __iter__ 方法的称为可迭代对象内置同时有 __iter__，__next__ 方法的称为迭代器对象 迭代器对象内置 __next__ 方法__iter__ 方法，执行该方法得到仍然是迭代器本身 1234567# 基于迭代器的迭代取值方式dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;iter_obj = dic.__iter__()print(iter_obj.__iter__() is iter_obj)# 执行结果True 迭代器对象一定是可迭代的对象可迭代对象不一定是迭代器对象 for 循环的底层运行机制 for循环可以称为迭代器循环 执行 for 循环 先调用 in 后面那个对象的 dic.__iter__() 方法，拿到它的迭代器对象 iter_obj = dic.__iter__() 执行迭代器对象的 __next__ 方法，得到的返回值赋值 in 前面的变量名k，然后执行一次循环体代码 print(k) 循环执行，直到取完迭代器内所有的值，自动捕捉 StopIteration 异常结束循环 for 循环字典123456789dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;for k in dic: print(k)# 执行结果k1k2k3 for 循环数字12345for x in 10: pass# 执行结果TypeError: 'int' object is not iterable for 循环文件1234567891011121314f = open('aa.py', 'rt', encoding='utf-8')for line in f: print(line)# 执行结果def f1(): def f2(): def f3(): def f4(): if 是否能区分出 in 后面跟的是迭代器对象还是可迭代对象，答：不能只能区分出只要能被 for循环 循环的，都称为可迭代对象，并不能确定它是否是迭代器对象迭代器对象最关键的方法是 __next__ 方法，也内置了一个 __iter__ 方法，为了和 for循环 的标准统一 12345678910dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;iter_obj = dic.__iter__() # 迭代器对象 = dic.__iter__()for k in iter_obj: print(k)# 执行结果k1k2k3 迭代器的优缺点优点： 提供了一种不依赖与索引的迭代取值方式 节省内存 缺点：值一次性取完，取完后无法再次取值，除非重新得到新的迭代器对象1234567891011121314151617dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;iter_obj = dic.__iter__()print('第一次迭代iter_obj')for k in iter_obj: print(k)print('第二次迭代iter_obj')for k in iter_obj: print(k)# 执行结果第一次迭代iter_objk1k2k3第二次迭代iter_obj 需求：两次都取到值1234567891011121314151617181920dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;iter_obj = dic.__iter__()print('第一次迭代iter_obj')for k in iter_obj: print(k)iter_obj = dic.__iter__()print('第二次迭代iter_obj')for k in iter_obj: print(k)# 执行结果第一次迭代iter_objk1k2k3第二次迭代iter_objk1k2k3 12345678910111213141516171819dic = &#123;'k1': 1, 'k2': 2, 'k3': 3&#125;print('第一次迭代')for k in dic: print(k)print('第二次迭代')for k in dic: print(k)# 执行结果第一次迭代k1k2k3第二次迭代k1k2k3 迭代器节省内存 12345f = open('aa.py')print(f)# 执行结果&lt;_io.TextIOWrapper name='aa.py' mode='r' encoding='cp936'&gt; 12345678f = open('aa.py')print(f.__next__())print(f.__next__())# 执行结果def f1(): def f2(): 谨慎使用f.read() 读取方式是一下子把文件内容全部读出，假设文件过大，就会把内存撑爆了f.readlines() 它也是一下子把文件内容全部读出1234567f = open()# f.readline() # 读文件内容最好使用 readline()，一次读一行# 推荐读文件方式# 即便文件非常大，也不会影响到内存（只不过for循环的次数会比较多）for line in f: print(line) Python2 中 range() 获取的是一个列表类型12&gt;&gt;&gt; range(1, 3)[1, 2] Python3 中 把 range() 做成了一个可迭代对象123456789101112131415161718192021&gt;&gt;&gt; range(1, 3)range(1, 3)&gt;&gt;&gt; obj = range(1, 3)&gt;&gt;&gt; obj.__iter__&lt;method-wrapper '__iter__' of range object at 0x000002A00528B450&gt;&gt;&gt;&gt; obj.__next__Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'range' object has no attribute '__next__'&gt;&gt;&gt; obj=range(1, 100000000000000000000000000000000000000000000000000000000)&gt;&gt;&gt; objrange(1, 100000000000000000000000000000000000000000000000000000000)&gt;&gt;&gt; iter_obj = obj.__iter__()&gt;&gt;&gt; next(iter_obj)1&gt;&gt;&gt; next(iter_obj)2&gt;&gt;&gt; iter_obj.__next__()3&gt;&gt;&gt; iter_obj.__next__()4 Python3 中使用以下方式，不用担心卡死现象Python2 中就有卡死的风险1234567for i in range(1, 10000): print(i)# 执行结果1...省略...9999 缺点：只能往后取，不能往前取，值一次性取完，值取完后无法再次取值，除非重新得到新的迭代器对象无法预测迭代器的长度 Python2123&gt;&gt;&gt; d = &#123;'a':1, 'b':2&#125;&gt;&gt;&gt; d.keys()['a', 'b'] Python3 做了很多优化机制，在 Python2 中的列表数据类型，在 Python3 中都做成了 可迭代对象12345678910111213141516171819&gt;&gt;&gt; d = &#123;'a':1, 'b':2&#125;&gt;&gt;&gt; d&#123;'a': 1, 'b': 2&#125;&gt;&gt;&gt; d.__iter__&lt;method-wrapper '__iter__' of dict object at 0x0000019A9FD67828&gt;&gt;&gt;&gt; d.__next__Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'dict' object has no attribute '__next__'&gt;&gt;&gt; obj = d.keys()&gt;&gt;&gt; objdict_keys(['a', 'b'])&gt;&gt;&gt; obj.__iter__&lt;method-wrapper '__iter__' of dict_keys object at 0x0000019A9FDAA528&gt;&gt;&gt;&gt; obj.__next__Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'dict_keys' object has no attribute '__next__']]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 可迭代对象与迭代器对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 三元表达式、列表生成式、字典生成式]]></title>
    <url>%2F2018%2F09%2F03%2FPython-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python 三元表达式、列表生成式、字典生成式 都是为了写代码写的简介一点儿，不用它们有点问题都没有这四个东西都是为了将多行代码写到一行去，而且还能兼顾一个简洁性的特点 三元表达式 比较两个值最大值最小值的功能1234567891011def max2(x, y): if x &gt; y: return x else: return yres = max2(1, 3)print(res)# 执行结果3 三元表达式 其实就是想用一行把上面这些事情搞定 语法 条件成立时的返回值 if 条件 else 条件不成立时的返回值 12345678x = 10y = 30res = x if x &gt; y else yprint(res)# 执行结果30 条件算一元：if x &gt; y条件成立时返回的值算一元：x条件不成立时返回的值算一元：else y 12345678x = 10y = 2res = True if x &gt; y else Falseprint(res)# 执行结果True 12345678x = 1y = 2res = True if x &gt; y else Falseprint(res)# 执行结果False 列表生成式（列表推导式）12345678l = []for i in range(10): # res = 'egg %s' % i # l.append(res) l.append('egg %s' % i)# 执行结果['egg0', 'egg1', 'egg2', 'egg3', 'egg4', 'egg5', 'egg6', 'egg7', 'egg8', 'egg9'] 12345678nums = []for i in range(10): nums.append(i)print(nums)# 执行结果[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 语法1234567891011121314[expression for item1 in iterable1 if condition1for item2 in iterable2 if condition2...for itemN in iterableN if conditionN]类似于res = []for item1 in iterable1: for item2 in iterable2: if condition2 ... for itemN in iterableN: if conditionN: res.append(expression) 列表生成式示例 12345l = ['egg%s' % i for i in range(10)]print(l)# 执行结果['egg0', 'egg1', 'egg2', 'egg3', 'egg4', 'egg5', 'egg6', 'egg7', 'egg8', 'egg9'] 获取10个数字12345nums = [i for i in range(10)]print(nums)# 执行结果[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 获取10个数的平方12345nums = [i**2 for i in range(10)]print(nums)# 执行结果[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 获取从4 开始往后的值123456789nums = []for i in range(10): if i &gt; 3: nums.append(i)print(nums)# 执行结果[4, 5, 6, 7, 8, 9] 12345nums = [i for i in range(10) if i &gt; 3]print(nums)# 执行结果[4, 5, 6, 7, 8, 9] 小练习 将 name 不是 lisi 的字符串后缀加上 py，并输出12345678910names = ['zhangsan', 'lisi', 'wangwu', 'zhaoliu']l = []for name in names: if name != 'lisi': l.append(name + 'py')print(l)# 执行结果['zhangsanpy', 'wangwupy', 'zhaoliupy'] 将后缀为 py 的字符串，小写变大写，并输出12345678910names = ['zhangsan_py', 'lisi', 'wangwu_py', 'zhaoliu_py']l = []for name in names: if name.endswith('py'): l.append(name.upper())print(l)# 执行结果['ZHANGSAN_PY', 'WANGWU_PY', 'ZHAOLIU_PY'] 将不是 py 结尾的字符串过滤掉，并转换为大写输出1234567891011names = ['zhangsan_py', 'lisi', 'wangwu_py', 'zhaoliu_py']l = []for name in names: if name.endswith('py'): l.append(name.upper())names = lprint(names)# 执行结果['ZHANGSAN_PY', 'WANGWU_PY', 'ZHAOLIU_PY'] 将以下列表中将不是 lisi 的字符串后缀加上 py，并大写输出 123456names = ['zhangsan_py', 'lisi', 'wangwu_py', 'zhaoliu_py']names = [name.upper() for name in names if name.endswith('py')]print(names)# 执行结果['ZHANGSAN_PY', 'WANGWU_PY', 'ZHAOLIU_PY'] 将以下列表中以 py 结尾的名字过滤掉，然后保留剩下的名字长度 123456789101112names = ['zhangsan', 'lisi_py', 'wangwu', 'zhaoliu']names = [name for name in names if not name.endswith('py')]print(names)# 执行结果['zhangsan', 'wangwu', 'zhaoliu']#####################################################################################names = ['zhangsan', 'lisi_py', 'wangwu', 'zhaoliu']names = [name for name in names if not name.endswith('py')]print(names)# 执行结果[8, 6, 7] 字典生成式 集合生成式12345s = &#123;i for i in range(10) if i &gt; 3&#125;print(3)# 执行结果&#123;4, 5, 6, 7, 8, 9&#125; 把符号 [] 换成 {} 就是字典表达式123456789101112d = &#123;i:i for i in range(10)&#125;print(d)# 执行结果&#123;0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9&#125;##########################################################################d = &#123;i:i for i in range(10) if i &gt; 3&#125;print(d)# 执行结果&#123;4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9&#125; 小练习 将以下列表内的字典数据类型，转换成字典类型 123456userinfo = [('egon', '123'), ('alex', '456'), ('wxx', '679')]dic = &#123;k: v for k, v in userinfo&#125;print(dic)# 执行结果&#123;'egon': '123', 'alex', '456', 'wxx': '679'&#125; 123456userinfo = [('egon', '123'), ('alex', '456'), ('wxx', '679')]dic = &#123;item[0]:item[1] for item in userinfo&#125;print(dic)# 执行结果&#123;'egon': '123', 'alex', '456', 'wxx': '679'&#125; 123456userinfo = [('egon', '123'), ('alex', '456'), ('wxx', '679')]dic = &#123;k:v for k, v in userinfo&#125;print(dic)# 执行结果&#123;'egon': '123', 'alex', '456', 'wxx': '679'&#125; 将列表转换成字典1234567891011121314info = [ ['name', 'egon'], ('age', 18), ['sex', 'male']]d = &#123;&#125;for item in info: print(item)# 执行结果['name', 'egon']('age', 18)['sex', 'male'] 1234567891011121314info = [ ['name', 'egon'], ('age', 18), ['sex', 'male']]d = &#123;&#125;for item in info: print(item[0], item[1])# 执行结果name egonage 18sex male 12345678910111213info = [ ['name', 'egon'], ('age', 18), ['sex', 'male']]d = &#123;&#125;for item in info: d[item[0]] = item[1]print(d)# 执行结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; 1234567891011info = [ ['name', 'egon'], ('age', 18), ['sex', 'male']]d = &#123;item[0]: item[1] for item in info&#125;print(d)# 执行结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; 把 key 变成大写1234567891011d = &#123; 'name': 'egon', 'age': 18, 'sex': 'male'&#125;d = &#123;k.upper():v for k,v in d.items()&#125;print(d)# 执行结果&#123;'NAME': 'egon', 'AGE': 18, 'SEX': 'male'&#125;]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 三元表达式、列表生成式、字典生成式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 资源汇总]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Docker 资源汇总 Docker官方英文资源Docker官网：http://www.docker.comDocker windows入门：https://docs.docker.com/windows/Docker Linux 入门：https://docs.docker.com/linux/Docker mac 入门：https://docs.docker.com/mac/Docker 用户指引：https://docs.docker.com/engine/userguide/Docker 官方博客：http://blog.docker.com/Docker Hub: https://hub.docker.com/Docker开源： https://www.docker.com/open-source Docker中文资源Docker中文网站：https://www.docker-cn.com/Docker安装手册：https://docs.docker-cn.com/engine/installation/ Docker 国内镜像网易加速器：http://hub-mirror.c.163.com官方中国加速器：https://registry.docker-cn.comustc的镜像：https://docker.mirrors.ustc.edu.cndaocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用） 参考文档http://www.runoob.com/docker/docker-resources.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker 资源汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker tag 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-tag-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker tag 命令 docker tag : 标记本地镜像，将其归入某一仓库。 语法1docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] 实例将镜像 ubuntu:15.10 标记为 runoob/ubuntu:v3 镜像。 1234[root@localhsot ~] docker tag ubuntu:15.10 runoob/ubuntu:v3[root@localhsot ~] docker images runoob/ubuntu:v3REPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v3 4e3b13c8a266 3 months ago 136.3 MB 参考文档http://www.runoob.com/docker/docker-tag-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker tag 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker search 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-search-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker search 命令 docker search : 从 Docker Hub 查找镜像 语法1docker search [OPTIONS] TERM OPTIONS 说明： –automated : 只列出 automated build 类型的镜像； –no-trunc : 显示完整的镜像描述； -s : 列出收藏数不小于指定值的镜像。 实例从 Docker Hub 查找所有镜像名包含 java，并且收藏数大于 10 的镜像 12345678[root@localhost ~] docker search -s 10 javaNAME DESCRIPTION STARS OFFICIAL AUTOMATEDjava Java is a concurrent, class-based... 1037 [OK] anapsix/alpine-java Oracle Java 8 (and 7) with GLIBC ... 115 [OK]develar/java 46 [OK]isuper/java-oracle This repository contains all java... 38 [OK]lwieske/java-8 Oracle Java 8 Container - Full + ... 27 [OK]nimmis/java-centos This is docker images of CentOS 7... 13 [OK] 参考文档http://www.runoob.com/docker/docker-search-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker search 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker push 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-push-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker push 命令 docker push : 将本地的镜像上传到镜像仓库，要先登陆到镜像仓库。 语法1docker push [OPTIONS] NAME[:TAG] OPTIONS 说明： –disable-content-trust : 忽略镜像的校验，默认开启。 实例上传本地镜像 myapache:v1 到镜像仓库中。 1docker push myapache:v1 参考文档http://www.runoob.com/docker/docker-push-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker push 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker pull 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-pull-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker pull 命令 docker pull : 从镜像仓库中拉取或者更新指定镜像 语法1docker pull [OPTIONS] NAME[:TAG|@DIGEST] OPTIONS 说明： -a : 拉取所有 tagged 镜像 –disable-content-trust : 忽略镜像的校验，默认开启 实例从 Docker Hub 下载 java 最新版镜像。 1docker pull java 从 Docker Hub 下载 REPOSITORY 为 java 的所有镜像。 1docker pull -a java 参考文档http://www.runoob.com/docker/docker-pull-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker pull 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker version 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-version-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker version 命令 docker version : 显示 Docker 版本信息。 语法1docker version [OPTIONS] OPTIONS 说明： -f : 指定返回值的模板文件。 实例显示 Docker 版本信息。 12345678910111213141516docker versionClient: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64Server: Version: 1.8.2 API version: 1.20 Go version: go1.4.2 Git commit: 0a8c2e3 Built: Thu Sep 10 19:19:00 UTC 2015 OS/Arch: linux/amd64 参考文档http://www.runoob.com/docker/docker-version-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker version 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker info 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-info-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker info 命令 docker info : 显示 Docker 系统信息，包括镜像和容器数。 语法1docker info [OPTIONS] 实例查看 docker 系统信息。 12345678910111213141516docker infoContainers: 12Images: 41Storage Driver: aufs Root Dir: /var/lib/docker/aufs Backing Filesystem: extfs Dirs: 66 Dirperm1 Supported: falseExecution Driver: native-0.2Logging Driver: json-fileKernel Version: 3.13.0-32-genericOperating System: Ubuntu 14.04.1 LTSCPUs: 1Total Memory: 1.954 GiBName: iZ23mtq8bs1ZID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW 参考文档http://www.runoob.com/docker/docker-info-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker info 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker import 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-import-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker import 命令 docker import : 从归档文件中创建镜像。 语法1docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] OPTIONS 说明： -c : 应用 docker 指令创建镜像； -m : 提交时的说明文字； 实例从镜像归档文件 my_ubuntu_v3.tar 创建镜像，命名为 runoob/ubuntu:v4 12345[root@localhost ~] docker import my_ubuntu_v3.tar runoob/ubuntu:v4 sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39[root@localhost ~] docker images runoob/ubuntu:v4REPOSITORY TAG IMAGE ID CREATED SIZErunoob/ubuntu v4 63ce4a6d6bc3 20 seconds ago 142.1 MB 参考文档http://www.runoob.com/docker/docker-import-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker import 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker save 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-save-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker save 命令 docker save : 将指定镜像保存成 tar 归档文件。 语法1docker save [OPTIONS] IMAGE [IMAGE...] OPTIONS 说明： -o : 输出到的文件。 实例将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档 123[root@localhost ~] docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3[root@localhost ~] ll my_ubuntu_v3.tar-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta Docker 容器导入导出有两种方法一种是使用 save 和 load 命令使用例子如下： 12docker save ubuntu:load &gt; /root/ubuntu.tardocker load &lt; ubuntu.tar 一种是使用 export 和 import 命令使用例子如下： 12docker export 98ca36 &gt; ubuntu.tarcat ubuntu.tar | sudo docker import - ubuntu:import 需要注意两种方法不可混用。 参考文档http://www.runoob.com/docker/docker-save-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker save 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker build 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-build-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker build 命令 docker build 命令用于使用 Dockerfile 创建镜像。 语法1docker build [OPTIONS] PATH | URL | - OPTIONS说明： –build-arg=[] : 设置镜像创建时的变量； –cpu-shares : 设置 CPU 使用权重； –cpu-period : 限制 CPU CFS周期； –cpu-quota : 限制 CPU CFS配额； –cpuset-cpus : 指定使用的CPU id； –cpuset-mems : 指定使用的内存 id； –disable-content-trust : 忽略校验，默认开启； -f : 指定要使用的 Dockerfile 路径； –force-rm : 设置镜像过程中删除中间容器； –isolation : 使用容器隔离技术； –label=[] : 设置镜像使用的元数据； -m : 设置内存最大值； –memory-swap : 设置 swap 的最大值为 内存+swap，”-1” 表示不限 swap； –no-cache : 创建镜像的过程不使用缓存； –pull : 尝试去更新镜像的新版本； –quiet, -q : 安静模式，成功后只输出镜像 ID； –rm : 设置镜像成功后删除中间容器； –shm-size : 设置 /dev/shm 的大小，默认值是 64M； –ulimit : Ulimit 配置。 –tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 –network: 默认 default。在构建期间设置RUN指令的网络模式 实例使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。 1docker build -t runoob/ubuntu:v1 . 使用 URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。 1docker build github.com/creack/docker-firefox 也可以通过 -f Dockerfile 文件的位置： 1docker build -f /path/to/a/Dockerfile . 在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回： 123docker build -t test/myapp .Sending build context to Docker daemon 2.048 kBError response from daemon: Unknown instruction: RUNCMD 参考文档http://www.runoob.com/docker/docker-build-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker build 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker rmi 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-rmi-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker rmi 命令 docker rmi : 删除本地一个或多个镜像。 语法1docker rmi [OPTIONS] IMAGE [IMAGE...] OPTIONS 说明： -f : 强制删除； –no-prune : 不移除该镜像的过程镜像，默认移除； 实例强制删除本地镜像 runoob/ubuntu:v4。 1234[root@localhost ~] docker rmi -f runoob/ubuntu:v4Untagged: runoob/ubuntu:v4Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072beDeleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73 参考文档http://www.runoob.com/docker/docker-rmi-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker rmi 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker images 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-images-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker images 命令 docker images : 列出本地镜像。 语法1docker images [OPTIONS] [REPOSITORY[:TAG]] OPTIONS 说明： -a 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层） --digests 显示镜像的摘要信息 -f 显示满足条件的镜像 --format 指定返回值的模板文件 --no-trunc 显示完整的镜像信息 -q 只显示镜像ID 实例查看本地镜像列表。 123456789101112[root@localhost ~] docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmymysql v1 37af1236adef 5 minutes ago 329 MBrunoob/ubuntu v4 1c06aa18edee 2 days ago 142.1 MB&lt;none&gt; &lt;none&gt; 5c6e1090e771 2 days ago 165.9 MBhttpd latest ed38aaffef30 11 days ago 195.1 MBalpine latest 4e38e38c8ce0 2 weeks ago 4.799 MBmongo 3.2 282fd552add6 3 weeks ago 336.1 MBredis latest 4465e4bcad80 3 weeks ago 185.7 MBphp 5.6-fpm 025041cd3aa5 3 weeks ago 456.3 MBpython 3.5 045767ddf24a 3 weeks ago 684.1 MB... 列出本地镜像中 REPOSITORY 为 ubuntu 的镜像列表。 1234[root@localhost ~] docker images ubuntuREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 14.04 90d5884b1ee0 9 weeks ago 188 MBubuntu 15.10 4e3b13c8a266 3 months ago 136.3 MB 参考文档http://www.runoob.com/docker/docker-images-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker images 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker cp 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-cp-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker cp 命令 docker cp : 用于容器与主机之间的数据拷贝。 语法12docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH OPTIONS 说明： -L : 保持源目标中的链接 实例将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 的 /www 目录下。 1docker cp /www/runoob 96f7f14e99ab:/www/ 将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 中，目录重命名为 www。 1docker cp /www/runoob 96f7f14e99ab:/www 将容器 96f7f14e99ab 的 /www 目录拷贝到主机的 /tmp 目录中。 1docker cp 96f7f14e99ab:/www /tmp/ 参考文档http://www.runoob.com/docker/docker-cp-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker cp 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker commit 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-commit-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker commit 命令 docker commit : 从容器创建一个新的镜像。 语法1docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] OPTIONS 说明： -a : 提交的镜像作者； -c : 使用 Dockerfile 指令来创建镜像； -m : 提交时的说明文字； -p : 在 commit 时，将容器暂停。 实例将容器 a404c6c174a2 保存为新的镜像，并添加提交人信息和说明信息。 12345[root@localhost ~] docker commit -a "runoob.com" -m "my apache" a404c6c174a2 mymysql:v1 sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057[root@localhost ~] docker images mymysql:v1REPOSITORY TAG IMAGE ID CREATED SIZEmymysql v1 37af1236adef 15 seconds ago 329 MB 参考文档http://www.runoob.com/docker/docker-commit-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker commit 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker port 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-port-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker port 命令 docker port : 列出指定的容器的端口映射，或者查找将 PRIVATE_PORT NAT 到面向公众的端口。 语法1docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]] 实例查看容器 mynginx 的端口映射情况。 12[root@localhost ~] docker port mymysql3306/tcp -&gt; 0.0.0.0:3306 参考文档http://www.runoob.com/docker/docker-port-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker port 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker export 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-export-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker export 命令 docker export : 将文件系统作为一个 tar 归档文件导出到 STDOUT。 语法1docker export [OPTIONS] CONTAINER OPTIONS 说明： -o : 将输入内容写到文件。 实例将 id 为 a404c6c174a2 的容器按日期保存为 tar 文件。 123[root@localhost ~]# docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2[root@localhost ~]# ls mysql-`date +%Y%m%d`.tarmysql-20160711.tar 参考文档http://www.runoob.com/docker/docker-export-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker export 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker logs 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-logs-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker logs 命令 docker logs : 获取容器的日志 语法1docker logs [OPTIONS] CONTAINER OPTIONS 说明： -f : 跟踪日志输出 –since : 显示某个开始时间的所有日志 -t : 显示时间戳 –tail :仅列出最新N条容器日志 实例跟踪查看容器 mynginx 的日志输出。 123456[root@localhost ~]# docker logs -f mynginx192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"2016/07/10 16:53:33 [error] 5#5: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.239.130", referrer: "http://192.168.239.130/"192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET /favicon.ico HTTP/1.1" 404 571 "http://192.168.239.130/" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"... 查看容器 mynginx 从 2016年7月1日 后的最新 10条 日志。 1docker logs --since="2016-07-01" --tail=10 mynginx 参考文档http://www.runoob.com/docker/docker-logs-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker logs 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker attach 命令]]></title>
    <url>%2F2018%2F09%2F01%2FDocker-attach-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker attach 命令 docker attach : 连接到正在运行中的容器。 语法1docker attach [OPTIONS] CONTAINER 要 attach 上去的容器必须正在运行，可以同时连接上同一个 container 来共享屏幕（与 screen 命令的 attach 类似）。 官方文档中说 attach 后可以通过 CTRL-C 来 detach，但实际上经过测试，如果 container 当前在运行 bash，CTRL-C 自然是当前行的输入，没有退出；如果 container 当前正在前台运行进程，如输出 nginx 的 access.log 日志，CTRL-C 不仅会导致退出容器，而且还 stop 了。这不是我们想要的，detach 的意思按理应该是脱离容器终端，但容器依然运行。好在 attach 是可以带上 --sig-proxy=false 来确保 CTRL-D 或 CTRL-C 不会关闭容器。 实例容器 mynginx 将访问日志指到标准输出，连接到容器查看访问信息。 12[root@localhost ~]# docker attach --sig-proxy=false mynginx192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-" 参考文档http://www.runoob.com/docker/docker-attach-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker attach 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker top 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-top-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker top 命令 docker top : 查看容器中运行的进程信息，支持 ps 命令参数。 语法1docker top [OPTIONS] CONTAINER [ps OPTIONS] 容器运行时不一定有 /bin/bash 终端来交互执行 top 命令，而且容器还不一定有 top 命令，可以使用docker top 来实现查看 container 中正在运行的进程。 实例查看容器 mymysql 的进程信息。 123[root@localhost mysql]# docker top mymysqlUID PID PPID C STIME TTY TIME CMD999 40347 40331 18 00:58 ? 00:00:02 mysqld 查看所有运行容器的进程信息。 1for i in `docker ps | grep Up | awk '&#123;print $1&#125;'`; do echo \ &amp;&amp; docker top $i; done 参考文档http://www.runoob.com/docker/docker-top-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker top 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker inspect 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-inspect-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker inspect 命令 docker inspect : 获取容器/镜像的元数据。 语法1docker inspect [OPTIONS] NAME|ID [NAME|ID...] OPTIONS说明： -f : 指定返回值的模板文件。 -s : 显示总的文件大小。 –type : 为指定类型返回JSON。 实例获取镜像 mysql:5.6 的元信息。 1234567891011121314151617181920212223runoob@runoob:~$ docker inspect mysql:5.6[ &#123; "Id": "sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec", "RepoTags": [ "mysql:5.6" ], "RepoDigests": [], "Parent": "", "Comment": "", "Created": "2016-05-24T04:01:41.168371815Z", "Container": "e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54", "ContainerConfig": &#123; "Hostname": "b0cf605c7757", "Domainname": "", "User": "", "AttachStdin": false, "AttachStdout": false, "AttachStderr": false, "ExposedPorts": &#123; "3306/tcp": &#123;&#125; &#125;,... 获取正在运行的容器 mymysql 的 IP。 12runoob@runoob:~$ docker inspect --format='&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' mymysql172.17.0.3 参考文档http://www.runoob.com/docker/docker-inspect-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker inspect 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker ps 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-ps-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker ps 命令 docker ps : 列出容器 语法1docker ps [OPTIONS] OPTIONS 说明： -a : 显示所有的容器，包括未运行的。 -f : 根据条件过滤显示的内容。 –format : 指定返回值的模板文件。 -l : 显示最近创建的容器。 -n : 列出最近创建的 n 个容器。 –no-trunc : 不截断输出。 -q : 静默模式，只显示容器编号。 -s : 显示总的文件大小。 实例列出所有在运行的容器信息 1234runoob@runoob:~$ docker psCONTAINER ID IMAGE COMMAND ... PORTS NAMES09b93464c2f7 nginx:latest "nginx -g 'daemon off" ... 80/tcp, 443/tcp myrunoob96f7f14e99ab mysql:5.6 "docker-entrypoint.sh" ... 0.0.0.0:3306-&gt;3306/tcp mymysql 列出最近创建的 5 个容器信息 1234567runoob@runoob:~$ docker ps -n 5CONTAINER ID IMAGE COMMAND CREATED 09b93464c2f7 nginx:latest "nginx -g 'daemon off" 2 days ago ... b8573233d675 nginx:latest "/bin/bash" 2 days ago ... b1a0703e41e7 nginx:latest "nginx -g 'daemon off" 2 days ago ... f46fb1dec520 5c6e1090e771 "/bin/sh -c 'set -x \t" 2 days ago ... a63b4a5597de 860c279d2fec "bash" 2 days ago ... 列出所有创建的容器ID 123456789101112runoob@runoob:~$ docker ps -a -q09b93464c2f7b8573233d675b1a0703e41e7f46fb1dec520a63b4a5597de6a4aa42e947bde7bb36e796843a432b73776664a8ab1a585ba52eb632bbd... 参考文档http://www.runoob.com/docker/docker-ps-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker ps 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker exec 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-exec-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker exec 命令 docker exec ： 在运行的容器中执行命令 语法1docker exec [OPTIONS] CONTAINER COMMAND [ARG...] OPTIONS说明： -d : 分离模式: 在后台运行 -i : 即使没有附加也保持 STDIN 打开 -t : 分配一个伪终端 实例在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本 12runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.shhttp://www.runoob.com/ 在容器 mynginx 中开启一个交互模式的终端 12runoob@runoob:~$ docker exec -i -t mynginx /bin/bashroot@b1a0703e41e7:/# 参考文档http://www.runoob.com/docker/docker-exec-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker exec 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker pause/unpause 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-pause-unpause-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker pause/unpause 命令 docker pause : 暂停容器中所有的进程。docker unpause : 恢复容器中所有的进程。 语法12docker pause [OPTIONS] CONTAINER [CONTAINER...]docker unpause [OPTIONS] CONTAINER [CONTAINER...] 实例暂停数据库容器 db01 提供服务。 1docker pause db01 恢复数据库容器 db01 提供服务。 1docker unpause db01 参考文档http://www.runoob.com/docker/docker-pause-unpause-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker pause/unpause 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker rm 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-rm-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker rm 命令 docker rm ：删除一个或多个容器 语法1docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS 说明： -f : 通过 SIGKILL 信号强制删除一个运行中的容器 -l : 移除容器间的网络连接，而非容器本身 -v : 删除与容器关联的卷 实例强制删除容器 db01、db02 1docker rm -f db01 db02 移除容器 nginx01 对容器 db01 的连接，连接名 db 1docker rm -l db 删除容器 nginx01，并删除容器挂载的数据卷 1docker rm -v nginx01 参考文档http://www.runoob.com/docker/docker-rm-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker rm 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker kill 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-kill-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker kill 命令 docker kill : 杀掉一个运行中的容器。 语法1docker kill [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明： -s : 向容器发送一个信号 实例杀掉运行中的容器 mynginx12docker kill -s KILL mynginxmynginx 参考文档http://www.runoob.com/docker/docker-kill-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker kill 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker start/stop/restart 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-start-stop-restart-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker start/stop/restart 命令 docker start: 启动一个或多少已经被停止的容器docker stop: 停止一个运行中的容器docker restart: 重启容器 语法123docker start [OPTIONS] CONTAINER [CONTAINER...]docker stop [OPTIONS] CONTAINER [CONTAINER...]docker restart [OPTIONS] CONTAINER [CONTAINER...] 实例启动已被停止的容器 myrunoob 1docker start myrunoob 停止运行中的容器 myrunoob 1docker stop myrunoob 重启容器 myrunoob 1docker restart myrunoob 参考文档http://www.runoob.com/docker/docker-start-stop-restart-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker start/stop/restart 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker create 命令]]></title>
    <url>%2F2018%2F08%2F31%2FDocker-create-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker create 命令 docker create ：创建一个新的容器但不启动它 用法同 docker run 语法1docker create [OPTIONS] IMAGE [COMMAND] [ARG...] 语法同 docker run 实例使用 docker 镜像 nginx:latest 创建一个容器，并将容器命名为 myrunoob 12docker create --name myrunoob nginx:latest09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f 参考文档http://www.runoob.com/docker/docker-create-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker create 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[find 命令结合 exec 和 xargs 使用的区别]]></title>
    <url>%2F2018%2F08%2F30%2Ffind%E5%91%BD%E4%BB%A4%E7%BB%93%E5%90%88exec%E5%92%8Cxargs%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[find 命令结合 exec 和 xargs 使用的区别 -exec xargs 区别一 该参数是将查找的结果文件名逐个传递给后面的命令执行，如果文件比较多则执行的效率会较低 该命令是将查找的结果一次性传给后面的命令执行，命令执行效率高，可以使用 -n 参数控制一次传递文件的个数 区别二 文件名有空格等特殊字符也照常处理 处理特殊的文件名（例如：文件名有空格）需要采用特殊的方式(find . -name “edu” -print0 使用 -exec 选项命令操作示例及结果如下 1234567891011121314151617# 从命令执行的结果可以看到，每次获得一个文件就输出一次find . -type f -exec echo oldboyedu &#123;&#125; \ ;oldboyedu ./.viminfooldboyedu ./anaconda-ks.cfgoldboyedu ./install.logoldboyedu ./install.log.syslogoldboyedu ./.bash_logoutoldboyedu ./.cshrcoldboyedu ./ls.txtoldboyedu ./.bash_historyoldboyedu ./.lesshstoldboyedu ./oldboy. Logoldboyedu ./test. txtoldboyedu ./.tcshrcoldboyedu ./GB2312.txtoldboyedu ./.bash_profileoldboyedu ./.bashrc 使用 xargs 命令操作示例及结果如下 123# 输出结果只有一行，xargs 获取到所有文件名一次性输出find . -type f | xargs echo oldboyeduoldboyedu ./.viminfo ./anaconda-ks.cfg ./install.log ./install.log.syslog ./.bash_logout ./.cshrc ./ls.txt ./.bash_history ./.lesshst ./oldboy.log ./test.txt ./.tcshrc ./GB2312.txt ./.bash_profile ./.bashrc xargs 还能控制每行输出的参数个数，示例如下，更多使用方法见 xargs 命令 1234567# 使用 -n 3 指定每次输出 3 个参数find . -type f | xargs -n 3 echo oldboyeduoldboyedu ./.viminfo ./anaconda-ks.cfg ./install.logoldboyedu ././install.log.syslog ./.bash_logout ./.cshrcoldboyedu ./ls.txt ./.bash_history ./.lesshstoldboyedu ./oldboy.log ./test.txt ./.tcshrcoldboyedu ./GB2312.txt ./.bash_profile ./.bashrc 验证区别二的案例 123456789101112131415# 创建一个文件名带有空格的特殊文件touch "oldboy edu"ll -h "oldboy edu"-rw-r--r-- 1 root root 0 May 17 16:30 oldboy edu# 使用 -exec 参数正常使用find . -name "*oldboy*" -exec ls -lh &#123;&#125; \;-rw-r--r-- 1 root root 0 May 17 16:30 ./oldboy edu# 使用 xargs 命令无法正常打印find . -name "*edu*" | xargs ls -lhls: cannot access ./oldboy: No such file or directoryls: cannot access edu: No such file or directoryfind . -name "*edu*" -print0 | xargs -0 ls -lh-rw-r--r-- 1 root root 0 May 17 16:30 . /oldboy edu]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>find 命令结合 exec 和 xargs 使用的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python装饰器]]></title>
    <url>%2F2018%2F08%2F27%2FPython-%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Python 装饰器 什么是装饰器？装饰指的是为被装饰对象添加新的功能器指的是工具 装饰器本身可以是任意可调用对象，被装饰的对象也可以是任意可调用的对象 目的：写一个函数用来为另一个函数添加新功能，需要遵循开放封闭原则对修改（源代码+调用方式）封闭的，对扩展是开放的不修改被装饰对象的源代码不修改被装饰对象的调用方式 示例 12345678910import timedef index(): time.sleep(3) print('welcome to index page')index()# 执行结果（3秒后获得结果）welcome to index page 需求：为 index() 函数增加（装饰）一个统计时间的功能123456789101112131415import timedef index(): time.sleep(3) print('welcome to index page')# 获取一个时间段start = time.time()index()stop = time.time()print('run time is %s' % (stop - start))# 执行结果welcome to index pagerun time is 3.004941940307617 time.time() 获取当前时间秒数的表达形式以 1970 年为基准，当前时间减去 1970 年，中间经过的秒数123456import timeprint(time.time())# 执行结果1535380439.073392 为无参函数做装饰 为无参函数做装饰 1234567891011121314151617import timedef index(): time.sleep(3) print('welcome to index page')def timmer(func): # func = index start = time.time() # 统计起始时间 func() # index() stop = time.time() # 统计结束时间 print('run time is %s' % (stop - start))timmer(index)# 执行结果welcome to index pagerun time is 3.0023746490478516 这里更改了被装饰对象的调用方式 1234567891011121314151617181920import timedef index(): time.sleep(3) print('welcome to index page')def outter(func): # func=最原始的index def wrapper(): start = time.time() func() # 最原始的index() stop = time.time() print('run time is %s' % (stop - start)) return wrapperf = outter(index) # f = wrapperf()# 执行结果welcome to index pagerun time is 3.0037789344787598 原功能该执行还是执行，并且再加上统计运行时间的功能 上面修改了被装饰对象的调用方式把 f=outter(index) 改成 index=outter(index) 就行了1234567891011121314151617181920import timedef index(): time.sleep(3) print('welcome to index page')def outter(func): # func=最原始的index def wrapper(): start = time.time() func() # 指向最原始的index() stop = time.time() print('run time is %s' % (stop - start)) return wrapperindex = outter(index) # index = wrapperindex() # wrapper()# 执行结果welcome to index pagerun time is 3.0034096240997314 为有参函数做装饰 为有参函数做装饰 1234567891011121314151617181920212223242526272829import timedef index(): time.sleep(3) print('welcome to index page')def home(name): time.sleep(2) print('welcome %s to home page' % name)def outter(func): # func = 最原始的index def wrapper(*args, **kwargs): start = time.time() func(*args, **kwargs) stop = time.time() print('run time is %s' % (stop - start)) return wrapperindex = outter(index) # index = wrapperindex()home = outter(home)home('egon')# 执行结果welcome to index pagerun time is 3.003574848175049welcome egon to home pagerun time is 2.003159523010254 为有函数返回值的函数做装饰 为有函数返回值的函数做装饰 12345678910111213141516171819202122232425262728import timedef index(): time.sleep(0.5) print('welcome to index page') return 1234def home(name): time.sleep(1) print('welcome %s to home page' % name)def outter(func): # func = 最原始的index def wrapper(*args, **kwargs): start = time.time() res = func(*args, **kwargs) stop = time.time() print('run time is %s' % (stop - start)) return res return wrapperindex = outter(index) # index = wrapperres = index()print(res)# 执行结果welcome to index pagerun time is 0.50071883201599121234 装饰器语法糖 在 被装饰对象 正上方，单独一行写上 @装饰器函数名Python 会自上而下运行代码一旦运行到 @装饰器函数名 的位置，Python解释器就会立刻将正下方函数当做参数传给 装饰器函数然后将返回的结果，重新赋值 给 函数（函数变量名） 1234567891011121314151617181920212223242526272829303132333435import timedef timmer(func): # func = 最原始的index def wrapper(*args, **kwargs): start = time.time() res = func(*args, **kwargs) stop = time.time() print('run time is %s' % (stop - start)) return res return wrapper@timmer # index = timmer(index)def index(): time.sleep(0.5) print('welcome to index page') return 1234@timmer # home = timmer(index)def home(name): time.sleep(1) print('welcome %s to home page' % name)index = timmer(index) # index = wrapperhome = timmer(home)res = index()print(res)home('egon')# 执行结果welcome to index pagerun time is 0.50152611732482911234welcome egon to home pagerun time is 1.0023066997528076 认证功能装饰器 为被装饰对象添加认证功能 123456789101112131415161718192021222324252627282930313233343536373839404142import timecurrent_userinfo = &#123;'user': None&#125;def outter(func): def wrapper(*args, **kwargs): if current_userinfo['user']: # res = func(*args, **kwargs) # return res return func(*args, **kwargs) user = input('please input your username: ').strip() pwd = input('please input your password: ').strip() if user == 'egon' and pwd == '123': print('login successfull') # 保存登录状态 current_userinfo['user'] = user res = func(*args, **kwargs) return res else: print('user or password error') return wrapper@outter # index = outter(index)def index(): print('welcome to index page') time.sleep(3)@outter # home = outter(home)def home(name): print('welcome %s' % name) time.sleep(2) return 123index()res = home('egon')# 执行结果please input your username: egonplease input your password: 123login successfullwelcome to index pagewelcome egon 多个装饰器的执行顺序 为一个被装饰对象，同时添加多个装饰器同时添加多个装饰器的执行顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import timecurrent_userinfo = &#123;'user': None&#125;def timmer(func): # func = wrapper1 def wrapper2(*args, **kwargs): print('wrapper2......') start = time.time() res = func(*args, **kwargs) stop = time.time() print('run time is %s' % (stop - start)) return res return wrapper2def outter(func): # func = 最原始的 index def wrapper1(*args, **kwargs): print('wrapper1......') if current_userinfo['user']: return func(*args, **kwargs) user = input('please input your username: ').strip() pwd = input('please input your password: ').strip() if user == 'egon' and pwd == '123': print('login successfull') # 保存登录状态 current_userinfo['user'] = user res = func(*args, **kwargs) # 调用最原始的index return res else: print('user or password error') return wrapper1@timmer # index = timmer(wrapper1)@outter # outter(最原始的index) ==&gt; wrapper1def index(): print('welcome to index page') time.sleep(3)index() # index ==&gt; wrapper2# 执行结果wrapper2......wrapper1......please input your username: egonplease input your password: 123login successfullwelcome to index pagerun time is 11.453307151794434 @timmer 在前，@outter 在后代码会统计 outter() 和 index() 的总时间，这不是我们想要的效果我们只要统计 index() 的运行时间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import timecurrent_userinfo = &#123;'user': None&#125;def timmer(func): # func = wrapper1 def wrapper2(*args, **kwargs): print('wrapper2......') start = time.time() res = func(*args, **kwargs) stop = time.time() print('run time is %s' % (stop - start)) return res return wrapper2def outter(func): # func = 最原始的 index def wrapper1(*args, **kwargs): print('wrapper1......') if current_userinfo['user']: return func(*args, **kwargs) user = input('please input your username: ').strip() pwd = input('please input your password: ').strip() if user == 'egon' and pwd == '123': print('login successfull') # 保存登录状态 current_userinfo['user'] = user res = func(*args, **kwargs) # 调用最原始的index return res else: print('user or password error') return wrapper1@outter@timmerdef index(): print('welcome to index page') time.sleep(3)index() # index ==&gt; wrapper2# 执行结果wrapper1......please input your username: egonegonplease input your password: 123123login successfullwrapper2......welcome to index pagerun time is 3.003432512283325 @outter 在前，@timmer 在后 总结：可以连续写多个装饰器，处于最顶层的装饰器先执行 有参装饰器12345678910111213141516171819202122232425262728293031323334353637383940414243import timecurrent_userinfo = &#123;'user': None&#125;def auth(engine = 'file'): def outter(func): # func = 最原始的index def wrapper(*args, **kwargs): if engine == 'file': if current_userinfo['user']: return func(*args, **kwargs) user = input('please input your username: ').strip() pwd = input('please input your password: ').strip() if user == 'egon' and pwd == '123': print('login successfull') # 保存登录状态 current_userinfo['user'] = user res = func(*args, **kwargs) return res else: print('user or password error') elif engine == 'mysql': print('mysql 的认证机制') elif engine == 'ldap': print('ldap 的认证机制') else: print('不支持该engine') return wrapper return outterx = auth(engine = 'file')@x # @autter # index = outter(最原始的index) # index = wrapperdef index(): print('welcome to index page') time.sleep(3)index()# 执行结果please input your username: egonplease input your password: 123login successfullwelcome to index page 1234x = auth(engine = 'mysql')# 执行结果mysql 的认证机制 合并一下 x = auth(engine = &#39;file&#39;) 和 @xauth(engine = &#39;file&#39;)这就是有参装饰器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import timecurrent_userinfo = &#123;'user': None&#125;def auth(engine = 'file'): def outter(func): # func = 最原始的index def wrapper(*args, **kwargs): if engine == 'file': if current_userinfo['user']: return func(*args, **kwargs) user = input('please input your username: ').strip() pwd = input('please input your password: ').strip() if user == 'egon' and pwd == '123': print('login successfull') # 保存登录状态 current_userinfo['user'] = user res = func(*args, **kwargs) return res else: print('user or password error') elif engine == 'mysql': print('mysql 的认证机制') elif engine == 'ldap': print('ldap 的认证机制') else: print('不支持该engine') return wrapper return outter@auth(engine = 'mysql') # @autter # index = outter(最原始的index) # index = wrapperdef index(): print('welcome to index page') time.sleep(3)@auth(engine = 'file')def home(name): print('welcome %s' % name) time.sleep(2) return 123index() # warpper()home('egon') # warpper('egon')# 执行结果mysql 的认证机制ldap 的认证机制 wraps 装饰器123456789101112131415161718192021import timedef timmer(func): def wrapper(*args, **kwargs): start = time.time() res = func(*args, **kwargs) stop = time.time() print('run time is %s' % (stop - start)) return res return wrapper@timmerdef index(): print('welcome to index page') time.sleep(3)index()# 执行结果welcome to index pagerun time is 3.0011937618255615 12345678910111213@timmerdef index(): print('welcome to index page') time.sleep(1) return 123res = index()print(res)# 执行结果welcome to index pagerun time is 1.0007963180541992123 定义函数，函数体最好有写文档注释 1234567891011121314151617def index(): """ 这是一个 index 函数 :return: """ print('welcome to index page') time.sleep(1) return 123print(help(index))# 执行结果Help on function index in module __main__:index() 这是一个index函数 :return: print(help(index)) 可以查看函数的帮助信息 12345678910def index(x, y): """ :param x: :param y: :return: """ print('welcome to index page') time.sleep(1) return 123 help() 其实就是在查看 __doc__ 属性 123456789101112131415def index(x, y): """ 这是一个index函数 :return: """ print('welcome to index page') time.sleep(1) return 123# print(help(index)) # index.__doc__print(index.__doc__)# 执行结果 这是一个index函数 :return: 1234567print(help(len))# 执行结果Help on built-in function len in module builtins:len(obj, /) Return the number of items in a container. 在不修改被装饰源代码，以及被装饰器调用的方式，为其加上新功能最好在使用 index() 的时候，和原来一模一样12345678910111213141516@timmerdef index(x, y): """ 这是一个index函数 :return: """ print('welcome to index page') time.sleep(1) return 123print(help(index))# 执行结果Help on function index in module __main__:wrapper(*args, **kwargs) 但是加上装饰器后，index() 就不是原来的 index() 了help() 是调用的 wrapper() 的注释打印的是 wrapper() 的注释 应该将 wrapper() 伪装的和原来的 index() 一模一样把 index() 的 __doc__ 拿过来把 index() 的 __name__ 拿过来12345678910111213141516171819202122232425262728293031323334import timedef timmer(func): def wrapper(*args, **kwargs): start = time.time() res = func(*args, **kwargs) stop = time.time() print('run time is %s' % (stop - start)) return res wrapper.__doc__ = func.__doc__ wrapper.__name__ = func.__name__ return wrapper@timmerdef index(x, y): """ 这是一个index函数 :return: """ print('welcome to index page') time.sleep(1) return 123print(help(index)) # index.__doc__print(index.__name__)# 执行结果Help on function index in module __main__:index(*args, **kwargs) 这是一个index函数 :return:index 这些功能不用自己写，Python 为我们内置了一个装饰器 wraps导入 from functools import wraps@wraps 加在最内层函数正上方12345678910111213141516171819202122232425262728293031323334import timefrom functools import wrapsdef timmer(func): @wraps(func) # 加在最内层函数正上方 def wrapper(*args, **kwargs): start = time.time() res = func(*args, **kwargs) stop = time.time() print('run time is %s' % (stop - start)) return res # wrapper.__doc__ = func.__doc__ # wrapper.__name__ = func.__name__ return wrapper@timmerdef index(): """ 这是一个index函数 :return: """ print('welcome to index page') time.sleep(1) return 123print(help(index)) # index.__doc__print(index.__name__)# 执行结果index() 这是一个index函数 :return:index]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker run 命令]]></title>
    <url>%2F2018%2F08%2F27%2FDocker-run-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Docker run 命令 docker run ：创建一个新的容器并运行一个命令 语法1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS 说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -p: 端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m : 设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； 实例使用 docker 镜像 nginx:latest 以后台模式启动一个容器,并将容器命名为 mynginx。 1docker run --name mynginx -d nginx:latest 使用镜像 nginx:latest 以后台模式启动一个容器,并将容器的 80 端口映射到主机随机端口。 1docker run -P -d nginx:latest 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口，主机的目录 /data 映射到容器的 /data。 1docker run -p 80:80 -v /data:/data -d nginx:latest 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。 1docker run -p 127.0.0.1:80:8080/tcp ubuntu bash 使用镜像 nginx:latest 以交互模式启动一个容器,在容器内执行 /bin/bash 命令。 12docker run -it nginx:latest /bin/bashroot@b8573233d675:/# 参考文档http://www.runoob.com/docker/docker-run-command.html]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker run 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python闭包函数]]></title>
    <url>%2F2018%2F08%2F27%2FPython-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python 闭包函数 前提：函数的作用域关系是在函数定义阶段就已经固定死的，与调用位置无关 闭包函数介绍 定义在函数的内部的函数 该内部函数包含对其外层函数作用域名字的引用 闭包函数通常需要结合函数对象的概念，将闭包函数返回到外部使用 示例一123456789101112def outter(): x = 100 def inner(): print(x) return innerf = outter()x = 200f()# 执行结果100 示例二1234567891011121314def outter(): x = 100 def inner(): print(x) return innerdef foo(): x = 300 f()foo()# 执行结果100 示例三 12345678910111213141516171819def outter(): x = 100 def inner(): print(x) return innerf = outter()def foo(): x = 300 def bar(): x = 400 f() bar()foo()# 执行结果100 闭 指的是 -&gt; 定义在函数的内部的函数闭 指的就是将一个函数闭合在另一个函数内部包 指的是 -&gt; 该内部函数包含对其外层函数作用域名字的引用 闭包函数的使用12345def outter(): x = 1 def inner(): print(x) return inner 闭包函数的基本形式 1234def outter(x): def inner(): print(x) return inner 求两个数的和 直接通过参数为其传值 12345def sum2(x, y): res = x + y return ressum2(1, 2) 将 值 包给 函数 sum2 12345678910def outter(x, y): # x = 1 # y = 2 def sum2(): res = x + y return res return sum2sum2 = outter(1, 2)sum2() 示例12345import requestsresponse = requests.get('https://www.jd.com')# if response.status_code = 200:print(response.text) 通过参数的形式为函数体传值 123456789import requestsdef get(url): response = requests.get(url) print(len(response.text))get('https://www.baidu.com')get('https://www.jd.com')get('https://www.tmall.com') 将值包给函数 12345678910111213141516171819202122232425262728import requestsdef outter(url): # url = 'https://www.jd.com' def get(): response = requests.get(url) print(len(response.text)) return getjd = outter('https://www.jd.com')jd()jd()jd()# 执行结果117377117377117377baidu = outter('https://www.baidu.com')baidu()baidu()baidu()# 执行结果244324432443 123456789def outter(): x = 1 def foo(): print(x) return foof = outter()print(f)f()]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python闭包函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数之 global 与 nonlocal 关键字]]></title>
    <url>%2F2018%2F08%2F26%2FPython-%E5%87%BD%E6%95%B0%E4%B9%8Bglobal%E4%B8%8Enonlocal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Python 函数 global 与 nonlocal 关键字 global global 是用于在函数内去修改全局作用域的名字 12345678910x = 1def func(): x = 2func()print(x)# 执行结果1 12345678910x = []def func(): xfunc()print(x)# 执行结果[] 在局部名称空间，修改一个可变类型的变量名字 12345678910x = []def func(): x.append(1) # 在局部名称空间，修改一个可变类型的变量func()print(x)# 执行结果[1] 在 局部名称空间 造一个值覆盖全局的变量名字global 在局部声明名字是来自于全局的 1234567891011x = 1def func(): global x # 在 局部名称空间 造一个值覆盖全局的名字 x = 2func()print(x)# 执行结果2 nonlocal global 修改的是 全局名称空间 的所定义 的 名字但无法修改 当前层函数的 外面一层 的 局部名字 12345678910111213141516x = 222def f1(): x = 111 def f2(): global x x = 0 f2() print('f1---&gt;', x)f1()print(x)# 执行结果f1---&gt; 1110 nonlocal 声明变量是来自于当前层外层的名字只能找到 当前层函数 的外面一层的 名字如果没有则抛出异常：SyntaxError: no binding for nonlocal &#39;x&#39; found必须是在函数内，不能跳出函数123456789101112131415x = 222def f1(): def f2(): # x = 111 nonlocal x x = 0 f2() print('f1---&gt;', x)f1()print(x)# 执行结果SyntaxError: no binding for nonlocal 'x' found 12345678910111213141516x = 222def f1(): x = 111 def f2(): nonlocal x x = 0 f2() print('f1---&gt;', x)f1()print('global===&gt;', x)# 执行结果f1---&gt; 0global===&gt; 222]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数之 global 与 nonlocal 关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python名称空间与作用域]]></title>
    <url>%2F2018%2F08%2F23%2FPython-%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Python 名称空间与作用域 什么是名称空间？名称空间就是存放名字与值绑定映射关系的地方要取到值必须通过名字才能找到，而名字又在名称空间中存放着，所以在取值时首先是去名称空间中找名字找到了名字就拿到值的内存地址了 名称空间氛围三种内置名称空间 存放的 python 解释器自带的名字生命周期：在解释器启动时生成，在解释器关闭时回收12345678print(len)print(max)print(print)# 执行结果&lt;built-in function len&gt;&lt;built-in function max&gt;&lt;built-in function print&gt; 全局名称空间 除了内置的与局部的之外的名字，都属于全局名称空间生命周期：在程序文件执行时就立刻生成，在程序执行完毕后就回收 1234567891011x = 1y = 2def foo(): x = 1 y = 2foo()if y &gt; x: z = 3 局部名称空间 存放的是函数内部定义的名字生命周期：在调用函数时临时生成，在调用函数结束后，立刻回收12345def foo(): x = 1 y = 2foo() 加载顺序 内置名称空间 -&gt; 全局名称空间 -&gt; 局部名称空间 全局查找 12345len = 100print(len)# 执行结果100 12345# len = 100print(len)# 执行结果&lt;built-in function len&gt; 局部查找 12345678910len = 100def foo(): len = 2222 print(len)foo()# 执行结果2222 加载名称空间的目的是为了将名字与值的绑定关系存放起来，存的目的是为取，也就是说，当我们在查找名字时，必然是在三者之一找到 查找顺序 局部名称空间 -&gt; 全局名称空间 -&gt; 内置名称空间基于当前所在的位置往后查找1234567891011x = 100y = 200# 注：函数的形参名属于局部名称空间def foo(x, y): print(x, y)foo(1, 2)# 执行结果1, 2 示例示例一 顺序 调用 f1() 找到 f2() f2() 打印 from f212345678910def f1(): x = 1 def f2(): print('from f2') f2()f1()# 执行结果from f2 示例二 顺序 调用 f1() 找到 f2() f2() 找到局部名称变量 x 打印 from f2 x1234567891011def f1(): x = 1 def f2(): x = 2 print('from f2', x) f2()f1()# 执行结果from f2 2 示例三 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 找到 名字变量 x f2() 打印 from f2 11234567891011def f1(): x = 1 def f2(): # x = 2 print('from f2', x) f2()f1()# 执行结果from f2 1 示例四 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 最终没有找到 名字变量 x 抛出异常NameError: name &#39;x&#39; is not defined1234567891011def f1(): # x = 1 def f2(): # x = 2 print('from f2', x) f2()f1()# 执行结果NameError: name 'x' is not defined 示例五 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在 全局名称空间 里找到 名字变量 x f2() 打印 from f2 111123456789101112x = 111def f1(): # x = 1 def f2(): # x = 2 print('from f2', x) f2()f1()# 执行结果from f2 111 示例六 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在 全局名称空间 里找到 名字变量 x f2() 打印 from f2 111注：名称空间并不是往上找，只要有就能找到123456789101112def f1(): # x = 1 def f2(): # x = 2 print('from f2', x) f2()x = 111f1()# 执行结果from f2 111 示例七 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在 全局名称空间 里找到 名字变量 x 名字变量 x=2222 被重新赋值 x=111 f2() 打印 from f2 11112345678910111213x = 2222def f1(): # x = 1 def f2(): # x = 2 print('from f2', x) f2()x = 111f1()# 执行结果from f2 111 作用域 域是范围，作用域指的是作用范围 分为两大类全局作用范围 包含 内置名称空间 与 全局名称空间 中的名字特点：全局有效，全局存活1234567891011121314151617def f1(): def f2(): def f3(): print(len) f3() f2()f1()def foo(): print(len)foo()# 执行结果&lt;build-in function len&gt;&lt;build-in function len&gt; 内置名字，具备一个特点，无论在任何位置，都能访问的到这叫全局有效 12345678910111213141516171819x = 1def f1(): def f2(): def f3(): print(x) f3() f2()f1()def foo(): print(x)foo()# 执行结果11 局部作用范围 包含 局部名称空间 的名字特点：局部有效，临时存活 gloabls 与 locals12345678x = 1def foo(): y = 2print(globals)# 执行结果&lt;built-in function globals&gt; 返回 全局作用域 中的名字123456789x = 1111111111def foo(): y = 2print(globals()) # 返回 全局作用域 中的名字# 执行结果&lt;built-in function globals&gt;&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x7fa1f58357f0&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/data/app/SH_weekend_s2/day04/04_名称空间与作用域.py', '__cached__': None, 'x': 1111111111, 'foo': &lt;function foo at 0x7fa1f5766bf8&gt;&#125; 查看 全局名称空间 包含的 内置名称空间 的名字12345678x = 1111111111def foo(): y = 2print(dir(globals()['__builtins__'])) # 返回 全局作用域中 包含的 内置名称空间 的名字# 执行结果['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] 查看 局部作用域12345678x = 1111111111def foo(): y = 2print(locals() is globals())# 执行结果True 在全局作用范围内查看，locals() 和 gloables() 是一样的全局查看就是 优先查看自己，再查看局部的在全局作用范围查看检索范围就是 全局名称空间，以及内置名称空间123456789x = 1111111111def foo(): y = 2 print(locals())foo()# 执行结果&#123;'y': 2&#125; 打破函数层级限制的解决方案 如何打破函数层级的访问限制？让能够在任意位置都可以访问到一个内部函数123456789def outter(): def inner(): print('from inner') inner()outter()# 执行结果from inner 如何在任何位置都能访问到 inner() 函数？12345678910def outter(): def inner(): print('from inner') return innerf = outter()print(f)# 执行结果&lt;function outter.&lt;locals&gt;.inner at 0x7f2b7b0a0c80&gt; 返回 inner() 的存地址return inner，注意这里 inner 不能加括号然后调用 outter() 函数，将其赋值给 一个 全局名称空间 的名字变量打印这个名字变量，输出 inner() 的内存地址 名字变量 加 括号 执行，就可以访问 内部函数inner() 内的内容了12345678910def outter(): def inner(): print('from inner') return innerf = outter()f()# 执行结果from inner 定义个 全局名称空间 foo() 函数通过 foo() 调用 全局名称空间 的 名字变量 f，也能访问到 内部函数inner() 内的内容了 12345678910111213141516def outter(): def inner(): print('from inner') return innerf = outter()def foo(): print(f) f()foo()# 执行结果&lt;function outter.&lt;locals&gt;.inner at 0x7f8aaa6f6c80&gt;from inner 基于函数对象的概念将一个内部函数返回到全局使用，从而打破了函数的的层级限制 也可以将 内部函数 inner() 返回到 foo() 内 12345678910111213def outter(): def inner(): print('from inner') return innerdef foo(): f = outter() f()foo()# 执行结果from inner 函数的作用域关系是在函数定义阶段就已经固定死的，与函数的调用位置无关即在调用函数时，一定要跑到定义函数的位置寻找作用域关系 示例示例一 注意查看 x 变量的位置1234567891011121314x = 111def outter(): def inner(): print('from inner', x) return innerdef foo(): x = 222 f()foo()# 执行结果from inner 111 示例二 注意查看 x 变量的位置1234567891011121314151617x = 111def outter(): x = 33333 def inner(): print('from inner', x) return innerf = outter()def foo(): x = 222 f()foo()# 执行结果from inner 33333 示例三 注意查看 x 变量的位置1234567891011121314151617x = 111def outter(): def inner(): print('from inner', x) return innerx = 4444f = outter()def foo(): x = 222 f()foo()# 执行结果from inner 4444]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python名称空间与作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数嵌套]]></title>
    <url>%2F2018%2F08%2F21%2FPython-%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[Python 函数嵌套 函数的嵌套调用 在调用一个函数时，其内部的代码又调用了其他的函数12345678910def bar(): print('from bar')def foo(): print('from foo')foo()# 执行结果from foofrom bar 求两个数的最大值12345def max2(x, y): if x &gt; y: return x else: return y 求四个数的最大值12345678910def max4(a, b, c, d): res1 = max2(a, b): res2 = max2(res1, c) res3 = max2(res2, d) return res3print(max4(1, 2, 3, 4))# 执行结果4 函数的嵌套定义 在一个函数的内部又定义了另外一个函数123456789def f1(): x = 1 def f2(): print('from f2')print(f1)# 执行结果&lt;function f1 at 0x00000288E1A51E18&gt; 123456789101112def f1(): x = 1 def f2(): print('from f2') print(x) print(f2)f1()# 执行结果1&lt;function f1.&lt;locals&gt;.f2 at 0x0000024BD90F89D8&gt; 12345678910def f1(): x = 1 def f2(): print('from f2') f2()f1()# 执行结果from f2]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数嵌套</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数对象]]></title>
    <url>%2F2018%2F08%2F20%2FPython-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Python 函数对象 函数是第一类对象，意味着函数可以当做数据去使用 可以被引用123456789101112def foo(): print('from foo')print(foo)func = fooprint(func)func() # 加括号运行# 执行结果&lt;function foo at 0x00000221E334E18&gt;&lt;function foo at 0x00000221E334E18&gt;from foo 可以当做参数传给另外一个函数123456789101112def foo(): print('from foo')def bar(x): # x=foo 的内存地址 print(x) x() # 在调用 bar 的时候触发 foobar(foo)# 执行结果&lt;function foo at 0x00000221E334E18&gt;from foo 可以当作函数的返回值123456789101112131415def foo(): print('from foo')def bar(): return foof = bar()print(f)print(f is foo)f()# 执行结果&lt;function foo at 0x00000221E334E18&gt;Truefrom foo 可以当作容器类型的元素12345678910111213def f1(): print('from f1')def f2(): print('from f2')l = [f1, f2]print(l)l[1]()# 执行结果[&lt;function f1 at 0x000001E9A24A89D8&gt;, &lt;function f2 at 0x000001E9A24A8A60&gt;]from f2 示例（基于函数对象思想）12345678910111213141516171819202122232425262728293031323334353637def pay(): print('pay function')def withdraw(): print('withdraw')def auth(): print('auth function')def shopping(): print('shopping function')def transer(): print('transfer function')while True: print(""" 1 支付 2 取款 3 购物 4 转账 5 退出 """) choice = input('请输入您要执行的操作：').strip() if choice == '1': pay() elif choice == '2': withdraw() elif choice == '3': shopping() elif choice == '4': transfer() elif choice == "5": break else: print('输入错误，请重新输入') 示例优化01 1234567891011121314151617181920def pay(): print('pay function')def withdraw(): print('withdraw')def auth(): print('auth function')func_dic = &#123;&#125; '1': pay, '2': withdraw, '3': authprint(func_dic)func_dic['2']()# 执行结果&#123;'1': &lt;function pay at 0x0000029EF7F589D8&gt;, '2': &lt;function withdraw at 0x0000029EF7F58A60&gt;, '3': &lt;function auth at 0x0000029EF7F58AE8&gt;&#125;withdraw function 示例优化02 1234567891011121314151617181920212223242526272829303132333435363738def pay(): print('pay function')def withdraw(): print('withdraw')def auth(): print('auth function')def shopping(): print('shopping function')def transer(): print('transfer function')func_dic = &#123; '1': pay, '2': withdraw, '3': auth, '4': shopping, '5': transfer&#125;while True: print(""" 1 支付 2 取款 3 认证 4 购物 5 转账 """) choice = input('请输入您要执行的操作（按q退出）：').strip() # choice = '1' if choice == 'q': break if choice not in func_dic: print('输入错误，请重新输入') continue func_dic[choice]()]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数参数-命名关键字参数]]></title>
    <url>%2F2018%2F08%2F20%2FPython-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python 函数参数-命名关键字参数命名关键字参数 函数参数格式 def foo(位置形参, 默认形参, **args, 命名关键字参数, **kwargs) 12def foo(x, y=1, **args, m, **kwargs): print(x, y, args, m, kwargs) m 为 命名关键字参数 命名关键字参数：凡是在 * 后 ** 之前定义的的参数称之为 命名关键字参数注意： 在调用函数时，传值的形式必须是 key=value 的形式 1234567def foo(x, y, *, m, n): print(x, y, m, n)foo(1, 2, 3, 4)# 执行结果TypeError: foo() takes 2 positional arguments but 4 were given 需要改成 1234567def foo(x, y, *, m, n): print(x, y, m, n)foo(1, 2, n=3, m=4)# 执行结果1 2 4 3 以下 m=1 表示为命名关键字参数指定一个默认值 1234567def foo(x, y, *, m=1, n): print(x, y, m, n)foo(1, 2, n=3) # m=1 命名关键字参数有值了，可以不传值# 执行结果1 2 1 3 命名关键字参数示例123456789def foo(x, y, *args, m=1, n): print(x, y, m, n) print(args)foo(1, 2, 3, 4, 5, n=222, m=11)# 执行结果1 2 11 222(3, 4, 5) 1234567def foo(x, y=1, *args, m, **kwargs): print(x, y, args, m, kwargs)foo(1, 2, 3, 4, 5, 6, m=200, n=300, a=400)# 执行结果1 2 (3, 4, 5, 6) 200 &#123;'n': 300, 'a': 400&#125; 常用函数参数形式12345678def foo(x, y): passdef foo(x, y=1): passdef wrapper(*args, **kwargs): index(*args, **kwargs) 示例：求和函数 12345678910def my_sum(*args): res = 0 for item in args: res += item return resprint(my_sum(1, 2, 3, 5, 6))# 执行结果21]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数参数-命名关键字参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数参数-可变长参数]]></title>
    <url>%2F2018%2F08%2F15%2FPython-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python函数参数-可变长参数 可变长参数 指的是在调用函数时，传入的实参个数可以不固定实参两种形式： 位置实参 关键字实参所以对应的，形参也必须对应两种解决方案，专门用于接收溢出的位置实参和关键字实参 接收溢出的位置实参 星（*）：接收溢出的位置实参，存成元组类型，然后赋值给（*）后边跟的那个变量名 用法一：在形参中使用（*）12345678910111213def foo(x, y, *args): print(x, y) print(z)foo(1, 2, 3, 4, 5) # 3, 4, 5 是溢出的# 执行结果1, 2(3, 4, 5)foo(1, 2, 3, 4, 5, 6, 7, 8, 9) # 3, 4, 5, 6, 7, 8, 9 是溢出的# 执行结果1 2(3, 4, 5, 6, 7, 8, 9) 用法二：在实参中用（*）123456789def foo(x, y, *args): # args = ((3, 4, 5, 6, 7, 8, 9)) print(x, y) print(z)foo(1, 2, (3, 4, 5, 6, 7, 8, 9))# 执行结果1 2(3, 4, 5, 6, 7, 8, 9) 实参中使用星（*），将实参打散成位置实参，再传值给形参 123456789def foo(x, y, *args): # args = (3, 4, 5, 6, 7, 8, 9) print(x, y) print(z)foo(1, 2, *(3, 4, 5, 6, 7, 8, 9)) # foo(1, 2, 3, 4, 5, 6, 7, 8, 9)# 执行结果1 2(3, 4, 5, 6, 7, 8, 9) 123456789def foo(x, y, *args): # args = (3, 4, 5,) print(x, y) print(z)foo(1, 2, *[3, 4, 5]) # foo(1, 2, 3, 4, 5)# 执行结果1 2(3, 4, 5) 123456789def foo(x, y, *args): print(x, y) print(z)foo(1, 2, *'abc') # foo(1, 2, 'a', 'b', 'c')# 执行结果1 2('a', 'b', 'c') 注意以下传参问题：1234567def foo(x, y): print(x, y)foo(1, *(2, 3, 4, 5)) # foo(1, 2, 3, 4, 5)# 执行结果TypeError: foo() takes 2 positional arguments but 5 were given 1234567def foo(x, y): print(x, y)foo(1, (2, 3, 4, 5))# 执行结果1, (2, 3, 4, 5) 1234567def foo(x, y): print(x, y)foo(*(1, 2, 3, 4, 5)) # foo(1, 2, 3, 4, 5)# 执行结果TypeError: foo() takes 2 positional arguments but 5 were given 示例：求和函数，传一堆数字，求这堆数字的和 123456789101112131415161718def my_sum(*args): res = 0 for n in args: res = res + n return resres1 = my_sum(1, 2, 3)res2 = my_sum(1, 2, 3, 4)res3 = my_sum(1, 2, 3, 4, 5)print(res1)print(res2)print(res3)# 执行结果61015 接收溢出的关键字实参 星星（**）：接收溢出的关键字实参，存成字典类型，然后赋值给（**）后面跟的那个变量名 用法一：在形参中使用（**）1234567891011def foo(x, y, **kwargs): # kwargs=&#123;'a':2, 'b':4, 'c':4&#125; print(x) print(y) print(z)foo(1, a=2, b=3, c=4, y=5)# 执行结果15&#123;'a': 2, 'b': 4, 'c': 4&#125; 用法二：在实参中使用（**）1234567891011def foo(x, y, **kwargs): print(x) print(y) print(z)foo(1, &#123;'a':2, 'c':3, 'b':10, 'y':111&#125;)# 执行结果1&#123;'a':2, 'c':3, 'b':10, 'y':111&#125;&#123;&#125; 1 赋值给了 x{‘a’:2, ‘c’:3, ‘b’:10, ‘y’:111} 赋值给了 y没有溢出的关键字参数，所以 **kwargs 为空 1234567891011def foo(x, y, **kwargs): # kwargs=&#123;'a':2, 'c':3, 'b':10&#125; print(x) print(y) print(z)foo(1, **&#123;'a':2, 'c':3, 'b':10, 'y':111&#125;) # foo&#123;1, y=111, a=2, b=10, c=3&#125;# 执行结果1111&#123;'a':2, 'c':3, 'b':10&#125; 1 赋值给了 x111 赋值给了 y{‘a’:2, ‘c’:3, ‘b’:10} 为溢出的关键字参数，赋值给了 **kwargs 12345678910def foo(x, y, **kwargs): print(x) print(y) print(z)foo(1, **&#123;'a':2, 'c':3&#125;) # foo(1, c=3, a=2)# 执行结果TypeError: foo() missing 1 required positional argument: 'y'缺少1个所需的位置参数：'y' 示例：把字典里的每个值取出来，分别赋值给 x, y, z 123456789101112def foo(x, y, z): print(x) print(y) print(z)d = &#123;'x': 1, 'y': 2, 'z': 3&#125;foo(d['x'], d['y'], d['z'])# 执行结果123 123456789101112def foo(x, y, z): print(x) print(y) print(z)d = &#123;'x': 1, 'y': 2, 'z': 3&#125;foo(**d) # foo(x=1, y=2, z=3)# 执行结果123 12345678910def foo(x, y, z): print(x) print(y) print(z)d = &#123;'x': 1, 'y': 2, 'z': 3, 'a': 10&#125;foo(**d) # foo(x=1, y=2, z=3, a=10)# 执行结果TypeError: foo() got an unexpected keyword argument: 'a' 12345678910def foo(x, y, z): print(x) print(y) print(z)d = &#123;'x': 1, 'y': 2,&#125;foo(**d) # foo(x=1, y=2)# 执行结果TypeError: foo() missing 1 required positional argument: 'z' 接收任意形式，任意长度的参数123456789def foo(*args, **kwargs): # args=(1, 2, 3) print(x) print(y)foo(1, 2, 3, a=1, b=2, c=3)# 执行结果(1, 2, 3)&#123;'a': 1, 'b': 2, 'c': 3&#125; 示例场景 12345678910def index(name, gender): print('welcome %s gender is %s' % (name, gender))def wrapper(*args, **kwargs): # args=(1,2,3) kwargs=&#123;'a':1, 'b':2&#125; index(*args, **kwargs) # index(*(1,2,3), **&#123;'a':1,'b':2&#125;) # index(1,2,3,a=1,b=2)wrapper(1, 2, 3, a=1, b=2)# 执行结果TypeError: index() got an unexpected keyword argument 'a' 123456789101112def index(name, gender): print('welcome %s gender is %s' % (name, gender))def wrapper(*args, **kwargs): # args=('zhangsan','male') kwargs=&#123;&#125; index(*args, **kwargs) # index(*('zhangsan','male'), **&#123;&#125;) # index('zhangsan','male')# wrapper('zhangsan', 'male')# wrapper(gender='male', name='zhangsan')wrapper('zhangsan', gender='male')# 执行结果welcome zhangsan gender is male]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python函数参数-可变长参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数参数]]></title>
    <url>%2F2018%2F08%2F12%2FPython-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python函数参数 函数的参数氛围两大类：形参与实参 形参：指的是在定义函数时，括号指定的参数，本质就是“变量名”实参：指的是在调用函数时，括号内传入的值，本质就是值 123456789def foo(x, y): # x=1, y=2 print(x) print(y)foo(1, 2)# 输出结果12 只有在调用函数时才会在函数体内发生实参（值）与形参（变量名）的绑定关系该绑定关系只在调用函数时临时生效，在调用函数结束后就解除绑定 123456789def foo(x, y): # x=1, y=2 print(x) print(y)foo(1.3, &#123;'a': 1&#125;)# 输出结果1.3&#123;'a': 1&#125; 在传值的时候没有类型限制 位置参数 位置形参：在定义函数时，按照从左到右的顺序依次定义的形参称之为位置形参位置实参：在调用函数时，按照从左到右的顺序依次传入的值 1234567def foo(x, y, z): print(x, y, z)foo(1, 2, 3)# 输出结果1 2 3 位置形参：在定义函数时，按照从左到右的顺序依次定义的形参称之为位置形参凡是按照位置定义的形参，在调用函数时必须为其传值，多一个不行少一个也不行 12345678def foo(x, y, z): print(x, y, z)foo(1, 2)# 输出结果TypeError: foo() missing 1 required positional argument: 'z'# 缺少 1 个所需的位置参数 1234567def foo(x, y, z): print(x, y, z)foo(1, 2, 3, 4)# 输出结果TypeError: foo() takes 3 positional arguments but 4 were given 位置实参：在调用函数时，按照从左到右的顺序依次传入的值在传值时按照顺序与形参一一对应 1234567def foo(x, y, z): print(x, y, z)foo(3, 2, 1)# 输出结果3 2 1 缺点：基于位置的方式传值，按照顺序与形参一一对应，对应错了，传值就错了 1234567891011def register(name, sex, age): print(name) print(sex) print(age)register('egon', 'male', 18)# 输出结果egonmale18 关键字实参 关键字实参：在调用函数时，按照 key=value 的形式定义的实参，称之为关键字实参在传值时，可以完全打乱顺序，仍然能为指定的参数传值 1234567891011def register(name, sex, age): print(name) print(sex) print(age)register(name='egon', sex='male', age=18)# 输出结果egonmale18 123456789def register(name, sex, age): print(name) print(sex) print(age)register(sex='male', age=18)# 输出结果TypeError: register() missing 1 required positional argument: 'name' 在调用函数时，可以混合使用位置实参和关键字实参但是位置实参必须在关键字实参的左边 123456789def register(name, sex, age): print(name) print(sex) print(age)register(name='egon', 'male', age=18)# 输出结果SyntaxError: positional argument follows keyword argument 不能为同一个形参重复传值 123456789def register(name, sex, age): print(name) print(sex) print(age)register('male', name='egon', age=18)# 输出结果TypeError: register() got multiple value for argument 'name' 1234567891011def register(name, sex, age): print(name) print(sex) print(age)register('egon', age=18, sex='male')# 输出结果egonmale18 默认参数 形参在定义时就已经为其赋值可以传值也可以不传值经常需要变得参数定义成位置形参，变化较小的参数定义成默认参数（形参）注意： 在定义阶段已经赋值，在调用阶段可以不用为其传值 默认参数的定义应该在位置形参右边 默认参数通常应该定义成不可变类型 1234567891011def foo(x, y, z=3): print(x) print(y) print(z)foo(1, 2)# 输出结果123 如需传值，以新的值为准 1234567891011def foo(x, y, z=3): print(x) print(y) print(z)foo(1, 2, 4)# 输出结果124 经常需要变得参数定义成位置形参，变化较小的参数定义成默认参数（形参） 1234567def register(name, sex='female', age): print(name) print(sex) print(age)# 执行结果SyntxError: non-default argument follows default argument 默认参数的定义应该在位置形参右边 1234567891011121314151617181920212223def register(name, age, sex='female'): print(name) print(sex) print(age)register('wxx', 38)register('lxx', 48)register('cxx', 28)register('alex', 73, 'male')# 输出结果wxxfemale38lxxfemale48cxxfemale28alexmale73 默认形参的值只在定义阶段生效一次，在函数定义之后发生的改动无效 12345678910111213m = 10def foo(x, y, z=m): print('x: %s' % x) print('y: %s' % y) print('z: %s' % z)m = 123456foo(1, 2)# 执行结果x: 1y: 2z: 10 默认参数通常应该定义成不可变类型 123456789101112def foo(name, hobby, l=[]): # 这里 l=[] 默认参数为可变类型 l.append(hobby) print('%s 的爱好是 %s' % (name, l))foo('张三', 'read')foo('李四', '吃饭')foo('王五', '睡觉')# 执行结果张三 的爱好是 ['read']李四 的爱好是 ['read', '吃饭']王五 的爱好是 ['read', '吃饭', '睡觉'] 问题：三次调用之间彼此之间有关联，一次调用基于上次的结果继续调用注意：函数定义的时候一定要做到函数的解耦合性 12345678910111213def foo(name, hobby,): l = [] l.append(hobby) print('%s 的爱好是 %s' % (name, l))foo('张三', 'read')foo('李四', '吃饭')foo('王五', '睡觉')# 执行结果张三 的爱好是 ['read']李四 的爱好是 ['吃饭']王五 的爱好是 ['睡觉'] 123456789101112def foo(name, hobby, l=None): if l is None: l = [] l.append(hobby) print('%s 的爱好是 %s' % (name, l))foo('张三', 'read', ['music', 'movie']])foo('李四', '吃饭', ['撸串',])# 执行结果张三 的爱好是 ['music', 'movie', 'read']张三 的爱好是 ['撸串', '吃饭'] 1234567891011121314151617def foo(name, hobby, l=None): if l is None: l = [] l.append(hobby) print('%s 的爱好是 %s' % (name, l))l1 = []foo('张三', 'read', l1)foo('张三', '音乐', l1)foo('张三', '旅行', l1)foo('李四', '吃饭')foo('王五', '睡觉')# 执行结果张三 的爱好是 ['read', '音乐', '旅行']李四 的爱好是 ['吃饭']王五 的爱好是 ['睡觉']]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack network模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack-network%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[network模块 返回 Minion 主机的网络信息 获取 minion01 主机 ping 域名信息1salt 'minion01' network.ping www.baidu.com 获取 minion 的主机名1salt '*' network.get_hostname 获取指定网络接口的 mac 地址1salt '*' network.hw_addr eth0 获取主机是否在某个子网内 在就返回True，如果不在的话就返回 False，多子网用空格隔开1salt '*' network.in_subnet 192.168.1.0/24 查看 minion 端绑定的 IP 地址 多 IP 也会显示出来，127.0.0.1 除外1salt '*' network.ip_addrs 显示所有接口的详细信息 但是别名的网卡类似于 eth0:1 这种不会显示1salt '*' network.interfaces 显示指定网卡接口上面的 IP 只会显示IP不会显示其他内容1salt '*' network.interface_ip eth0 network.interface 会连网关子网掩码也显示 修改某一个 minion 的主机名 显然这一步操作只适合在初始化的时候而且不适合执行所有主机1salt 'agent1.salt' network.mod_hostname test1.salt 显示的 ping 的结果信息 如果不加 return_boolean=True 显示的是 ping 的结果信息，加了就是如果 ping 通了就返回 True，ping不通就返回 False1salt '*' network.ping www.baidu.com return_boolean=True timeout=3 timeout=3 就是 ping 的时间，3秒超时这样能快速返回结果这个其实挺好用的，比如我们可以测试哪些主机的 DNS 设置有问题不能正常解析啊，或者是我们内网 DNS 指向了一个非公网的域名解析，可以通过这个看哪些主机设置了内网 DNS 而哪些没设置内网 DNS 获取主机所属的子网1salt '*' network.subnets]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack network模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack host模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack-hosts%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[hosts 模块 通过这个命令可以查看详细用法1salt '*' sys.doc hosts 我们生产中如果没有用内建 DNS 服务，使用 hosts 模块修改 /etc/hosts 还是经常会用到的 hosts.add_host 追加123salt '*' hosts.add_host 192.168.1.113 minion01# hosts.add 会先判断 /etc/hosts 里面有没有这个 IP 192.168.1.113# 如果有 minion01 会将 alias 名追加到这个 IP 后面，跟之前的解析别名一起使用这个 IP 12salt '*' hosts.add_host 192.168.1.114 minion01# 如果没有这个 IP，则会新创建一行 hosts 记录，但是 192.168.1.113 那条还是存在的。两条记录 hosts.set_host 覆盖123salt '*' hosts.set_host 192.168.1.114 minion02hosts.set_host 这个的不同之处就是，如果这个 IP 不存在则创建新的一条 hosts 记录，如果 hosts 存在这个 IP 的解析记录。会完全覆盖掉也就是旧的 IP 解析记录完全变成现在的结果 hosts.rm_host 删除123salt '*' hosts.rm_host 192.168.1.114 minion02# 删除 192.168.1.114 minion02 这条解析记录# 如果 192.168.1.114 这行有多条解析记录，而只会删除 minion02 这条记录，其他的 192.168.1.114 xxx.xxx，还会存在不会删除，可以说是有选择性的删除 查看 hosts 解析的用法 123# 192.168.1.114 这个 IP 对应的别名解析salt '*' hosts.get_alias 192.168.1.114# 如果有则返回对应的 hosts 别名解析记录，没有则什么都不返回 123# 这个就是返回 minion01 在 /etc/hosts 里面对应的 IPsalt '*' hosts.get_ip minion01# 但是有个问题，如果有多条只会返回文件最上方的那一条对应的 IP 地址 12# 如果有这条别名解析记录，则返回True，如果没有则返回Falsesalt '*' hosts.has_pair 192.168.1.113 minion01 1234# 类似于 cat /etc/hosts 的操作salt '*' hosts.list_hosts# 不同的是，这相当于一个汇总，会以第一行是 IP：下一行是其对应的别名解析的方式来呈现# 比如一个 IP 有好几行的解析，这所有的解析记录都会汇总到这个 IP 下面，注释过的别名解析的行不会出现在这个汇总信息里面 dnsutil 模块 Minion 主机通用 DNS 操作添加 192.168.2.71 www.test.com 到 minion01 端 /etc/hosts 下1salt 'minion01' dnsutil.hosts_append /etc/hosts 192.168.2.71 www.test.com]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack host模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack group模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack-group%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[group 模块 添加指定用户组 group.add 方法123[root@salt-master ~]# salt 'salt-minion02' group.add user1 1000salt-minion02: True 返回用户组信息 group.info 方法12345678910[root@salt-master ~]# salt 'salt-minion02' group.info user1salt-minion02: ---------- gid: 1000 members: name: user1 passwd: x 返回所有用户组的信息 group.getent 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485[root@salt-master ~]# salt 'salt-minion02' group.getentsalt-minion02: |_ ---------- gid: 0 members: name: root passwd: x |_ ---------- gid: 1 members: - bin - daemon name: bin passwd: x |_ ---------- gid: 2 members: - bin - daemon name: daemon passwd: x |_ ---------- gid: 3 members: - bin - adm name: sys passwd: x |_ ---------- gid: 4 members: - adm - daemon name: adm passwd: x |_ ---------- gid: 5 members: name: tty passwd: x |_ ---------- gid: 6 members: name: disk passwd: x |_ ---------- gid: 7 members: - daemon name: lp passwd: x |_....... 添加一个用户到指定组中 group.adduser 方法必须是一个已经存在的组和已存在的用户123[root@salt-master ~]# salt 'salt-minion02' group.adduser user1 zabbixsalt-minion02: True 将用户从用户组中移除 group.deluser 方法123[root@salt-master ~]# salt 'salt-minion02' group.deluser user1 zabbixsalt-minion02: True 移除指定用户组 group.delete 方法123[root@salt-master ~]# salt 'salt-minion02' group.delete user1salt-minion02: True]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack group模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack user模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack-user%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[user模块 用于用户管理，如创建用户，删除用户，更改用户信息等官方文档https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.useradd.html 在 minion 端上创建一个用户 语法1salt '*' user.add name &lt;uid&gt; &lt;gid&gt; &lt;groups&gt; &lt;home&gt; &lt;shell&gt; 创建用户 创建一个 test 用户，其它都和 useradd 一样默认12345salt * user.add test[root@salt-master ~]# salt 'salt-minion02' user.add test 610 605 zabbix /home/test /bin/bashsalt-minion02: True 获取用户信息 user.info 方法返回用户信息123456789101112131415161718192021[root@salt-master ~]# salt 'salt-minion02' user.info testsalt-minion02: ---------- fullname: gid: 605 groups: - zabbix home: /home/test homephone: name: test passwd: x roomnumber: shell: /bin/bash uid: 610 workphone: 获取所有系统用户信息的列表 user.getent 方法返回所有系统用户信息的列表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@salt-master ~]# salt 'salt-minion02' user.getent salt-minion02: |_ ---------- fullname: root gid: 0 groups: - root home: /root homephone: name: root passwd: x roomnumber: shell: /bin/bash uid: 0 workphone: |_ ---------- fullname: bin gid: 1 groups: - bin - daemon - sys home: /bin homephone: name: bin passwd: x roomnumber: shell: /sbin/nologin uid: 1 workphone: ...... 查看所有用户 查看所有用户1salt * user.list_users 列出指定用户所属组的列表 user.list_groups 方法列出指定用户所属组的列表123[root@salt-master ~]# salt 'salt-minion02' user.list_groups zabbixsalt-minion02.contoso.com: - zabbix 创建用户指定 shell 创建用户时指定 shell1salt * user.add test shell=/sbin/nologin 创建用户时指定不创建家目录 创建用户时指定不创建家目录1salt * user.add test createhome=False 创建用户时指定附加组 创建用户时指定附加组1salt * user.add test groups=nginx 将用户加入到其他组，为附加组 将 test 用户加入到 nginx 组，此为附加组1salt * user.chgroups test nginx 查看用户所有的组 查看 test 用户所有的组1salt * user.list_groups test 删除用户 user.delete 方法删除 test 用户1salt * user.delete test remove=True 在 minion 端删除一个用户123[root@salt-master ~]# salt 'salt-minion02' user.delete testsalt-minion02: True 修改用户名 user.rename 方法123[root@salt-master ~]# salt 'salt-minion02' user.rename test testusersalt-minion02.contoso.com: False 虽然返回 False 但是操作是成功完成了的 编辑 user.sls 文件12345678vim /srv/salt/nginx/create_users.sls# usernginx_user: user.present: # 用户创建 - name: nginx - createhome: False # 不用家目录 - gid_from_name: True - shell: /sbin/nologin # 指定shell]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack user模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack archive模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack-archive%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[archive 模块 主要用于打包，压缩和归档使用官方文档https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.archive.html实现系统层面的压缩包调用，支持 gunzip、gzip、rar、tar、unrar、unzip 等 可以设置为 “jinja” 或另一个受支持的模板引擎，以便在执行之前呈现命令参数1salt '' archive.tar cjvf /tmp/salt.tar.bz2 &#123;&#123;grains.saltpath&#125;&#125; template=jinja 将 /tmp/file_1,/tmp/file_2 打包压缩成 tarfile.tar.bz2 文件 到 /tmp 目录下1salt '' archive.tar cjvf /tmp/tarfile.tar.bz2 /tmp/file_1,/tmp/file_2 解压缩 foo.tar 文件到 /target/directory 目录下1salt '*' archive.tar xf foo.tar dest=/target/directory 执行压缩命令1234567salt '*' archive.tar zcvf /root/test.tar.gz /root/python,/root/testa192.168.10.249:- tar: Removing leading `/' from member names- /root/python/- /root/python/p2- /root/python/p1- /root/testa 通过该方法压缩的文件，解压后带有全路径，可通过 cwd 指定执行的目录123456salt '*' archive.tar zcvf /root/test/test.tar.gz python,testa cwd=/root192.168.10.249:python/python/p2python/p1testa 执行解压缩命令123456salt '*' archive.tar zxvf /root/test/test.tar.gz dest=/root/test192.168.10.249:- python/- python/p2- python/p1- testa 12345678# 采用 gzip 压缩 sourcefile.txt 文件salt '*' archive.gzip sourcefile.txt# 采用 gzip 压缩 test.txt 文件salt 'minion01' archive.gzip test.txt# 采用 gunzip 解压 sourcefile.txt.gz 包salt '*' archive.gunzip sourcefile.txt.gz 12345# 解压在 /root 目录下salt 'minion01' archive.tar xf /tmp/access.tar.gz# 压缩在 /tmp 目录下salt 'minion01' archive.tar /tmp/test.txt 1234567891011121314151617181920# 打包指定文件，多个文件使用空隔分开，打包后的名称为 test.zipsalt minion* archive.cmd_zip /opt/test.zip /tmp/test.sh# 打包目录salt minion* archive.cmd_zip /opt/test.zip /tmp/init# 将 init.zip 解压至 /root 目录下面salt minion* archive.cmd_unzip /opt/init.zip /root/# 将 test.sh 打包为 test.sh.gz，打包后就在当前目录salt minion* archive.gzip /tmp/test.sh# 将 test.sh.gz 解压，解压后就在当前目录salt minion* archive.gunzip /tmp/test.sh.gz# 对 /tmp/init 目录打包后压缩为 tar.gzsalt minion* archive.tar czvf /opt/init.tar.gz /tmp/init# 解压 init.tar.gz，默认放到 /root 目录下面，因为 minion 进程是以 root 用户启动的salt minion* archive.tar xvzf /opt/init.tar.gz api 调用12client.cmd('*', 'archive.gunzip', ['sourcefile.txt.gz'])client.cmd('minion01', 'archive.tar', ['xf', '/tmp/access.tar.gz']) 通过 Python 扩展模块，使用 API通过调用 master client 模块，实例化一个 LocalClient 对象，再调用 cmd() 方法来实现12345678910# API 实现 archive.gzipvim archive_gzip.pyimport salt.clientclient = salt.client.LocalClient()res = client.cmd('*', 'archive.gzip', '/tmp/test.txt')print(res)# 执行结果返回一个字典&#123;'minion01': '/tmp/test.txt.gz'&#125;]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack archive模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack 常用模块]]></title>
    <url>%2F2018%2F08%2F07%2FSaltStack-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[SaltStack 常用模块 SaltStack 内置模块汇总1acl, aliases, alternatives, apache, archive, artifactory, blockdev, btrfs, buildout, cloud, cmd, composer, config, container_resource, cp, cron, data, defaults, devmap, dig, disk, django, dnsmasq, dnsutil, drbd, elasticsearch, environ, etcd, event, extfs, file, gem, genesis, git, grains, group, grub, hashutil, hg, hipchat, hosts, http, img, incron, ini, introspect, ip, iptables, jboss7, jboss7_cli, key, kmod, locale, locate, logrotate, lowpkg, match, mine, modjk, mount, network, openstack_config, pagerduty, pillar, pip, pkg, pkg_resource, postfix, publish, puppet, pyenv, raid, random, random_org, rbenv, ret, rsync, runit, rvm, s3, saltutil, schedule, scsi, sdb, seed, selinux, serverdensity_device, service, shadow, slack, smtp, sqlite3, ssh, state, status, supervisord, sys, sysctl, syslog_ng, system, test, timezone, user, vbox_guest, virtualenv, webutil, xfs SaltStack 常用模块介绍这里重点是要将经常用到的模块记录的用法记录下来，直接在 master 端用 salt 命令可以做一些简单的操作，也为做 .sls文件 打基础。 cmd 模块常用方法12salt 'agent1.salt' sys.doc cmd# 可以看 cmd 模块都有哪些使用方法，这里只列举常用的 cmd.has_exec 用法 如果可执行文件在 minion 上可用，则返回true，否则返回false 12# 这里只能是单个命令，如果你用 'ip addr' 这种形式的话，肯定返回的是 Falsesalt '*' cmd.has_exec ifconfig cmd.retcode 用法 在 minion 端执行一个 shell 命令并返回命令的返回码。0 表示成功，0 以外表示失败有问题。123salt '*' cmd.retcode 'ls -l /etc/hostname'# 如我们可以查看一个文件是否存在根据返回码来判断，或者执行一个脚本等，''里面就是你要执行的命令# 正好跟 cmd.has_exec 相反 cmd.run 用法 这个执行 shell 命令跟 cmd.retcode 类似，但是不同的是，cmd.run 就像在本地执行一样。cmd.run_stderr 意思只会在出问题的时候返回信息。 1234567891011121314151617[root@master ~]# salt '*' cmd.retcode 'cat /root/1'zwidc_kvm_192.168.1.104: 0agent1.salt: 0[root@master ~]# salt '*' cmd.run 'cat /root/1'agent1.salt: 123zwidc_kvm_192.168.1.104:[root@master ~]# salt '*' cmd.run_stderr 'cat /root/1'agentl.salt:zwidc_kvm_192.168.1.104:[root@master ~]# salt '*' cmd.run_stderr 'cat /root/6'agent1.salt: cat: /root/6: No such file or directoryzwidc_kvm_192.168.1.104: cat: /root/6: No such file or directory cmd.script 和 cmd.script_retcode 从远程 salt 服务器 或 ftp 服务器 或 http 服务器 下载脚本到本地执行 12salt '*' cmd.script salt://scripts/runme.shsalt '*' cmd.script salt://scripts/runme.sh 'arg1 arg2 "arg 3"' cmd.shell 和 cmd.shells cmd.shell 跟 cmd.run 一样一般用 cmd.run, cmd.shells 是通过 /etc/shells 文件列出此系统上的有效 shell 1234567891011121314[root@master ~]# salt '*' cmd.shellszwidc_kvm_192.168.1.104: - /bin/sh - /bin/bash - /sbin/nologin - /user/bin/sh - /usr/bin/bash - /usr/sbin/nologinagent1.salt: - /bin/sh - /bin/bash - /sbin/nologin - /bin/dash cmd.which 和 cmd.which_bin 用法 就是查找执行文件所在的位置，which 命令嘛都不陌生1234567891011121314151617181920# 查看节点所有 ifconfig 命令的位置，在写脚本或者定时任务的时候很有用salt '*' cmd.which ifconfig# 因为系统不同执行文件的绝对路径也不同 和 salt '*' cmd.run "which ifconfig" 一个效果# 这是定义了一个列表，返回在命令列表中找到的第一个命令salt '*' cmd.which_bin '[cat, ifconfig, touch]'# 存在就返回第一个命令的路径[root@master ~]# salt '*' cmd.which_bin '[cat, ifconfig, touch]'agent1.salt: /bin/catzwidc_kvm_192.168.1.104: /usr/bin/cat# 如果第一个命令不存在就往后寻找[root@master ~]# salt '*' cmd.which_bin '[cat, ifconfig, touch]'zwidc_kvm_192.168.1.104: /usr/bin/ifconfigagent1.salt: /bin/ifconfig cp模块常用方法 只列举一些常用的，详细的可以自行执行此命令查看 1salt 'agent1.salt' sys.doc cp cp.get_dir 和 cp.get_file 用法 就是从 master 端 cp 目录 或 文件 到 minion 端的目录，get_dir 支持与 get_file 相同的模板和 gzip 参数。对应的是 cp.push，cp.push_dir，就是把客户端的文件 或 目录推送到 master 端的 cachedir，默认为 /var/cache/salt/master/minions/minion-id/files，但是这种用法是禁用状态，一般不让 minion 端的文件或目录发送到 master 端，这里只是记录一下有这种用法。 12345678# 从 salt master 递归复制目录到 minion 客户端的 /minion/dest 目录下面salt '*' cp.get_dir salt://path/to/dir/ /minion/dest# 从服务端拷贝单个文件到 minion 端的 /minion/dest 目录下面salt '*' cp.get_file salt://path/to/file /minion/dest# 所有 Salt minions 从与其 os 粒度相同名称的目录下载 vimrc，并将其复制到 /etc/vimrcsalt '*' cp.get_file "salt://&#123;&#123;grains.os&#125;&#125;/vimrc" /etc/vimrc template=jinja cp.get_url 用法 用于从 URL 获取单个文件 1234567891011121314151617181920212223242526272829# 将 salt://cptest1/cptest1file 文件里面的内容写入到 /tmp/test 文件里面，每次都会覆盖里面的内容# 这种就跟 cp.get_file 一样salt '*' cp.get_url salt://cptest1/cptest1file /tmp/test# 如这种就把一个页面的 html 信息写入到了客户端的 /tmp/test 文件，切记只能是这种文本形式的文件，不要是压缩包啥的salt '*' cp.get_url http://blog.51niux.com/?id=116 /tmp/test# 最主要的用法还是这种，我们可以以 httpd 的形式去下载一个 sh 脚本，config 文件等salt '*' cp.get_url http://blog.51niux.com/zb_users/upload/2017/03/201703091489030442220789.txt /tmp/load_one_check.shsalt '*' cmd.run " cat /tmp/load_one_check.sh"# 下面是部分内容，这样我们很多文本类的文件就不用从 salt 服务端发布了，直接做个 ftp 服务 或 http 服务来发布文本类的东西什么的就可以了。当然 cmd.run 命令也可以了...agent1.salt: #!/bin/bash # ======================================================================================== # System loadavg plugin for Nagios # # Written by : chaishao # From : 51niux.com # Release : 1.1.0 # Creation date : 2017-03-08 # Revision date : 2017-03-08 # Description : Nagios plugin (script) to check system load_one . # This script has been designed and written on Linux System. # # USAGE : ./$PROGNAME [-w -c] # # Exemple: : ./$PROGNAME -w n1 -c n2 # ======================================================================================== cp.list_master 和 cp.list_master_dirs 用法 这个就是查看 salt master 本地的 file 服务器又哪些文件 或 目录 12345# 这种就不要指定所有机器了，匹配一台机器就可以了，列出存储在主机上的所有文件salt 'agent1.salt' cp.list_master# 列出存储在 master 主机上面的所有目录salt 'agent1.salt' cp.list_master_dirs 123456789101112# 查看目录下的文件[root@master cptest2]# salt 'agent1.salt' cp.list_masteragent1.salt: - cptest1/cptest1file# 只会将目录列出来以及子目录[root@master cptest2]# salt 'agent1.salt' cp.list_master_dirsagent1.salt: - . - cptest1 - cptest2 - cptest2/cptest2dir file 模块常用方法file.access 用法 f 代表存在rwx 分别代表读、写、执行权限file.file_exists、file.get_mode 和 file.stats 的用法1234567891011121314151617181920212223# 查看 /opt/check.sh 文件是否存在，这个挺有用的salt '*' file.access /opt/check.sh f# 我们查看某个脚本或者某个文件是否存在# 上面的例子也可以写成这种salt '*' file.file_exists /opt/check.sh# 文件存在就返回True，否则返回False# 如果有此脚本之后，我们还可以查看此脚本是否具有执行权限salt '*' file.access /opt/check.sh x# f、r、w、x 只能写一种，真就返回true，否则falsesalt '*' file.get_mode /etc/passwd# file.get_mode 后面指定目录或者文件，可以查看其授权情况，如文件一般是0644，如果文件或目录不存在无信息# 还有# file.is_blkdev 检查文件是否存在并且是块设备# file.is_chrdev 检查文件是否存在并且是字符设备# file.is_fifo 检查文件是否存在并且是FIFO# file.is_link 检查路径是否是符号链接）# file.stats 返回一个文件 或 目录的统计信息salt '*' file.stats /etc/passwd# 这里是返回 /etc/passwd 文件的统计信息（类型，时间，属组，权限等） file.append 和 file.write 用法 前者将内容追加到文件的末尾，后者是直接覆盖类似于 echo &gt;，但是格式跟前者一样 12345678910111213# 第一组：单引号 和 双引号 的区别，还有 ! 需要注意的地方salt '*' file.append /tmp/1 "`hostname` This is a good day\!"# 用双引号，就是里面可以接变量，但是这个 ! 需要注意，不用 \ 转义的话会报错# salt '*' file.append /tmp/1 '`hostname` This is a good day!'# 所以如果出现 ! 最好放到单引号里面来引用，因为上面就算转义了也显示的不对# 第二组：换行符的使用salt '*' file.append /tmp/1 "Two""Two Two"# 这表示两组字符串在一行，中间默认加个空格隔开# 这表示两组字符串是换行的salt '*' file.append /tmp/1 "Two" "Two Two" 1234567[root@activemq ~]# cat /tmp/1master.hadoop This is a good day\!'hostname' This is a good day!TwoTwo TwoTwoTwo Two[root@activemq ~]# 上面两组测试结果，可以明显的比较出差别 1234567891011121314151617# 第三组：! 是不知道怎么解决了，要么就放单引号# 还有个 = 是需要注意的，有个 args 用法，以及 [] 外面加不加双引号的区别# 如果字符串里面有等号要用这种 args 的用法salt '*' file.append /tmp/1 args='Hostname=`hostname`'# args 用 单引号 和 双引号 的区别就在于里面的变量是否解析为变量的值还是字符串salt '*' file.append /tmp/1 args="Hostname=`hostname`"# 这里就是定义一个并排的两个字符串salt '*' file.append /tmp/1 args=['Hostname=`hostname`''rel=`cat /etc/redhat-release`']# 可见 args 默认是单引号的形式，两组字符串中间加逗号salt '*' file.append /tmp/1 args=['Hostname=`hostname`','rel=`cat /etc/redhat-release`']# 双引号 不是默认的，所以要单独的加上salt '*' file.append /tmp/1 args="['Hostname=`hostname`','rel=`cat /etc/redhat-release`']" 12345678[root@activemq !]# cat /tmp/1Hostname= hostnameHostname=master.hadoopHostname='hostname'rel='cat /etc/redhat-release'Hostname='hostname'rel='cat /etc/redhat-release'Hostname=master.hadooprel=CentOS release 6.4 (Final) 从结果我们可以看出，两个字符串之间如果没有逗号的话，不换行，但是中间也没有分隔，可以学习 awk，在两个字符串中间加 “ “ 来进行添加空格的操作。其实主要还是字符串里面有=就用 args 的形式，如果是多组字符串可以用[]的形式，如果要是用变量就用双引号的形式，默认是单引号的形式。 file.chgrp、file.chown 和 file.set_mode 用法 前者是更改文件的属组，中者是更改文件数的属主属组，后者是更改文件或目录的权限 1234567891011# 将 minion 端的 /tmp/1 文件更改用户组为 test9salt '*' file.chgrp /tmp/1 test9# 如果客户端有此用户组则返回 None，没有此用户组则返回用户组不存在# 第一个是用户，第二个是用户组，固定格式必须存在salt '*' file.chown /tmp/1 test7 test9# 将 /tmp/1 的用户组设置为 test7，用户组设置为 test9# 设置 /opt/cs 目录权限为 0550salt '*' file.set_mode /opt/cs 0550# 如果授权成功会显示授权后的权限，如果没有此文件或目录会提示 file.comment 和 file.comment_line 用法 注释指定内容的行，每次操作前都会更新文件名命令的 .bak 备份文件12345678910# 这就是将以 /tmp/passwd 文件以 ftp 开头的行注释掉salt '*' file.comment /tmp/passwd ftp# 如果注释会显示注释行的信息，如果没注释则返回False# 另外还支持正则表达式，这里就表示以 ftp 开头以 nologin 结尾的行，多行注释salt '*' file.comment /tmp/passwd ftp.*nologin$# 后面可以指定在行开头加什么字符，当然默认是 #salt '*' file.comment /tmp/passwd ftp.*nologin$ '-'# 前面也可以这样后面指定要行头添加的字符 file.copy 用法 复制文件 或 目录到指定的目录下面，成功返回True，失败会有提示的另外还有 file.move，移动文件的用法 12345678910111213141516# 这里是文件拷贝，将文件 /path/to/src 拷贝到 /path/to/ 目录下面，其名称为 dstsalt '*' file.copy /path/to/src /path/to/dst# 切记这里一定要是文件名# 目录复制的区别看下面的例子# 复制目录的话，要加 recurse=True 递归标记salt '*' file.copy /opt/file2 /tmp/haha/ recurse=True# 这种不管是 /tmp/haha/ 还是 /tmp/haha，如果这个 haha 存在的话，就是将 /opt/file2 下面的内容 cp -r 拷贝到 /tmp/haha 目录下面，如果 haha 目录不存在的话，就是将 /opt/file2 目录变为 /tmp/haha 目录# 这种才是正确的将 /opt/file2 目录复制到 /tmp/haha/ 目录下方salt '*' file.copy /opt/file2 /tmp/haha/file2 recurse=True# 如 haha 目录不存在会创建# remove_existing=True 这种就是完全覆盖的形式salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True remove_existing=True file.directory_exists 和 file.dirname 用法 前者检查一个目录是否存在，后者取文件的路径 12345678# /tmp/haha/file 目录存在就会返回True，不存在就会返回Falsesalt '*' file.directory_exists /tmp/haha/file2# 取出来的结果是 /opt/file2，这就是末尾加 /，认为这两个都是目录，当然不管是否有这个目录salt '*' file.dirname '/opt/file2/'# 取出来的结果是 /opt/file2salt '*' file.dirname '/opt/file2/test1' file.find 用法 类似于 Linux下面的 find 命令 123456789101112131415161718192021222324252627282930313233343536salt '*' file.find / type=f name=\*.bak size=+10m# 查找/目录下，文件类型为文件的# a：所有文件类型# b：块设备# c：字符设备# d：目录# p：FIFO（命名管道）# f：普通文件# l：符号链接# s：套接字，名称为 .bak 结尾的（这里支持正则表达式），大小大于 10MB 的文件# b：字节# k：千字节# m：兆字节# g：GB# t：太字节也是TBsalt '*' file.find /var mtime=+30d size=+10m print=path,size,mtime# 这里是查找 /var 目录下，最后一次更改时间是 30 天以前# w：周# d：天# h：小时# m：分钟# s：秒，大小大于 10MB 的文件，并打印文件的路径，大小，更改时间# 可打印的内容有# group：组名# md5：文件内容的 MD5 摘要# mode：文件权限（以整数形式）# mtime：最后修改时间# name：文件基础名称# path：文件绝对路径# size：文件大小（以字节为单位）# type：文件类型# user：用户名salt '*' file.find /var/log name=\*.[0-9] mtime=+30d size=+10m delete# find 的匹配条件有（name区分大小写，iname不区分大小写，type类型，user用户，group用户组，size[+-]大小，mtime修改时间，grep搜索文件内容），最后执行的动作除了 delete 和 print，还有 exec command file.get_gid、file.get_uid 和 file.get_group、file.get_user 用法 前一组返回文件或目录的 gid号 和 uid号，后一组返回文件或目录 group 和 user 1234567# 查看 /etc 目录的属组salt '*' file.get_user /etc# 如果文件或目录不存在返回 false# 查看 /etc 目录的属组的 uid 号salt '*' file.get_uid /etc# 如果目录或者文件不存在返回 -1 file.grep 用法 类似于 Linux上面的 grep 命令 12345678910111213salt '*' file.grep /etc/passwd nobody# 过滤 /ect/passwd 文件中包含 nobody 的行# 输出：pid: 是 grep 运行的 pid 号# retcode: 为状态码# 0 是成功过滤 1 为非成功过滤# stderr: 错误输出# stdout: 正常输出也就是我们要过滤的内容# "-i" 的目的是不区分大小写，注意 -i 前面有空格，额外的参数之间都有空格salt '*' file.grep /etc/sysconfig/network-scripts/ifcfg-eth0 ipaddr " -i" # -B2 就是连上面两行也过滤出来，-A2 就是连下两行也过滤出来salt '*' file.grep /etc/sysconfig/network-scripts/ifcfg-eth0 ipaddr " -i -B2 -A2" file.link 和 file.symlink 用法 前者是创建文件的硬链接，后者是创建符号链接也就是软链接 12345# 为 /tmp/1 创建一个硬链接是 /tmp/2，只能是文件salt '*' file.link /tmp/1 /tmp/2# 为 /tmp/haha 目录创建一个软链接 /tmp/buhaha，成功返回 Ture，失败有提示信息salt '*' file.symlink /tmp/haha /tmp/buhaha file.mkdir 和 file.makedirs 用法 两种都是创建目录，前者对结尾的/不敏感，后者对/敏感 1234567# 这就是在 /opt/ 目录下面创建 cs 目录，并在 cs 目录下面创建 ds 目录salt '*' file.mkdir /opt/cs/ds# 如果 cs 目录不存在就创建。目录存不存在也不会有提示# 这里只会创建 /opt/cs 目录，首先如果 /opt 要创建的目录是存在的会有提示salt '*' file.makedirs /opt/cs/ds# /opt/cs/ds/ 才会在 cs 目录下面创建 ds 目录 file.remove、file.rmdir 和 file.rename 用法 前者是删除文件或者目录，中间是删除目录但是目录一定要为空、后者是重命名文件或目录 123456789# 删除 /opt 目录下面的 cs 目录salt '*' file.remove /opt/cs/# 删除 /opt/cs 目录salt '*' file.rmdir /opt/cs# 如果 cs 目录下面有内容会提示目录不会空删除失败，如果为空则会执行并返回 True# 更改 /opt/cs 目录下的 ds 目录为 dss 目录salt '*' file.rename /opt/cs/ds /opt/cs/dss file.touch 和 file.truncate 的用法12345# 文件不存在则创建此文件，如果文件存在里面的内容不会发生变化，但是它的 time 信息会更新，上级目录必须存在salt '*' file.touch /tmp/test1# 将 /tmp/passwd 第三个字段以后的内容全删除掉了，就剩下了 roo 三个字段salt '*' file.truncate /tmp/passwd 3 hosts模块常用方法12# 通过这个命令可以查看详细用法，如果没有用 内建DNS服务，使用 hosts 模块修改 /etc/hosts 还是经常会用到的salt '*' sys.doc hosts hosts.add_host、hosts.rm_host 和 hosts.set_host 用法 前者是追加，中着是删除、后者是覆盖 123456789101112131415# hosts.add 会先判断 /etc/hosts 里面有没有这个 IP 192.168.1.113，如果有 foreman.puppet 会将 alias 名追加到这个 IP 后面，跟之前的解析别名一起使用这个 IPsalt '*' hosts.add_host 192.168.1.113 foreman.puppet# 如果没有这个IP，则会新创建一行 hosts 记录，但是 192.168.1.113 那条还是存在的，两条记录salt '*' hosts.add_host 192.168.1.114 foreman.puppet# hosts.set_host 这个的不同之处就是# 如果这个 IP 不存在则创建新的一条 hosts 记录# 如果 hosts 存在这个 IP 的解析记录，会完全覆盖掉，也就是旧的 IP 解析记录完全变成现在的结果salt '*' hosts.set_host 192.168.1.114 test.hahahah# 删除 192.168.1.114 test.haha 这条解析记录salt '*' hosts.rm_host 192.168.1.114 test.haha# 如果 192.168.1.114 这行有多条解析记录，而只会删除 test.haha 这条记录# 其他的 192.168.1.114 xxx.xxx，还会存在不会删除，可以说是有选择性的删除 其他查看 hosts 解析的用法12345678910111213# 192.168.1.114 这个 IP 对应的别名解析，如果有则返回对应的 hosts 别名解析记录，没有则什么都不返回salt '*' hosts.get_alias 192.168.1.114# 这个就是返回 wo.haha 在 /etc/hosts 里面对应的IP# 但是有个问题，如果有多条只会返回文件最上方的那一条对应的 IP 地址salt '*' hosts.get_ip wo.haha# 如果有这条别名解析记录，则返回True，如果没有则返回Falsesalt '*' hosts.has_pair 192.168.1.113 foreman.puppet# 类似于 cat /etc/hosts 的操作salt '*' hosts.list_hosts# 但是不同的是，这相当于一个汇总，会以第一行是IP：下一行是其对应的别名解析的方式来呈现，比如一个 IP 有好几行的解析，这所有的解析记录都会汇总到这个 IP 下面，注释过的别名解析的行不会出现在这个汇总信息里面 cron模块常用方法cron.raw_cron 用法 cron.list_tab 和 cron.ls 和跟其效果一样，格式也一样必须要指定某一个用户，都是显示指定用户 crontab 文件里面的定时任务 1salt '*' cron.raw_cron root #必须指定用户，这里是显示root的crontab文件里面的内容，注释的行也会显示 cron.set_job 用法 为指定用户设置一个定时任务 123salt '*' cron.set_job root '0' '0' '*' '*' '*' '/bin/bash /opt/scripts/scp.sh &gt; /dev/null 2&gt;&amp;1'# 如果 '/bin/bash /opt/scripts/scp.sh &gt; /dev/null 2&gt;&amp;1'# 这一部分存在了，那么这一步操作就是 update，也就是更新前面执行 crontab 的时间，如果不存在，这就相当于一条添加定时任务的操作返回内容为 new cron.rm_job 用法 删除指定用户指定的的定时任务 12# 注意格式是用户 后面跟要删除的任务，不要加前面的时间，成功会返回 removed，如果没有这条记录会返回 absentsalt '*' cron.rm_job root '/bin/bash /opt/scripts/scp.sh &gt; /dev/null 2&gt;&amp;1' network 模块常用方法1234567891011121314151617181920212223242526272829# 返回minion的主机名salt '*' network.get_hostname# 返回指定网络接口的mac地址salt '*' network.hw_addr eth0# 查看主机在某个子网内就返回True，如果不在的话就返回False，多子网用空格隔开salt '*' network.in_subnet 192.168.1.0/24# 查看 minion 端绑定的 IP 地址，多 IP 也会显示出来，127.0.0.1除外salt '*' network.ip_addrs# 会显示所有接口的详细信息，但是别名的网卡类似于 eth0:1 这种不会显示salt '*' network.interfaces# 显示指定网卡接口上面的 IP，只会显示 IP 不会显示其他内容# network.interface 会连网关子网掩码也显示salt '*' network.interface_ip eth0# 修改某一个minion的主机名，显然这一步操作只适合在初始化的时候而且不适合执行所有主机salt 'agent1.salt' network.mod_hostname test1.saltsalt '*' network.ping www.baidu.com return_boolean=True timeout=3# 如果不加 return_boolean=True 显示的是 ping 的结果信息，加了就是如果 ping 通了就返回True，ping 不通就返回 False# timeout=3 就是 ping 的时间，3秒超时这样能快速返回结果# 这个其实挺好用的，比如我们可以测试哪些主机的 DNS 设置有问题不能正常解析啊，或是我们内网 DNS 指向了一个非公网的域名解析，可以通过这个看哪些主机设置了内网 DNS 而哪些没设置内网 DNS# 返回主机所属的子网salt '*' network.subnets sys模块常用方法sys.argspec 用法 返回 Salt 执行模块中函数的参数说明。对于我们后期写 .sls文件 很有帮助 12345# 查看 pkg.install 函数的参数说明salt '*' sys.argspec pkg.install# 查看sys模块里面所有函数的规则说明，或者#salt '*' sys.argspec 'sys.*'salt '*' sys.argspec sys sys.doc 用法 显示模块下函数的使用文档信息类似于man帮助，前面已介绍过，多模块或者多函数之间用空格隔开 sys.list_functions 和 sys.list_modules 用法 前者就是列出所有模块下面的函数，多模块也是用空格隔开。后者是将所有模块列出来 12345678# 可以用这种方法将所有 sys.list 开头的函数列出来salt '*' sys.list_functions 'sys.list_*'# 列出所有的模块salt '*' sys.list_modules# 列出所有以 s 开头的模块salt '*' sys.list_modules 's*' service 模块常用方法1234567891011121314151617181920212223242526272829303132333435# 查看某个命令的服务是否可用，这里是查看sshd服务是否可用，可用返回True，不可用返回Falsesalt '*' service.available sshd# 禁止某个服务开机启动，这里是禁止 postfix 服务开机启动salt '*' service.disable postfix# 查看某个服务是否已经开机不启动，这里是以postfix服务为例，是返回True，否则返回Falsesalt '*' service.disabled postfix# 设置某个服务开机启动，这里以 postfix 为例salt '*' service.enable postfix# 查看某个服务是否开机启动，这里以 postfix 服务为例salt '*' service.enabled postfix# 查看所有的服务项salt '*' service.get_all# 查看所有开机启动的服务salt '*' service.get_enabled# 重新加载指定名称的服务salt '*' service.reload &lt;service name&gt;# 重新启动指定名称的服务salt '*' service.restart &lt;service name&gt;# 启动指定名称的服务salt '*' service.start &lt;service name&gt;# 查看指定服务的状态，启动状态是True，关闭状态是Falsesalt '*' service.status &lt;service name&gt;# 关闭指定名称的服务salt '*' service.stop &lt;service name&gt; pkg 模块常用方法pkg.install 用法 安装传递的包，在安装包之前，添加 refresh=True 来清理 yum 数据库 1234567891011121314151617181920# 参数介绍name # 要安装的软件包的名称。如果传递了 "pkgs" 或 "sources" 此参数则会被忽略# 如这就相当于在 minion 端执行 yum -y install httpd 操作salt '*' pkg.install httpd# 如果是第一个 yum 的话，还是可以 refresh 参数，相当于 yum clean all 操作salt '*' pkg.install httpd refresh=Trueskip_verify # 跳过 GPG 验证检查version # 安装包的特定版本fromrepo # 指定从哪个 repo 库来安装软件pkgs # 指定多个软件包，一定是要以列表传递salt '*' pkg.install pkgs='["foo", "bar"]'salt '*' pkg.install pkgs='["foo", &#123;"bar": "1.2.3-4.el5"&#125;]'sources # 要安装的RPM软件包列表，其中的键是包名称，值作为包的源URI或本地路径salt '*' pkg.install sources='[&#123;"foo": "salt://foo.rpm"&#125;, &#123;"bar": "salt://bar.rpm"&#125;]' pkg.latest_version 用法 更新软件包至最新版本 12345678# 更新指定的软件包salt '*' pkg.latest_version &lt;package name&gt;# 指定 repo 源来更新软件包salt '*' pkg.latest_version &lt;package name&gt; fromrepo=epel-testing# 多个要更新的软件之间用空格隔开salt '*' pkg.latest_version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ... pkg.remove 用法 删除软件的操作 12345678# 卸载指定的软件salt '*' pkg.remove &lt;package name&gt;# 多软件可以用空格隔开salt '*' pkg.remove &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt;# 也可以用 pkgs 使用 python 列表的形式salt '*' pkg.remove pkgs='["foo", "bar"]' salt ‘*’ pkg.version 用法 查看软件的版本 12345# 查看指定软件的版本号salt '*' pkg.version &lt;package name&gt;# 查看多软件版本号salt '*' pkg.version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ... 参考文档http://blog.51niux.com/?id=116]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack 常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成CI持续交付CD]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98CD%2F</url>
    <content type="text"><![CDATA[持续集成CI/持续交付CD CI 很容易理解，就是持续集成。但是 CD 既可以指代码持续交付，也可理解为代码持续部署。CI 和 CD 之间有很多相似的部分，但是也有很大的区别。 持续集成 (Continuous Integration)在持续集成环境中，开发人员将会频繁的提交代码到主干。这些新提交在最终合并到主线之前，都需要通过编译和自动化测试流进行验证。这样做是基于之前持续集成过程中很重视自动化测试验证结果，以保障所有的提交在合并主线之后的质量问题，对可能出现的一些问题进行预警。 持续交付 (Continuous Delivery)持续交付就是讲我们的应用发布出去的过程。这个过程可以确保我们尽可能快的实现交付。这就意味着除了自动化测试，我们还需要有自动化的发布流，以及通过一个按键就可以随时随地实现应用的部署上线。通过持续交付，可以决定每天，每周，每两周发布一次，这完全可以根据自己的业务进行设置。但是，如果您真的希望体验持续交付的优势，就需要先进行小批量发布，尽快部署到生产线，以便在出现问题时方便进行故障排除。 持续部署 (Continuous Deployment)如果我们想更加深入一步的话，就是持续部署了。通过这个方式，任何修改通过了所有已有的工作流就会直接和客户见面。没有人为干预（没有一键部署按钮），只有当一个修改在工作流中构建失败才能阻止它部署到产品线。持续部署是一个很优秀的方式，可以加速与客户的反馈循环，但是会给团队带来压力，因为不再有“发布日”了。开发人员可以专注于构建软件，他们看到他们的修改在他们完成工作后几分钟就上线了。基本上，当开发人员在主分支中合并一个提交时，这个分支将被构建、测试，如果一切顺利，则部署到生产环境中。 合并 CI CD and CD？当然，正如我所说，他们每部分都更加接近生产环境。你可以构建自己的持续集成环境，然后，一旦团队适应，你可以添加持续交付流，最后，可以添加持续部署流到整个工作流中。 举例 CI，CD 和 CD 流水线 到底值不值这样做？ 持续集成 需要具备哪些条件？ 你的团队需要为每个新功能，代码改进，或者问题修复创建自动化测试用例。你需要一个持续集成服务器，它可以监控代码提交情况，对每个新的提交进行自动化测试。研发团队需要尽可能快的提交代码，至少每天一次提交。 可以获得什么？ 通过自动化测试可以提早拿到回归测试的结果，避免将一些问题提交到交付生产中发布编译将会更加容易，因为合并之初已经将所有问题都规避了减少工作问题切换，研发可以很快获得构建失败的消息，在开始下一个任务之前就可以很快解决。测试成本大幅降低-你的 CI 服务器可以在几秒钟之内运行上百条测试。你的 QA 团队花费在测试上面的时间会大幅缩短，将会更加侧重于质量文化的提升上面。 持续交付 需要具备的条件 你需要有强大的持续集成组件和足够多的测试项可以满足你代码的需求部署需要自动化。触发是手动的，但是部署一旦开始，就不能人为干预。你的团队可能需要接受特性开关，没有完成的功能模块不会影响到线上产品。 可以获得什么？ 繁琐的部署工作没有了。你的团队不在需要花费几天的时间去准备一个发布。你可以更快的进行交付，这样就加快了与客户之间的反馈环。轻松应对小变更，加速迭代 持续部署 需要具备的条件 研发团队测试理念比较完善。测试单元的健壮性直接决定你的交付质量。你的文档和部署频率要保持一致。特征标志成为发布重大变化过程的固有部分，以确保您可以与其他部门（支持，市场营销，公关…）协调。 可以获得什么？ 发布频率更快，因为你不需要停下来等待发布。每一处提交都会自动触发发布流。在小批量发布的时候，风险降低了，发现问题也可以很轻松的修复。客户每天都可以看到我们的持续改进和提升，而不是每个月或者每季度，或者每年。如前所述，您可以采用持续集成，持续交付和持续部署。你怎么做取决于你的需求和你的业务情况。如果你刚刚开始一个项目，并且还没有客户，那么你就可以去创建这些工作流，最好是将这三个方面都实现，并且在你的项目迭代和需求增长中同时迭代它们。如果您已经有一个生产项目，那么您可以一步一步地分阶段去实现他们。 参考文档https://www.sohu.com/a/204652724_640923]]></content>
      <categories>
        <category>CI/CD笔记</category>
      </categories>
      <tags>
        <tag>持续集成CI持续交付CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数基础]]></title>
    <url>%2F2018%2F08%2F03%2FPython-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Python函数基础 什么是函数？ 函数就是具备某一功能的工具 函数的使用必须遵循先定义，后调用的原则 实现准备工具的过程即函数的定义 拿来就用即函数的调用 函数氛围两大类 内置函数 自定义函数 为什么要用函数？ 不用函数的问题 代码的组织结构不清晰，可读性差 遇到重复的功能只能重复编写实现代码，代码冗余过多 程序的扩展性差，功能需要扩展时，需要找出所有实现该功能的地方修改之，无法统一管理且维护难度极大 怎么用函数？ 定义函数语法12345678910def 函数名(参数1,参数2,参数3,...): """ 文档注释 """ 函数体 code1 code2 code3 ...... return 返回值 自定义函数的三种形式无参函数1234567891011def func1(): print('hello1') print('hello2') print('hello3')func1()# 输出结果hello1hello2hello3 有参函数1234567891011121314def func2(x, y): if x &gt; y: print(x) else: print(y)func2(1, 3)func2(2, 3)func2(2, 4)# 输出结果334 空函数 用于预设程序的框架 12345678910def get(): # 下载功能 passdef put(): # 上传功能 passdef auth(): # 认证功能 passdef ls(): # 浏览功能 passdef cd(): # 切换目录的功能 pass 定义函数阶段 相当于定义了一个名字，名字指向了一个值，值是内存地址，该地址包含了函数体代码定义函数阶段，只检测语法，不执行函数体代码 123456789101112131415def foo(): # foo = 函数的内存地址 print('first') print('second') print('third')print(foo) # 打印输出函数值内存地址# 输出结果&lt;function for at 0x000001E71A588950&gt;foo() # 函数调用阶段# 输出结果firstsecondthird 测试一123456789101112def bar(): print('from bar')def foo(): print('from foo') bar()foo()# 输出结果from foofrom bar 测试二123456789101112def foo(): print('from foo') bar()def bar(): print('from bar')foo() # 调用阶段# 输出结果from foofrom bar 调用函数语法1函数名() 调用函数过程 根据函数名找到函数的内存地址函数的内存地址加括号可以触发函数体代码的运行 调用函数的三种形式无参函数1234567def f1(): print('from f1')f1()# 输出结果from f1 有参函数1234567891011def max(x, y): if x &gt; y: return x else: return yres = max(1, 2)print(res)# 输出结果2 1234567891011def max(x, y): if x &gt; y: return x else: return yres = max(1, 2)*10print(res)# 输出结果20 当作参数传给其他函数 1234567891011def max(x, y): if x &gt; y: return x else: return yres = max(max(1, 2), 3)print(res)# 输出结果3 函数的返回值什么是返回值？函数的返回值是函数体代码运行的一个结果 什么时候使用返回值？如何使用？ return 返回值： 返回值没有类型限制 返回值没有个数限制逗号分隔多个值，返回一个元组一个值，返回值本身没有return，默认返回None 12345678def f1(): return [1, 2,]res = f1()print(res)# 输出结果[1, 2] 逗号分隔多个值，返回一个元组12345678def f1(): return 1, 2, [1, 2, 3]res = f1()print(res)# 输出结果(1, 2, [1, 2, 3]) 没有return，默认返回None12345678def f1(): passres = f1()print(res)# 输出结果None return 是函数结束的标志函数内可以有多个return，但只要执行一次，整个函数就立即结束，并且将return后的值当作本次调用的结果返回123456789101112def f1(): print(1) return 'first' print(2) return 'second' print(3) return 'third'f1()# 输出结果1 总结 函数使用的原则：先定义，再调用 函数名即“变量名”，“变量名”必须先定义后引用。未定义而直接引用函数，就相当于在引用一个不存在的变量名 我们在使用函数时，一定要明确地区分定义阶段和调用阶段 函数在定义阶段都做了哪些事？ 只检测语法，不执行代码 也就说，语法错误在函数定义阶段就会检测出来，而代码的逻辑错误只有在执行时才会知道 函数名：是用来访问到函数的内存地址，拿到函数的内存地址加括号就可以触发函数体代码函数参数：是外部调用者为函数体传值的媒介函数体代码：是函数功能的具体实现 return 函数返回值：函数的返回值是函数体执行的成果 返回值没有类型限制 返回值没有个数限制 没有return，默认返回None return 值1：返回值1 return 值1, 值2, 值3：返回(值1, 值2, 值3) return 注意点： return 是函数结束运行的标志，函数体内可以都有多个 return 但是只有执行一次，整个函数就终止运行]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python修改文件内容]]></title>
    <url>%2F2018%2F08%2F01%2FPython-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Python修改文件内容 想要修改文件中的内容，没有办法直接实现。硬盘上的数据都是一圈一圈写的，没有修改一说，都是新数据覆盖老数据 12vim db.txt你好哈哈哈 预期 在 你好 后面插入 上上上 1234567with open('db.txt' mode='r+t', encoding='utf-8') as f: f.seek(6, 0) # 移动了6个bytes f.write('上上上')# 执行结果cat db.txt你好上上上 使用 seek() 文件指针偏移 会覆盖其他内容，不好掌控 方法一 先将文件内容全部读入内存 在内存中修改完毕 将修改的结果覆盖写回硬盘中 12vim db.txtHello World! 优点：在修改期间硬盘上同一时刻只有一份数据缺点：占用内存过高 1234567891011with open('db.txt', mode='rt', encoding='utf-8') as f: data = f.read() new_data = data.replace('World', 'Python') print(new_data)with open('db.txt', mode='wt', encoding='utf-8') as f: f.write(new_data)# 执行结果cat db.txtHello Python! 方法二（推荐使用） 一行一行的读，一行一行的改 以读的模式打开源文件，以写的模式打开一个临时文件（解决占用内存的问题） 然后用 for 循环读取原文件一行行内容，每读一行则修改一行，将修改的内容写入临时文件，直到把源文件都遍历完， 删除原文件，将临时文件重命名为原文件名 1234567891011import oswith open('db.txt', mode='rt', encoding='utf-8') as src_f, \ open('.db.txt.swap', mode='wt', encoding='utf-8') as temp_f: for line in src_f: if 'World' in line: line = line.replace('World', 'Python') temp_f.write(line)os.remove('db.txt')os.rename('.db.txt.swap', 'db.txt') 优点：同一时刻在内存中只存在文件的一行内容缺点：在修改期间，硬盘上同一份数据会保存两份]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python修改文件内容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典操作]]></title>
    <url>%2F2018%2F07%2F30%2FPython-%E5%AD%97%E5%85%B8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Python字典操作字典（dict），是一系列放在 {} 的键值对（key-value）。可以使用键来访问对应的值，与键对应的值可以是 数字、字符串、列表、字典字典具有极快的查找速度。 下边是一个与手机信息相关的 dict1&#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125; 使用 dict()方法 创建字典1d = dict(os= 'Android', soc='Qualcomm', screen='Samsung') 使用可迭代对象（列表、元组等）也可以创建字典123456&gt;&gt;&gt; d = dict((['x', 1], ['y', 2], ['z', 3]))&gt;&gt;&gt; d&#123;'x': 1, 'y': 2, 'z': 3&#125;&gt;&gt;&gt; d = dict(zip(('x', 'y', 'z'), (1, 2, 3)))&gt;&gt;&gt; d&#123;'x': 1, 'y': 2, 'z': 3&#125; 使用 fromkeys()内建方法 创建默认字典12&gt;&gt;&gt; &#123;&#125;.fromkeys(('x', 'y', 'z'), -1)&#123;'x': -1, 'y': -1, 'z': -1&#125; 访问字典中的值123456789101112131415&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;# 通过 key 访问 value，如果 key 不存在则报错&gt;&gt;&gt; m['os']'Android'# 为了避免 key 不存在报错问题，可以使用 get 方法，如果 key 不存在则返回 None，或指定返回值&gt;&gt;&gt; m.get('soc')'Qualcomm'# key 不存在时，指定返回值&gt;&gt;&gt; m.get('xxx'，-1)-1# 除了 get 方法外，还可以先通过 in 判断 key 是否存在&gt;&gt;&gt;'xxx' in mFalse&gt;&gt;&gt;'os' in m True 添加 key-value 为字典增加一项 1234&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; m['camera'] = 'Sony'&gt;&gt;&gt; m&#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung', 'camera': 'Sony'&#125; 删除 key-value123456789101112&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; del m['os']&gt;&gt;&gt; m&#123;'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; m.pop('soc')'Qualcomm'&gt;&gt;&gt; m&#123;'screen': 'Samsung'&#125;# 删除所有键值对&gt;&gt;&gt; m.clear()&gt;&gt;&gt; m&#123;&#125; 修改字典中的值1234&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; m['screen'] = 'BOE'&gt;&gt;&gt; m&#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'BOE'&#125; 字典的长度（键值对数量）123&gt;&gt;&gt; d = &#123;'x': 1, 'y': 2, 'z': 3&#125;&gt;&gt;&gt; len(d)3 update() 字典合并 将一个字典的内容添加到另一个字典12345&gt;&gt;&gt; d = &#123;'x': 1, 'y': 2, 'z': 3&#125;&gt;&gt;&gt; d1 = &#123;'m': 4, 'n': 5&#125;&gt;&gt;&gt; d.update(d1)&gt;&gt;&gt; d&#123;'x': 1, 'y': 2, 'z': 3, 'm': 4, 'n': 5&#125; 遍历字典遍历字典的键 key12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for key in d.keys():··· print(key)1list111tuple 遍历字典的值value12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for value in d.values():··· print (value)[1, 2, 3]123python3(4, 5, 6) 遍历获取 key 和 value1234567&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; for key in m:··· print(key + ' -&gt; ' + m[key])os -&gt; Androidsoc -&gt; Qualcommscreen -&gt; Samsung 12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1:123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for key in d:··· print(str(key) + ':' + str(d[key]))list:[1, 2, 3]1:123111:python3tuple:(4, 5, 6) 遍历字典的项 items，获取 key 和 value items() 返回一个列表，列表的每一个元素是一个包含 key、value 的 tuple 12345678&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;# m.items() 返回一个列表，列表的每一个元素是一个包含 key、value 的 tuple&gt;&gt;&gt; for key, value in m.items():··· print(key + ' -&gt; ' + value)os -&gt; Androidsoc -&gt; Qualcommscreen -&gt; Samsung 12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for item in d.items():··· print(item)('list', [1, 2, 3])(1, 123)('111', 'python3')('tuple', (4, 5, 6)) 12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for key, value in d.items():··· print(key, value)list [1, 2, 3]1 123111 python3tuple (4, 5, 6) 12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for (key, value) in d.items():··· print(key, value)list [1, 2, 3]1 123111 python3tuple (4, 5, 6)]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python字典操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件内指针移动]]></title>
    <url>%2F2018%2F07%2F28%2FPython-%E6%96%87%E4%BB%B6%E5%86%85%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Python文件内指针移动 read(3) 文件打开方式为文本模式时，代表读取 3 个字符 文件打开方式为 b模式 时，代表读取 3 个字节 其余的文件内光标移动都是以字节为单位如 seek，tell，truncate seek() 文件内光标操作 seek 有三种移动方式 0，1，2其中 1 和 2 必须在 b模式 下进行，但无论哪种模式，都是以 bytes 为单位移动的 单位统一为字节第一个参数：控制移动的字节数第二个参数：控制移动的参照物，值可以为：0、1、20：参照文件开头，默认为01：参照当前位置2：参照文件末尾 0：参照文件开头（在 b 和 t 模式下都能使用） 默认为 0强调：除了 0 模式以外的模式都只能在 b 模式下使用1 和 2 只能用在 b 模式下 12cat e.txt你好hello 123456with open('e.txt', mode='rt', encoding='utf-8') as f: f.seek(3) print(f.read())# 输出结果好hello 如果一个 字节 没有读完，会报以下错误 1234567with open('e.txt', mode='rt', encoding='utf-8') as f: f.seek(2) print(f.read())# 输出结果(result, consumed) = self._buffer_decode(data, self.errors, final)UnicodeDecodeError: 'utf-8' codec can't decode byte 0xa0 in position 0: invalid start byte 123456with open('e.txt', mode='rt', encoding='utf-8') as f: f.seek(6, 0) print(f.read())# 输出结果hello 1234567with open('e.txt', mode='rt', encoding='utf-8') as f: f.read() f.seek(0, 0) print('第二次', f.read())# 输出结果第二次 你好hello 1：参照当前位置（只能在 b模式下使用） 储备：read(n)read 的 n 在 t模式下 读的是字符个数123456with open('e.txt', mode='rt', encoding='utf-8') as f: data = f.read(2) print(data)# 输出结果你好 read 的 n 在 b模式下 读的是字节个数123456with open('e.txt', mode='rb') as f: data = f.read(3) print(data)# 输出结果b'\xe4\xbd\xa0' 123456with open('e.txt', mode='rb') as f: data = f.read(3) print(data.decode('utf-8'))# 输出结果你 其余所有文件内指针的移动都是以字节为单位 123456with open('e.txt', mode='rt', encoding='utf-8') as f: s = f.read(1) print(s)# 输出结果你 12345678with open('e.txt', mode='rt', encoding='utf-8') as f: s = f.read(1) print(s) print(f.tell()) # 查看当前指针位置# 输出结果你3 # 表示当前指针在第 3 个字节 1234567with open('e.txt', mode='rt', encoding='utf-8') as f: s = f.read(1) # 读取一个字符 f.seek(6, 0) # 0 将指针放到文件开头，移动到第 6 个字节位 print(f.read()) # 打印输出# 输出结果hello 12345678with open('e.txt', mode='rb') as f: s = f.read(3) # f.seek(6, 0) f.seek(3, 1) print(f.read())# 输出结果b'hello' 12345678with open('e.txt', mode='rb') as f: s = f.read(3) # f.seek(6, 0) f.seek(3, 1) print(f.read().decode('utf-8'))# 输出结果hello 2：参照文件末尾（只能在 b模式下使用）1234cat e.txt你好hello1你好hello2你好hello3 123456with open('e.txt', mode='rb') as f: f.seek(-6,2) # 读取 'hello3' print(f.read())# 输出结果b'hello3' truncate 截断文件 文件的打开方式必须可写，但是不能用 w 或 w+ 等方式打开，因为那样直接清空文件了所以 truncate 要在 r+ 或 a 或 a+ 等模式下测试效果a：追加写r+：可读可写 1234cat e.txt你aaa好hello1你好hello2你好hello3 123456with open('e.txt', mode='at', encoding='utf-8') as f: f.truncate(9) # 从文件开头截取到 3个bytes 的位置，其余的删除# 执行结果cat e.txt你aaa好 123456with open('e.txt', mode='r+t', encoding='utf-8') as f: f.truncate(9) # 从文件开头截取到 3个bytes 的位置，其余的删除# 执行结果cat e.txt你aaa好 练习：基于 seek 实现 tail -f 功能12345678910import timewith open('test.txt', 'rb') as f: f.seek(0,2) while True: line = f.readline() if line: print(line.decode('utf-8')) else: time.sleep(0.2)]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python文件内指针移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ集群配置]]></title>
    <url>%2F2018%2F07%2F25%2FRabbitMQ%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[RabbitMQ 集群配置这里展示的是多机集群的部署，如果机器受限，可以选择单机集群部署 RabbitMQ 可以通过三种方法来部署分布式集群系统分别是：cluster，federation，shovel cluster 不支持跨网段，用于同一个网段内的局域网 可以随意的动态增加或者减少 节点之间需要运行相同版本的 RabbitMQ 和 Erlang federation 应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器上交换机或队列的消息，可以是单独机器或集群。federation 队列类似于单向点对点连接，消息会在联盟队列之间转发任意次，直到被消费者接受。通常使用 federation 来连接 internet 上的中间服务器，用作订阅分发消息或工作队列。 shovel 连接方式与 federation 的连接方式类似，但它工作在更低层次。可以应用于广域网。 节点类型 Ram node：内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速。 Disk node：将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启 RabbitMQ 的时候，丢失系统的配置信息。 选用三台主机，主机名分别是 pro-rabbitmq01pro-rabbitmq02pro-rabbitmq03 集群配置RabbitMQ 是用 Erlang 开发的，集群非常方便，因为 Erlang 天生就是一门分布式语言，但其本身并不支持负载均衡。RabbitMQ 利用 Erlang 的分布式特性组建集群，erlang 集群通过 magic cookie 实现，此 cookie 保存在 $HOME/.erlang.cookierpm安装即 /var/lib/rabbitmq/.erlang.cookie二进制安装在 /data/erlang/.erlang.cookie需要保证集群各节点的此 cookie 一致，可以选取一个节点的 cookie，用 rsync，scp 同步到其余节点。 同步 Cookie读取其中一个节点的 cookie，并复制到其他节点节点之间通过 cookie 确定相互是否可通信。cookie 存放在 /var/lib/rabbitmq/.erlang.cookie或$HOME/.erlang.cookie 中 设置 Erlang CookieRabbitMQ 的集群是依赖于 Erlang 的集群来工作的，所以必须先构建起 Erlang 的集群环境。Erlang 的集群中各节点是通过一个 magic cookie 来实现的，这个 Cookie 存放在 /data/erlang/.erlang.cookie 中，文件是 400 的权限。所以必须保证各节点 Cookie 保持一致，否则节点之间就无法通信。我们是删除其中两台的 /data/erlang/.erlang.cookie，然后将另一台的 /data/erlang/.erlang.cookie 拷贝到这两台上。文件权限是 400 注意：.erlang.cookie 文件的权限，RabbitMQ账号，权限 400 或 600 即可，为组或 other 账号赋权会报错 123rsync -avzP /data/erlang/.erlang.cookie root@10.21.20.94:/data/erlang/# scp /var/lib/rabbitmq/.erlang.cookie root@1.1.1.2:/var/lib/rabbitmq/# scp /var/lib/rabbitmq/.erlang.cookie root@1.1.1.3:/var/lib/rabbitmq/ 逐个启动节点1rabbitmq-server -detached 查看各节点的状态12rabbitmqctl statusrabbitmqctl cluster_status 配置各节点的 hosts 文件1234vim /etc/hostsx.x.x.x pro-rabbitmq01x.x.x.x pro-rabbitmq02x.x.x.x pro-rabbitmq03 组建集群pro-rabbitmq02 和 pro-rabbitmq03以 pro-rabbitmq01 为主节点在 pro-rabbitmq02 上 rabbitmqctl join_cluster rabbit@pro-rabbitmq01 中的 rabbit@pro-rabbitmq01，rabbit 代表集群名pro-rabbitmq01 代表集群节点节点名同 hostname，hostname 与 /etc/hosts 中设置必须保持一致pro-rabbitmq02 与 pro-rabbitmq03 均连接到 pro-rabbitmq01，它们之间也会自动建立连接。如果需要使用内存节点，增加一个 --ram 的参数即可如：rabbitmqctl join_cluster --ram rabbit@pro-rabbitmq01rabbitmqctl join_cluster rabbit@pro-rabbitmq01 --ram一个集群中至少需要一个 disk 节点默认是磁盘节点，如果是内存节点的话，需要加 --ram 参数 1234[root@pro-rabbitmq02 ~]# rabbitmqctl stop_app[root@pro-rabbitmq02 ~]# rabbitmqctl reset[root@pro-rabbitmq02 ~]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01[root@pro-rabbitmq02 ~]# rabbitmqctl start_app pro-rabbitmq03 上的操作与 pro-rabbitmq02 的相同 1234[root@pro-rabbitmq03 ~]# rabbitmqctl stop_app[root@pro-rabbitmq03 ~]# rabbitmqctl reset[root@pro-rabbitmq03 ~]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01[root@pro-rabbitmq03 ~]# rabbitmqctl start_app 12345678910111213141516171819202122232425262728[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl stop_appStopping rabbit application on node rabbit@pro-rabbitmq02 ...[root@pro-rabbitmq02 rabbitmq]# netstat -ntlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:4369 0.0.0.0:* LISTEN 2556/epmd tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2717/sshd tcp 0 0 0.0.0.0:25672 0.0.0.0:* LISTEN 2467/beam.smp tcp6 0 0 :::4369 :::* LISTEN 2556/epmd [root@pro-rabbitmq02 rabbitmq]# rabbitmqctl resetResetting node rabbit@pro-rabbitmq02 ...[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01Clustering node rabbit@pro-rabbitmq02 with rabbit@pro-rabbitmq01[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl start_appStarting node rabbit@pro-rabbitmq02 ... completed with 0 plugins.[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq02 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq01',[]&#125;,&#123;'rabbit@pro-rabbitmq02',[]&#125;]&#125;] 修改集群类型 修改 disk 节点到 内存 节点 1234567891011121314[root@pro-rabbitmq02 ~]# rabbitmqctl change_cluster_node_type ramTurning rabbit@pro-rabbitmq02 into a ram node[root@pro-rabbitmq02 ~]# rabbitmqctl start_appStarting node rabbit@pro-rabbitmq02 ... completed with 3 plugins.[root@pro-rabbitmq02 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq02 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01']&#125;,&#123;ram,['rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq01',[]&#125;,&#123;'rabbit@pro-rabbitmq02',[]&#125;]&#125;] 1234567891011121314[root@pro-rabbitmq03 rabbitmq]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq03 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01']&#125;, &#123;ram,['rabbit@pro-rabbitmq03','rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq02','rabbit@pro-rabbitmq01', 'rabbit@pro-rabbitmq03']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq02',[]&#125;, &#123;'rabbit@pro-rabbitmq01',[]&#125;, &#123;'rabbit@pro-rabbitmq03',[]&#125;]&#125;]# 可以看到三个节点都加入了集群中，两个 ram 节点、一个 disc 节点。# 其中三个节点都在运行中，以及集群名称显示。 默认是磁盘节点，如果是内存节点的话，需要加 --ram 参数RabbitMQ 集群节点有 disc 和 ram 两种类型，一个集群中至少要有一个 disc 类型的节点，不指定默认加入为 disc 12# 将集群类型修改成 disk 节点rabbitmqctl change_cluster_node_type disc]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ集群配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础学习]]></title>
    <url>%2F2018%2F07%2F25%2FHTML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[HTML基础学习Web运行本质 对于所有的 Web 应用，本质上其实就是一个 socket 服务端，用户的浏览器其实就是一个 socket 客户端 12345678910111213141516171819import socketdef handle_request(client): buf = client.recv(1024) client.send(bytes("HTTP/1.1 200 OK\r\n\r\n", encoding='utf-8')) client.send(bytes("Hello, World", encoding='utf-8')) def main(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind(('localhost', 8000)) sock.listen(5) while True: connection, address = sock.accept() handle_request(connection) connection.close()if __name__ == '__main__': main() HTML 相关概念html是什么 超文本标记语言（Hypertext Markup Language，HTML）通过标记符号来标记要显示的网页中的内容。 其实就是一套规则，浏览器认识的规则。 浏览器按顺序渲染网页文件，然后根据标记符解释和显示内容。 对于不同的浏览器，对同一标签可能会有不完全相同的解释（兼容性）。 w3c（了解） w3c是什么？ 万维网联盟（World Wide Web Consortium，简称W3C）创建于1994年，是Web技术领域具权威和影响力的国际标准化组织 w3c的主要工作？ W3C主要工作，是制作Web规范。到目前为止，W3C已发布了200多项影响深远的Web技术标准。比如：XHTML、HTML5、XML、CSS、DOM、XSTL等 HTML 文件结构以及标签格式html 的文件格式12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文件体 &lt;/body&gt;&lt;/html&gt; 上述代码说明 &lt;html&gt;&lt;/html&gt;是文档的开始标记和结束标记。此元素告诉浏览器其自身是一个 HTML 文档，在它们之间是文档的头部和主体 &lt;head&gt;&lt;/head&gt;元素出现在文档的开头部分。&lt;head&gt;与&lt;/head&gt;之间的内容不会在浏览器的文档窗口显示，但是其中的元素有特殊重要的意义 &lt;title&gt;&lt;/title&gt;定义网页标题，在浏览器标题栏显示 &lt;body&gt;&lt;/body&gt;之间的文本是可见的网页主体内容 html 标签格式 HTML标签是由尖括号包围的关键词，比如 &lt;html&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 HTML标签通常是成对出现的（双边标记），比如 &lt;div&gt; 和 &lt;/div&gt; 但也有单独呈现的标签（单边标记），如：&lt;br /&gt;、&lt;hr /&gt;和&lt;img src=“images/1.jpg” /&gt;等 标签可以有若干个属性，也可以不带属性。如&lt;head&gt;元素就不带任何属性 123标答的语法：&lt;标签名 属性1=“属性值1” 属性2=“属性值2”...&gt;内容部分&lt;/标签名&gt;&lt;标签名 属性1=“属性值1” 属性2=“属性值2”.../&gt; HTML 常用标签之MetaMeta介绍 &lt;meta&gt;元素可提供有关页面的元信息（meta-information），针对搜索引擎和更新频度的描述和关键词 &lt;meta&gt;标签位于文档的头部，不包含任何内容 &lt;meta&gt;提供的信息是用户不可见的 关于meta常见的用法 author（作者） 说明：标注网页的作者用法：&lt;meta name=&quot;author&quot; content=&quot;张三&quot;&gt; Copyright(版权信息) 功能：说明网站版权信息用法：&lt;meta name=&quot;copyright&quot; content=&quot;信息参数&quot;&gt; 简单示例 HTML 常用标签之字体以及排版标签排版元素（常用） 标签 作用 &lt;p&gt;&lt;/p&gt; 用来创建一个段落，该元素自动在其前后创建一些空白 &lt;br/&gt; 换行 &lt;hr/&gt; 华丽的分割线 &lt;h1&gt;&lt;/h1&gt;...&lt;h6&gt;&lt;/h6&gt; 6种标题效果标签。分别为h1~h6。&lt;h1&gt;字体最大，&lt;h6&gt;字体最小 marquee标签（跑马灯的实现）HTML常用标签之列表无序列表1234&lt;ul&gt; &lt;li&gt;内容&lt;/li&gt; &lt;li&gt;内容&lt;/li&gt;&lt;/ul&gt; 常用属性解释 type属性：disc（实心圆点）（默认）、circle（空心圆圈）、square（实心方块） 有序列表1234&lt;ol&gt; &lt;li&gt;内容&lt;/li&gt; &lt;li&gt;内容&lt;/li&gt;&lt;/ol&gt; 常用属性解释 属性：type编号类型，默认为整数。可选（1、A、a、Ⅰ、i）属性：start起始编号，默认为1，即由最小编号开始 HTML常用标签之a标签语法 &lt;a 属性=&quot;属性值&quot;&gt;标签内容&lt;/a&gt; 常见的属性 href – 指定目标网页的地址，该地址可以有如下类型： 链接远程目标：通过URL地址链接到远程目标。 链接本地页面：可以通过相对路径或者绝对路径链接本地页面。 相对路径：指相对于当前页面位置的路径./：表示当前页面所在的目录../：表示当前页面所在的上一级目录 绝对路径：绝对路径指当前站点中确切的路径，一般以”/”开始 例如：&lt;a href=&quot;/admin/index.py&quot;&gt;后台首页&lt;/a&gt; target _blank 表示在 新窗口 中打开目标网页_self 表示在 当前窗口 中打开目标网页 常见例子 链接到远程地址 12&lt;a href="http://www.sina.com.cn"&gt;新浪网&lt;/a&gt;&lt;a href="http://www.qq.com"&gt;腾讯网&lt;/a&gt; 链接到本地文件 12相对路径：&lt;a href="include/login.html"&gt;登录页面&lt;/a&gt;绝对路径：&lt;a href="/html/123.html"&gt;国内新闻&lt;/a&gt; 链接到邮箱 1&lt;a href="mailto:976296751@qq.com"&gt;给我发邮件&lt;/a&gt; 下载文件 12&lt;a href="/download/winRAR.rar"&gt;下载WinRAR&lt;/a&gt;&lt;a href="download/office2007.rar"&gt;下载office2007&lt;/a&gt; HTML常用标签之div和span元素块级元素 &lt;div&gt;&lt;/div&gt;&lt;div&gt;只是一个块级元素，并无实际的意义. 主要通过CSS为其赋予不同的表现 行内元素 &lt;span&gt;&lt;/span&gt;&lt;span&gt;内联行(行内元素),并无实际的意义. 主要通过CSS为其赋予不同的表现 块级元素与行内元素的区别 所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行如果单独在网页中插入这两个元素，不会对页面产生任何的影响这两个元素是专门为定义CSS样式而生的 HTML常用标签之img标签常见的用法1&lt;img src="URL" alt="图片说明"/&gt; 常见的属性用法说明 属性 值 含义 src 图像URL 规定图像的URL alt 字符串 规定图像的替代文本 width px / % 规定图像的宽 height px / % 规定图像的高 border px 图像的边框粗细 HTML常用标签之table标签html表格的基本结构12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容&lt;/td&gt; &lt;td&gt;内容&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 解释说明 &lt;table&gt;&lt;/table&gt;表示的表格的开始和结束 &lt;tr&gt;&lt;/tr&gt;表示的是表格的一行 &lt;td&gt;&lt;/td&gt;表示的是一个单元数据格 &lt;th&gt;&lt;/th&gt;表示表格标题单元格，且加粗居中显示 table的常用属性 属性 值 含义 width px或% 表格的宽度 height px或% 表格的高度 border px 表格的边框的粗细 align Left/center/right 元素的对齐方式 简单的案例实现 HTML常用标签之form表单元素标签FORM表单的基本概念 基本概念 HTML表单是HTML元素中较为复杂的部分，表单往往和脚本、动态页面、数据处理等功能相结合，因此它是制作动态网站很重要的内容。表单一般用来收集用户的输入信息 表单的工作原理 访问者在浏览有表单的网页时，可填写必需的信息，然后按某个按钮提交这些信息通过Internet传送到服务器上服务器上专门的程序对这些数据进行处理，如果有错误会返回错误信息，并要求纠正错误 12345678910111213141516import tornado.ioloopimport tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write("Hello, world") def post(self): self.write('this is a test') application = tornado.web.Application([ (r"/index", MainHandler),]) if __name__ == "__main__": application.listen(8888) tornado.ioloop.IOLoop.instance().start() 表单的常见结构 123456&lt;form id="form1" method="post" action=""&gt; 账号：&lt;input type="text" name="account" /&gt;&lt;br /&gt; 密码：&lt;input type="password" name="password" /&gt;&lt;br /&gt; &lt;input type="submit" name="submit" value="提交" /&gt; &lt;input type="reset" name="reset" value="重置" /&gt;&lt;/form&gt; 表单标记属性 属性 值 含义 action url 指定一个表单处理目标URL，表单数据将被提交到该URL地址的处理程序。如果该属性值为空，则提交到文档自身。该属性值可以为绝对地址、相对地址、文档片段，甚至是脚本代码 method get或post 将表单数据提交到http服务器的方法，可能值有两个：get和post enctype application/x-www-form-urlencoded 指定表单数据的编码类型，此属性只有在method属性设置为post时才有效。默认值为application/x-www-form-urlencoded对所有字符进行编码。如果表单包含用于文件上传的控件（input type=“file”），那么这个属性值必须设为multipart/form-data ，不对字符进行编码。 补充：Get和Post提交的区别 Get方式提交 如果为get，那么所提交的数据集将被作为一个由表单的所有名/值对组成的查询字符串（query string）添加到表单处理器的URL（action属性）的末尾比如：http://www.oldboyedu.com/index.py?variable1=content1&amp;variable1=content2这种方法提交的信息在长度上有一定限制，而且不安全，适合简单的数据查询 Post方式提交 如果为post，那么数据集将直接发给表单处理程序，而不是以可见的URL查询字符串的形式。post方法可以提交更长的数据，并且相对安全一些，传送的数据类型更多一些（不限于ASCII字符），因而适用于数据更复杂的表单 常见的 INPUT 标签 type属性值 空间名称 对应代码 text 单行文本输入框 &lt;input type=&quot;text&quot;/&gt; password 密码输入框 &lt;input type=&quot;password&quot;/&gt; checkbox 复选框 &lt;input type=&quot;checkbox&quot; checked=&#39;checked&#39;/&gt; radio 单选框 &lt;input type=&quot;radio&quot;/&gt; submit 提交按钮 &lt;input type=&quot;submit&quot; value=&#39;提交&#39;/&gt; reset 重置按钮 &lt;input type=&quot;reset&quot; value=&#39;重置&#39;/&gt; button 普通按钮 &lt;input type=&quot;button&quot; value=“普通按钮”/&gt; hidden 隐藏按钮 &lt;input type=&quot;hidden&quot; value=“隐藏按钮”/&gt; file 文本选择框 &lt;input type=&quot;file&quot;/&gt; 需要注意的问题 上传文件控件 当一个中有“上传文件域”，必须指定MIME类型 enctype=”multipart/form-data”&gt;，否则无法上传文件上传文件域，只在 method=”post” 下才有效 隐藏控件 &lt;input type=&quot;hidden&quot; name=&quot;nid&quot; value=&quot;234&quot; /&gt;隐藏字段对于用户是不可见的隐藏字段通常会存储一个默认值一般用在，修改某条数据时，用来记录数据的id号 普通按钮 &lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;普通按钮&quot; /&gt;定义可点击的按钮，但没有任何行为，一般配合JS使用 各种按钮显示效果 SELECT下拉列表常见的基本结构 123456789&lt;form id="form1" name="form1" method="post" action=""&gt; &lt;select name="city" id="city"&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海" selected="selected"&gt;上海&lt;/option&gt; &lt;option value="南京"&gt;南京&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;option value="深圳"&gt;深圳&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 属性说明 multiple：布尔属性，设置后允许多选，否则只能选择一个disabled：禁用该下拉列表selected：首次显示时,为选中状态value：定义发往服务器的选项值 TEXTAREA多行文本框12345&lt;form id="form1" name="form1" method="post" action=""&gt; &lt;textarea cols="宽度" rows="高度" name="名称"&gt; 默认内容 &lt;/textarea&gt;&lt;/form&gt; 属性说明 属性 属性值 说明 name name 控件名称 rows number 设置多行文本框的显示行数（高度） cols number 设置多行文本框的显示列数（宽度） disabled disabled 布尔属性，设置当前文本框为禁用状态 LABEL表单修饰1234&lt;form id="form1" name="form1" method="post" action=""&gt; &lt;label for="username"&gt;用户名&lt;/label&gt; &lt;input type="text" name="username" id="username" /&gt;&lt;/form&gt; 说明 label 元素不会向用户呈现任何特殊效果&lt;label&gt; 标签的 for 属性应当与相关元素的 id 属性相同结合CSS可以控制表单文本或控件对齐，美化表单 案例 参考文档http://www.shangzekai.xyz/2017/05/07/html基础目录/]]></content>
      <categories>
        <category>HTML笔记</category>
      </categories>
      <tags>
        <tag>HTML基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ常用命令]]></title>
    <url>%2F2018%2F07%2F24%2FRabbitMQ%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[RabbitMQ常用命令 服务启动关闭12345# 启动rabbitmq-server -detached # 关闭rabbitmqctl stop 集群配置相关命令12345678910111213rabbitmqctl stop_app rabbitmqctl reset # 在当前集群中加入某节点rabbitmqctl join_cluster &#123;rabbit_node_name&#125;# 某些低版本可以采用 rabbitmqctl cluster &#123;rabbit_node_name&#125;rabbitmqctl start_app # 集群状态rabbitmqctl cluster_status# 将某节点剔除出当前集群rabbitmqctl forget_cluster_node &#123;rabbit_node_name&#125; 插件管理123456789101112# 开启某个插件rabbitmq-plugins enable &#123;插件名&#125;# 关闭某个插件rabbitmq-plugins disable &#123;插件名&#125;# 有关插件名可以在 rabbitmq 的安装目录下的 plugins 目录中查看$RABBITMQ_HOME/plugins# 举例rabbitmq-plugins enable rabbitmq_management rabbitmq-plugins list 用户管理1234567891011121314151617# 添加用户rabbitmqctl add_user &#123;username&#125; &#123;password&#125;# 删除用户rabbitmqctl delete_user &#123;username&#125;# 修改密码rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;# 设置用户角色rabbitmqctl set_user_tags &#123;username&#125; &#123;tag&#125;tag 可以为 administrator, monitoring, management# 举例rabbitmqctl add_user root rootrabbitmqctl set_user_tags root administratorrabbitmqctl list_users 权限管理123456789101112131415161718# 权限设置rabbitmqctl set_permissions [-p vhostpath] &#123;user&#125; &#123;conf&#125; &#123;write&#125; &#123;read&#125;conf # 一个正则表达式match哪些配置资源能够被该用户访问write # 一个正则表达式match哪些配置资源能够被该用户读read # 一个正则表达式match哪些配置资源能够被该用户访问# 查看（指定vhost）所有用户的权限信息rabbitmqctl list_permissions [-p vhostPath]# 查看指定用户的权限信息rabbitmqctl list_user_permissions &#123;username&#125;# 清除用户的权限信息rabbitmqctl clear_permissions [-p vhostPath] &#123;username&#125;# 举例rabbitmqctl set_permissions -p / root "." "." ".*" 获取服务器状态信息1234567891011121314151617181920212223242526272829303132333435# 服务器状态rabbitmqctl status# 队列信息rabbitmqctl list_queues -p vhostpath# queueinfoitem可以为name, durable, auto_delete, arguments, messages_ready, messages_unacknowled, messages, consumers, memory.# Exchange信息rabbitmqctl list_exchanges -p vhostpath# exchangeinfoitem有name, type, durable, auto_delete, internal, arguments.# Binding信息rabbitmqctl list_bindings -p vhostpath# bindinginfoitem有source_name, source_kind, destination_name, destination_kind, routing_key, arguments.等# connection信息rabbitmqctl list_connections [connectioninfoitem ...]# connectioninfoitem有recv_oct，recv_cnt，send_oct，send_cnt，send_pend 等。# channel信息rabbitmqctl list_channels [channelinfoitem ...]# channelinfoitem有consumer_count，messages_unacknowledged，messages_uncommitted，acks_uncommitted，messages_unconfirmed，prefetch_count，client_flow_blocked# 举例rabbitmqctl list_queues name messages_ready pid slave_pids 更改节点类型12345rabbitmqctl stop_apprabbitmqctl change_cluster_node_type disc或rabbitmqctl change_cluster_node_type ramrabbitmqctl start_app vhost管理12345# 添加vhostrabbitmqctl add vhost &#123;name&#125;# 删除vhostrabbitmqctl delete vhost &#123;name&#125; 镜像队列的设置12345678910111213141516镜像队列的配置通过添加 policy 完成，policy 添加的命令为rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority] -p Vhost: # 可选参数，针对指定 vhost 下的 queue 进行设置Name: # policy 的名称Pattern: # queue 的匹配模式（正则表达式）Definition: # 镜像定义，包括三个部分 ha-mode，ha-params，ha-sync-mode ha-mode: # 指明镜像队列的模式，有效值为 all/exactly/nodes all # 表示在集群所有的节点上进行镜像 exactly # 表示在指定个数的节点上进行镜像，节点的个数由 ha-params 指定 nodes # 表示在指定的节点上进行镜像，节点名称通过 ha-params 指定 ha-params: # ha-mode模式需要用到的参数 ha-sync-mode: # 镜像队列中消息的同步方式，有效值为 automatic，manually # 有效值为 automatic（自动同步），manually（手动同步），默认是 manually # 请注意一定要记得设置为 automatic（自动同步），否则消息在镜像队列中是不会自动同步的（即普通集群模式），只能通过命令手动去同步Priority: # 可选参数，policy 的优先级 示例1234567# 对队列名称以 hello 开头的所有队列进行镜像，并在集群的两个节点上完成镜像# policy 的设置命令为rabbitmqctl set_policy hello-ha "^hello" '&#123;"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"&#125;'# 对队列名称以 “queue_” 开头的所有队列进行镜像，并在集群的两个节点上完成进行# policy 的设置命令为rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue "^queue_" '&#123;"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"&#125;' policy 相关解释12345Name： # policy 策略的唯一名称Pattern： # 用于匹配 exchange 和 queue 等名称的正则表达式Apply to： # 指定将此 policy 应用到哪些项上（例如：exchange，queue等）Priority： # 可选参数，policy 的优先级，exchange 和 queue 名称可以匹配到多个 policy，优先级则定义了 policy 被执行的顺序Definition：# 参数定义 消息的同步 将新节点加入已存在的镜像队列是，默认情况下 ha-sync-mode=manual，镜像队列中的消息不会主动同步到新节点，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行操作，直到同步完毕。当 ha-sync-mode=automatic 时，新加入节点时会默认同步已知的镜像队列。由于同步过程的限制，所以不建议在生产的 active 队列（有生产消费消息）中操作。 12345678910# 可以使用下面的命令来查看那些 slaves 已经完成同步rabbitmqctl list_queues name slave_pids synchronised_slave_pids# 可以通过手动的方式同步一个 queuerabbitmqctl sync_queue name# 同样也可以取消某个 queue 的同步功能rabbitmqctl cancel_sync_queue name# 当然这些都可以通过 management 插件来设置 参考文档https://blog.csdn.net/u013256816/article/details/53524814]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ用户管理]]></title>
    <url>%2F2018%2F07%2F24%2FRabbitMQ%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 用户管理 创建用户 在 RabbitMQ 中，用户是访问控制（Access Control）的基本单元，且单个用户可以跨越多个vhost 进行授权。针对一至多个 vhost，用户可以被赋予不同级别的访问权限，并使用标准的用户名和密码来认证用户。创建用户的命令为：rabbitmqctl add_user {username} {password}。其中username 表示要创建的用户名称。password 表示创建用户登录的密码。具体创建一个用户名为 root、密码为 root123 的用户 12[root@node1 ~]# rabbitmqctl add_user root root@123Creating user "root" 修改密码可以通过rabbitmqctl change_password {username} {newpassword}命令来更改指定用户的密码其中username 表示要变更密码的用户名称newpassword 表示要变更的新的密码 举例：将 root用户的密码变更为 root32112[root@node1 ~]# rabbitmqctl change_password root root@321Changing password for user "root" 清除密码同样可以清除密码，这样用户就不能使用密码登录了对于的操作命令为：rabbitmqctl clear_password {username}其中username 表示要清楚密码的用户名称 验证用户使用rabbitmqctl authenticate_user {username} {password}可以通过密码来验证用户其中username 表示需要被验证的用户名称password 表示密码 下面示例中分别采用 root321 和 root322 来验证 root 用户1234567[root@node1 ~]# rabbitmqctl authenticate_user root root@321Authenticating user "root"Success[root@node1 ~]# rabbitmqctl authenticate_user root root@322Authenticating user "root"Error: failed to authenticate user "root" 删除用户删除用户的命令是rabbitmqctl delete_user {username}其中username 表示要删除的用户名称 删除用户 root 的示例如下12[root@node1 ~]# rabbitmqctl delete_user rootDeleting user "root" 查询用户列表rabbitmqctl list_users 命令可以用来罗列当前的所有用户每个结果行都包含用户名称，其后紧跟用户的角色（tags） 示例代码如下：1234[root@node1 ~]# rabbitmqctl list_usersListing usersguest [administrator]root [] 用户的角色分为 5 种类型none：无任何角色。新创建的用户的角色默认为 none。management：可以访问 Web 管理页面。policymaker：包含 management 的所有权限，并且可以管理策略（policy）和参数（parameter）。monitoring：包含 management 的所有权限，并且可以看到所有连接（connections）、信道（channels）以及节点相关的信息。administartor：包含 monitoring 的所有权限，并且可以管理用户、虚拟主机、权限、策略、参数等等。administator 代表了最高的权限。 设置用户角色用户的角色可以通过rabbitmqctl set_user_tags {username} {tag...}命令设置。其中username 参数表示需要设置角色的用户名称。tag 参数用于设置 0 个、1 个 或者 多 个的角色，设置之后任何之前现有的身份都会被删除。 使用示例如下：12345678910111213141516171819202122[root@node1 ~]# rabbitmqctl set_user_tags root monitoringSetting tags for user "root" to [monitoring][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [monitoring][root@node1 ~]# rabbitmqctl set_user_tags root policymaker -q[root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [policymaker][root@node1 ~]# rabbitmqctl set_user_tags rootSetting tags for user "root" to [][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [][root@node1 ~]# rabbitmqctl set_user_tags root policymaker,managementSetting tags for user "root" to ['policymaker,management'][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [policymaker,management] 参考文档https://blog.csdn.net/u013256816/article/details/78181306]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ用户管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ集群管理]]></title>
    <url>%2F2018%2F07%2F24%2FRabbitMQ%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 集群管理 rabbitmqctl join_cluster {cluster_node} [–ram] 将节点加入指定集群中。在这个命令执行前需要停止 RabbitMQ 应用并重置节点。 rabbitmqctl cluster_status 显示集群的状态 rabbitmqctl change_cluster_node_type {disc|ram} 修改集群节点的类型。在这个命令执行前需要停止 RabbitMQ 应用 rabbitmqctl forget_cluster_node [–offline] 将节点从集群中删除，允许离线执行 rabbitmqctl update_cluster_nodes {clusternode} 在集群中的节点应用启动前咨询 clusternode 节点的最新信息，并更新相应的集群信息。这个和 join_cluster 不同，它不加入集群。考虑这样一种情况，节点A 和 节点B 都在集群中，当节点A离线了，节点C 又和 节点B 组成了一个集群，然后 节点B 又离开了集群，当 A 醒来的时候，它会尝试联系 节点B，但是这样会失败，因为节点B已经不在集群中了。rabbitmqctl update_cluster_nodes -n A C 可以解决这种场景。 示例如下：12345678910111213141516171819202122232425262728293031323334353637383940# 假设已有 node1 和 node2 组成的集群# 1. 初始状态[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;]# 2. 关闭 node1 节点的应用[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1# 3. 之后将 node3 加入到集群中（rabbitmqctl join_cluster rabbit@node2）# 4. 再将 node2 节点的应用关闭# 5. 最后启动 node1 节点的应用，此时会报错[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1BOOT FAILED===========Timeout contacting cluster nodes: [rabbit@node2].....(省略)# 6. 如果在启动 node1 节点的应用之前咨询 node3 并更新相关集群信息则可以解决这个问题[root@node1 ~]# rabbitmqctl update_cluster_nodes rabbit@node3Updating cluster nodes for rabbit@node1 from rabbit@node3[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1# 7. 最终集群状态[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node3]&#125;]&#125;, &#123;running_nodes,[rabbit@node3,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node3,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;] rabbitmqctl force_boot确保节点可以启动，即使它不是最后一个关闭的节点。通常情况下，当关闭整个 RabbitMQ 集群时，重启的第一个节点应该是最后关闭的节点，因为它可以看到其它节点所看不到的事情。但是有时会有一些异常情况出现，比如整个集群都掉电而所有节点都认为它不是最后一个关闭的。在这种情况下，可以调用 rabbitmqctl force_boot 命令，这就告诉节点可以无条件的启动节点。在此节点关闭后，集群的任何变化，它都会丢失。如果最后一个关闭的节点永久丢失了，那么你需要优先使用 rabbitmqctl forget_cluster_node –offline 命令，因为它可以确保镜像队列的正常运转。 示例如下：123[root@node2 ~]# rabbitmqctl force_bootForcing boot for Mnesia dir /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node2[root@node2 ~]# rabbitmq-server –detached rabbitmqctl sync_queue [-p vhost] {queue} 指示未同步队列 queue 的 slave 镜像可以同步 master 镜像行的内容。同步期间此队列会被阻塞（所有此队列的生产消费者都会被阻塞），直到同步完成。此条命令执行成功的前提是队列queue 配置了镜像。注意，未同步队列中的消息被耗尽后，最终也会变成同步，此命令主要用于未耗尽的队列。 示例如下：12[root@node1 ~]# rabbitmqctl sync_queue queueSynchronising queue 'queue' in vhost '/' rabbitmqctl cancel_sync_queue [-p vhost] {queue} 取消队列 queue 同步镜像的操作。 示例如下：12[root@node1 ~]# rabbitmqctl cancel_sync_queue queueStopping synchronising queue 'queue' in vhost '/' rabbitmqctl set_cluster_name {name} 设置集群名称。集群名称在客户端连接时会通报给客户端。Federation 和 Shovel 插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。 示例如下：12345678910111213141516[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;][root@node1 ~]# rabbitmqctl set_cluster_name cluster_hiddenSetting cluster name to cluster_hidden[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"cluster_hidden"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;] 参考文档https://blog.csdn.net/u013256816/article/details/78348761]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ集群管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ应用管理]]></title>
    <url>%2F2018%2F07%2F24%2FRabbitMQ%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 应用管理本文主要阐述应用与集群相关的一些操作管理命令，包括关闭、重置、开启服务，还有建立集群的一些信息。 rabbitmqctl stop [pid_file] 用于停止运行 RabbitMQ 的 Erlang 虚拟机和 RabbitMQ 服务应用。如果指定了 pid_file，还需要等待指定进程的结束。其中 pid_file 是通过调用 rabbitmq-server 启动 RabbitMQ 服务时创建的，默认情况下存放于 Mnesia 目录中，可以通过 RABBITMQ_PID_FILE 这个环境变量来改变存放路径。注意，如果是 rabbitmq-server –detach 启动的 RabbitMQ 服务则不会生成 pid_file 这个文件。 示例如下：123456[root@node1 ~]# rabbitmqctl stop/data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidStopping and halting node rabbit@node1[root@node1 ~]# rabbitmqctl stopStopping and halting node rabbit@node1 rabbitmqctl shutdown 用于停止运行 RabbitMQ 的 Erlang 虚拟机 和 RabbitMQ 服务应用。执行这个命令会阻塞直到 Erlang 虚拟机进程的退出。如果 RabbitMQ 没有成功关闭，则会返回一个非零值。这个命令和 rabbitmqctl stop 的不同的是，它不需要指定 pid_file 而可以阻塞等待指定进程的关闭。 示例如下：1234[root@node1 ~]# rabbitmqctl shutdownShutting down RabbitMQ node rabbit@node1 running at PID 1706Waiting for PID 1706 to terminateRabbitMQ node rabbit@node1 running at PID 1706 successfully shut down rabbitmqctl stop_app 停止 RabbitMQ 服务应用，但是 Erlang 虚拟机还是处于运行状态。此命令优先执行其他管理操作（这些管理操作需要先停止 RabbitMQ 应用），比如 rabbitmqctl reset。 示例如下：12[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1 rabbitmqctl start_app 启动 RabbitMQ 应用。此命令典型的用途是在执行了其他管理操作之后，重新启动之前停止的 RabbitMQ 应用，譬如rabbitmqctl reset。 示例如下：12[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1 rabbitmqctl wait [pid_file] 等待 RabbitMQ 应用的启动。它会等到 pid_file 的创建，然后等待 pid_file 中的所代表的进程启动。当指定的进程没有启动 RabbitMQ 应用而关闭时将会返回失败。 示例如下：12345678[root@node1 ~]# rabbitmqctl wait /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidWaiting for rabbit@node1pid is 3468[root@node1 ~]# rabbitmqctl wait /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidWaiting for rabbit@node1pid is 3468Error: process_not_running rabbitmqctl reset 将 RabbitMQ 节点重置还原到最初状态，包括从原所在的集群中删除此节点，从管理数据库中删除所有的配置数据，如已配置的用户、vhost等，以及删除所有的持久化消息。执行 rabbitmqctl reset 命令前必须停止 RabbitMQ 应用（比如先执行 rabbitmqctl stop_app）。 示例如下：12345[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1[root@node1 ~]# rabbitmqctl resetResetting node rabbit@node1 rabbitmqctl force_reset 强制将 RabbitMQ 节点重置还原到最初状态。不同于 rabbitmqctl reset，rabbitmqctl force_reset 命令不论当前管理数据库的状态和集群配置是什么，会无条件地重置节点。它只能在数据库或集群配置已损坏的情况下才可使用。与 rabbitmqctl reset 命令一下，执行 rabbitmqctl force_reset 命令前必须先停止RabbitMQ 应用。 示例如下：12345[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1[root@node1 ~]# rabbitmqctl force_resetForcefully resetting node rabbit@node1 rabbitmqctl rotate_logs {suffix} 指示 RabbitMQ 节点轮换日志文件。RabbitMQ 节点会将原来的日志文件中的内容追加到 “原始名称+后缀”的日志文件中，然后再将新的日志内容记录到新创建的日志中（与原日志文件同名）。当目标文件不存在时，将会重新创建。如果不指定 suffix，那么则日志文件只是重新打开而不会进行轮换。 示例如下所示原日志文件为 `rabbit@node1.log和rabbit@node1-sasl.log，轮换日志之后，原日志文件中的内容就被追加到rabbit@node1.log.1和rabbit@node1-sasl.log.1日志中，之后重新建立rabbit@node1.log和rabbit@node1-sasl.log` 文件用来接收新的日志。1234567891011121314[root@node1 rabbitmq]# pwd/data/app/rabbitmq/var/log/rabbitmq[root@node1 rabbitmq]# ll-rw-r--r-- 1 root root 1024127 Aug 18 11:56 rabbit@node1.log-rw-r--r-- 1 root root 720553 Aug 17 19:16 rabbit@node1-sasl.log[root@node1 rabbitmq]# rabbitmqctl rotate_logs .1Rotating logs to files with suffix ".1"[root@node1 rabbitmq]# ll-rw-r--r-- 1 root root 0 Aug 18 12:05 rabbit@node1.log-rw-r--r-- 1 root root 1024202 Aug 18 12:05 rabbit@node1.log.1-rw-r--r-- 1 root root 0 Aug 18 12:05 rabbit@node1-sasl.log-rw-r--r-- 1 root root 720553 Aug 18 12:05 rabbit@node1-sasl.log.1 rabbitmqctl hipe_compile {directory} 将部分 RabbitMQ 代码用 HiPE（HiPE是指High Performance Erlang ，是Erlang版的JIT）编译，并且将编译后的 .beam 文件（beam 文件是 Erlang 编译器生成的文件格式，可以直接加载到 Erlang 虚拟机中运行的文件格式）保存到指定的文件目录中。如果这个目录不存在则会自行创建。如果这个目录中原本有任何 .beam 文件，则会在执行编译前被删除。如果要使用预编译的这些文件，需要设置 RABBITMQ_SERVER_CODE_PATH 这个环境变量来指定hipe_compile 调用的路径。 示例如下：123456789101112131415161718192021222324[root@node1 rabbitmq]# rabbitmqctl hipe_compile /data/app/rabbitmq/tmp/rabbit-hipe/ebinHiPE compiling: |---------------------------------------------------------| |#########################################################|Compiled 57 modules in 55s[root@node1 rabbitmq]# ls /opt/rabbitmq/tmp/rabbit-hipe/ebinarray.beam proplists.beam rabbit_misc.beamcredit_flow.beam qlc.beam rabbit_msg_file.beamdelegate.beam queue.beam rabbit_msg_store.beamdict.beam rabbit_amqqueue.beam rabbit_msg_store_ets_index.beamfile_handle_cache.beam rabbit_amqqueue_process.beam rabbit_net.beamgb_sets.beam rabbit_basic.beam rabbit_queue_index.beamgb_trees.beam rabbit_binary_generator.beam rabbit_reader.beamgen.beam rabbit_binary_parser.beam rabbit_router.beamgen_fsm.beam rabbit_channel.beam rabbit_trace.beamgen_server2.beam rabbit_command_assembler.beam rabbit_variable_queue.beamlists.beam rabbit_event.beam rabbit_writer.beamlqueue.beam rabbit_exchange.beam rpc.beammnesia.beam rabbit_exchange_decorator.beam sets.beammnesia_lib.beam rabbit_exchange_type_direct.beam sofs.beammnesia_tm.beam rabbit_exchange_type_fanout.beam ssl.beamorddict.beam rabbit_exchange_type_topic.beam ssl_connection.beamordsets.beam rabbit_framing_amqp_0_9_1.beam ssl_record.beampmon.beam rabbit_guid.beam tls_connection.beampriority_queue.beam rabbit_limiter.beam tls_record.beam 参考文档https://blog.csdn.net/u013256816/article/details/78221439]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ应用管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx修改隐藏版本号]]></title>
    <url>%2F2018%2F07%2F17%2FNginx%E4%BF%AE%E6%94%B9%E9%9A%90%E8%97%8F%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Nginx修改隐藏版本号Nginx 配置文件 配置文件里增加 server_tokens off;server_tokens 作用域是 http server location 语句块server_tokens 默认值是 on，表示显示版本信息，设置 server_tokens 值是 off，就可以在所有地方隐藏 nginx 的版本信息 隐藏 Nginx 版本号 在 /data/app/nginx/conf/nginx.conf 里 123456vim /data/app/nginx/conf/nginx.confhost &#123;...省略... server_tokens off;...省略...&#125; 这样修改之后能隐藏掉 nginx 的版本号，但是还是可以显示 Web 软件为 nginx 修改 Nginx 源码版本信息1curl -I "http://127.0.0.1 | grep Server" Nginx 编译前修改版本及版本号1234567891011121314151617181920212223cd /data/tools/cd nginx-1.15.1/vim ./src/core/nginx.h... 省略 ...#define nginx_version 1008001#define NGINX_VERSION "" # 修改想要显示的版本#define NGINX_VER "FastDFS" NGINX_VERSION # 将 nginx 修改成想要显示的软件名称... 省略 ...#define NGINX_VAR "FastDFS" # 将 nginx 修改成想要显示的软件名称(Evan Web Server)#define NGX_OLDPID_EXT ".oldbin"vim ./src/http/ngx_http_header_filter_module.c// static u_char ngx_http_server_string[] = "Server: nginx" CRLF;static u_char ngx_http_server_string[] = "Server: FastDFS" CRLF; # 将 nginx 修改为想要的版本static u_char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;static u_char ngx_http_server_build_string[] = "Server: " NGINX_VER_BUILD CRLF;vim ./src/http/ngx_http_special_response.cstatic u_char ngx_http_error_tail[] =// "&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;" CRLF"&lt;hr&gt;&lt;center&gt;FastDFS&lt;/center&gt;" CRLF # 将 nginx 修改为想要的版本信息"&lt;/body&gt;" CRLF"&lt;/html&gt;" CRLF 修改 fastcgi123456789101112cd /data/tools/nginx-1.15.1/vim ./conf/fastcgi_params找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;修改为fastcgi_param SERVER_SOFTWARE FastDFS/$nginx_version;vim ./conf/fastcgi.conf找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;修改为fastcgi_param SERVER_SOFTWARE FastDFS/$nginx_version; 修改探针中显示的 Web 服务软件信息，在编译前，fastcgi 编译后修改都可以 注意： 当添加 server_tokens off; 参数的时候，调用的是 src/http/ngx_http_header_filter_module.c 里的值不添加的时候，显示版本号调用的是 src/core/nginx.h 里的值所以我们修改的时候需要两个地方都修改。]]></content>
      <categories>
        <category>Nginx笔记</category>
      </categories>
      <tags>
        <tag>Nginx修改隐藏版本号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件处理]]></title>
    <url>%2F2018%2F07%2F11%2FPython-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件处理 应用程序中需要经常将内存的数据永久保存下来，而应用程序又无法直接操作硬件只能通过操作系统提供的虚拟单位去间接地操作硬盘 打开文件 open(&#39;文件的路径&#39;, mode=&#39;打开文件的模式&#39;, encoding=&#39;操作文件的字符编码&#39;)r 表示 原始字符串，不转义任何特殊字符 向操作系统发送打开文件的请求 向操作系统发送打开文件的请求 1open(r'/tmp/a.txt') open 有返回值12345f = open(r'/tmp/a.txt', mode='r')print(f)# 输出结果&lt;_io.TextIOWrapper name='/tmp/a.txt' mode='r' encoding='UTF-8'&gt; f =&gt; 应用程序中的一个值 =&gt; 操作系统打开的文件 a.txt =&gt; 硬盘中的一块空间 读/写123456789101112# 应用程序向操作系统发送请求，打开文件f.read() # 把文件内容全都读到内存里去f = open(r'a.txt', mode='r')data = f.read()print(data)# 输出结果UnicodeDecodeError: 'gbk' codec can't decode byte 0x8a in position 8: illegal multibyte sequenc# 注意 不同 操作系统平台 字符编码问题# Windows gbk# Linux utf-8 12345678f = open(r'a.txt', mode='r', encoding='utf-8') # 指定打开文件的字符编码为 utf-8data = f.read() # 在读取的时候就会以 utf-8 的编码读取print(data)# 输出结果你好啊aaawoca 嘞 关闭文件，释放资源1234567f.close() # 回收操作系统的资源，操作系统会定期回收资源print(f) # f 的资源会自动被 Python 回收掉f.read()# 输出结果ValueError: I/O operation on closed file.# del f # 手动回收 f 资源，不要在 f.close() 之前用这个 总结 文件处理的步骤 打开文件 读/写文件 关闭文件 打开多个文件12f1 = open(r'a1.txt', mode='r')f2 = open(r'a2.txt', mode='r') 操作系统资源 =&gt; 文件描述符应用程序资源 with 上下文管理 帮你打开文件先将操作系统把文件打开然后把打开结果赋值给 f（占用两个资源）123with open(r'a.txt', mode='r', encoding='utf-8') as f: print('==&gt;') # 运行 with 的子代码块 print(f.read()) # 在这里基于 with 打开的文件，做读写操作 with 会帮我们自动 close with 打开多个文件12345with open(r'a.txt', mode='r', encoding='utf-8') as f1,\ open(r'b.txt', mode='r', encoding='utf-8') as f2: print('==&gt;') print(f1.read()) print(f2.read()) 文件的打开模式三种纯净模式 r 只读模式（默认模式，文件必须存在，不存在则抛出异常）w 只写模式（不可读，不存在则创建；存在则清空内容）a 只追加写模式（不可读，不存在则创建；存在则追加内容） 控制操作文件内容的模式两种模式 不能单独使用，必须与 r，w，a 连用t（默认）：text文本模式，该模式操作文件内容的单位都是字符串，该模式只适用于文本文件注意： 该模式下必须指定 encoding=&quot;字符编码&quot;b：bytes 二进制模式，该模式下操作文件的内容单位都是bytes，该模式适用于所有类型文件 r 模式，只读模式 默认单位：t，可以不指定默认文件的打开模式是 rt 模式文件必须存在，不存在则报错文件存在则打开文件，并且将文件指针跳到文件的开头 read() 方法 读取所有内容，光标移动到文件末尾把文件内容一次性全都读出，读成 str字符串 数据类型 123456with open('a.txt', mode='rt', encoding='utf-8') as f: data = f.read() print(type(data))# 输出结果&lt;class 'str'&gt; 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: data = f.read() print(data)# 输出结果你好啊aaawoca 了 1234567891011with open('a.txt', mode='rt', encoding='utf-8') as f: data1 = f.read() print('第一次', data1) data2 = f.read() print('第二次', data2)# 输出结果第一次 你好啊aaawoca 了第二次 readable() 判断文件是否可读12345with open('a.txt', mode='rt', encoding='utf-8') as f: print(f.readable())# 输出结果True writable() 判断文件是否可写 r 读模式，不能写，只能读 12345678910with open('a.txt', mode='rt', encoding='utf-8') as f: print(f.writable())# 输出结果Falsewith open('a.txt', mode='rt', encoding='utf-8') as f: f.write('hello')# 输出结果io.UnsupportedOperation: not writable 1234f.closed # 文件是否关闭f.encoding # 如果文件打开模式为b，则没有该属性f.flush() # 立刻将文件内容从内存刷到硬盘f.name readline() 方法 一次读一行读取一行内容，光标移动到第二行首部 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: line = f.readline() print(line, end='') # end='' 取消 print() 自带的换行 print('====&gt;')# 输出结果你好啊====&gt; 1234567891011with open('a.txt', mode='rt', encoding='utf-8') as f: line1 = f.readline() print(line1, end='') # end='' 取消 print() 自带的换行 print('====&gt;') line2 = f.readline() print(line2, end='')# 输出结果你好啊====&gt;aaa readlines() 方法 读取每一行内容，存放于列表中把文件内容一次性全都读出，读成 list列表 数据类型，和 read() 类似 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: l = f.readlines() print(type(l)) print(l)# 输出结果&lt;class 'list'&gt;['你好啊\n', 'aaa\n', 'woca 了'] w 模式，只写模式 只写模式文件存在，会将文件内容情空，并且将文件指针跳到文件的开头文件不存在，则创建一个空文件，并且将文件指针跳到文件的开头 12with open('b.txt', mode='wt', encoding='utf-8') as f: pass 1234567891011with open('b.txt', mode='wt', encoding='utf-8') as f: print(f.readable()) print(f.writable())# 输出结果FalseTruewith open('a.txt', mode='wt', encoding='utf-8') as f: f.readline()# 输出结果io.UnsupportedOperation: not readable write() 方法 针对文本模式的写，需要自己写换行符 12f.write('1111\n2222\n')f.write('1111\n2222\n'.encode('utf-8')) 12345with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊')# 打开文件 b.txt你好啊 123456with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊') f.write('我的天')# 打开文件 b.txt你好啊我的天 1234567with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊\n') f.write('我的天')# 打开文件 b.txt你好啊我的天 注意：如果每次都是重新打开文件，那么文件内容总会清空，指针永远跳到开头如果在打开文件不关闭的情况下，连续的写入，本次写入会基于上一次指针所在的位置往后继续写 writelines() 方法 文件模式12f.writelines(['333\n','444\n'])f.writelines([bytes('333\n', encoding='utf-8'), '444\n'.encode('utf-8')]) 1234567891011121314151617with open('b.txt', mode='wt', encoding='utf-8') as f: l = ['1111\n', '2222\n', '3333\n'] f.writelines(l)# 打开文件 b.txt111122223333# 相当于with open('b.txt', mode='wt', encoding='utf-8') as f: l = ['1111\n', '2222\n', '3333\n'] for line in l: f.write(line)# 打开文件 b.txt111122223333 1234567with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('1111\n\2222\n3333\n')# 打开文件 b.txt111122223333 换行符 \n Unix/Linux平台\r 老 Mac OS\n 新 Mac OS X\r\n Windows平台 查看换行符12345with open('b.txt', mode='rb') as f: print(f.read())# 输出结果b'1111\r\n2222\r\n3333\r\n' 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: l = f.readlines() print(l) print(type(l))# 输出结果['1111\n', '2222\n', '3333']&lt;class 'list'&gt; write() 将内容一次性写入文件中 12345with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('hello')# 打开文件 b.txthello writelines() 将内容循环写入文件中 12345678910with open('b.txt', mode='wt', encoding='utf-8') as f: f.writelines('hello')# 相当于with open('b.txt', mode='wt', encoding='utf-8') as f: for i in 'hello': f.write(i)# 打开文件 b.txthello a 模式，只追加写模式 文件不存在，则创建一个空文件，并且将文件指针跳到文件的末尾文件存在，则会将文件指针跳到文件的末尾 12with open('a.txt', mode='at', encoding='utf-8') as f: pass 12345with open('a.txt', mode='at', encoding='utf-8') as f: print(f.writable())# 输出结果True 1234567with open('a.txt', mode='at', encoding='utf-8') as f: print(f.readable()) f.read()# 输出结果Falseio.UnsupportedOperation: not readable 123456789with open('a.txt', mode='at', encoding='utf-8') as f: f.write('你好\n')# 打开文件 a.txt111122223333你好你好你好 1234567891011with open('a.txt', mode='at', encoding='utf-8') as f: f.writelines(['aaaa\n', 'bbbb\n'])# 打开文件 a.txt111122223333你好你好你好aaaabbbb b 模式 操作文件内容 操作文件内容 t模式 有局限性优点：读写文件以 字符串 为单位，不用自己去进行编码解码的转换缺点：仅仅只适用于文本文件我们不仅仅要操作文本文件，还要操作 图片，视频，等，再用 t模式 就无法处理了文本文件 里存的是 字符，而 图片，视频文件中存的是 二进制 12345with open('1.mp4', mode='rt', encoding='utf-8') as f: f.read()# 输出结果UnicodeDecodeError: 'utf-8' codec can't decode byte 0x86 in position 37: invalid start byte b模式 字节，二进制模式，一种原始的模式，在硬盘上存的都是二进制模式，如果打开的文件时 b模式，意味告诉操作系统，不用做转换，文件存的是什么，读出来就是什么bytes` 二进制模式，该模式下操作文件的内容单位都是bytes，该模式适用于所有类型文件 注意： b模式 不需要指定 encoding 参数12345with open('1.mp4', mode='rb', encoding='utf-8') as f: f.read()# 输出结果ValueError: binary mode doesn't take an encoding argument 获取 音频文件 二进制内容 12345678with open('1.mp4', mode='rb') as f: data = f.readline() # 文件大，文件内容多，用 readline() print(type(data)) print(data)# 输出结果&lt;class 'bytes'&gt;b'\x00\x00\x00\xlcftypisom\x00\x00\x02\x00isomiso2mp41\x00\x00\x08free\t...' 获取 文本文件 二进制内容 12345678with open('d.txt', mode='rb') as f: data = f.read() # 文件小，文件内容少，用 read() print(type(data)) print(data)# 输出结果&lt;class 'bytes'&gt;b'\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x95\x8a\r\naaaa\r\nbbbbccc\r\n1111' 12345678910with open('d.txt', mode='rb') as f: data = f.read() res = data.decode('utf-8') # 将读出的二进制内容解码，转换成人类可识别的内容 print(res)# 输出结果你好啊aaaabbbbccc1111 12with open('d.txt', 'wb') as f: f.write('你好，Python'.encode('utf-8')) 遍历文件内容的方式12345678with open(r'd.txt', mode='rt', encoding='utf-8') as f: for line in f: # 如果文件过大，使用 for循环 读文件内容 print(line, end='')# 输出结果你好，Python你好，Python你好，Python 123456with open(r'd.txt', mode='rb') as f: print(f.readline()) print(f.readline()) print(f.readline())# 输出结果 二进制文件内容，换行符不会被识别 12print(b'11111111\n')print('====================') 输出 二进制文件 内容时，print() 内不要加 end=&#39;&#39;遍历 音频文件 内容 123with open('1.mp4', mode='rb') as f: for line in f: print(line) 练习：利用 b模式，编写一个 cp工具示例一1234with open(r'D:\test.jpg', 'rb') as read_f,\ open(r'E:\test.jpg', mode='wb') as write_f: for line in read_f: write_f.write(line) 1234567src_file_path = input('源文件路径：').strip()dst_file_path = input('目标文件路径').strip()with open(r'%s' % src_file_path, 'rb') as read_f,\ open(r'%s' % dst_file_path, mode='wb') as write_f: for line in read_f: write_f.write(line) 123456789101112import syssrc_file_path = sys.argv[1]dst_file_path = sys.argv[2]with open(r'%s' % src_file_path, 'rb') as read_f,\ open(r'%s' % dst_file_path, mode='wb') as write_f: for line in read_f: write_f.write(line)# 执行结果python3 copy.py test.jpg test2.jpg 示例二 既可以拷贝文本又可以拷贝视频，图片等文件 用户一旦参数错误，打印命令的正确使用方法，如 usage: cp source_file target_file提示：可以用 import sys，然后用 sys.argv 获取脚本后面跟的参数 1234567import sysprint(sys.argv)# 执行结果python3 cp.py src.txt dst.txt['cp.py', 'src.txt', 'dst.txt'] 123456789import sysprint(sys.argv[1])print(sys.argv[2])# 执行结果python3 cp.py src.txt dst.txtsrc.txtdst.txt 1234567891011import sysif len(sys.argv) != 3: print('usage: cp source_file target_file') sys.exit()source_file, target_file=sys.argv[1], sys.argv[2]with open(source_file,'rb') as read_f, \ open(target_file,'wb') as write_f: for line in read_f: write_f.write(line) 可读可写模式 + r+t，r+bw+t，w+ba+t，a+b 12345678910with open('a.txt', mode='r+t', encoding='utf-8') as f: print(f.readable()) print(f.writable())# r+t 模式，在没有文件的情况下，会报找不到文件的提示FileNotFoundError: [Errno 2] No such file or directory: 'a.txt'# 执行结果TrueTrue 1234567with open('a.txt', mode='r+t', encoding='utf-8') as f: print(f.read())# 执行结果111222333 12345678with open('a.txt', mode='r+t', encoding='utf-8') as f: print(f.read()) f.write('444\n')# 执行后，查看 a.txt 文件111222333444]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python列表类型]]></title>
    <url>%2F2018%2F07%2F10%2FPython-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[list 列表类型 用途 存放多个值，记录人多个爱好，多个人名 定义方式 在 [] 内用逗号分隔 多个元素 每个元素可以是任意数据类型1234567lst = [1, 'aa', 3.1, [1, 2]] # lst = list([1, 'a', 3.1, [1, 2]])res = list('hello') # 将 字符串 转换成 列表print(res, type(res))# 输出结果['h', 'e', 'l', 'l', 'o'] &lt;class 'list'&gt; list 类型转换的工作原理：list(items) 先造一个空列表 类似调用了一个 for 循环，从 items 里取出一个值放入空列表中，循环往复直到取干净为止但凡可以被 for循环 循环的，都可以被 list() 转换1234print(list(range(1, 5)))# 输出结果[0, 1, 2, 3, 4] 调用 list() 方法123456&gt;&gt;&gt; list('hello')['h', 'e', 'l', 'l', 'o']&gt;&gt;&gt; list((1, 2, 3))[1, 2, 3]&gt;&gt;&gt; list(&#123;'x': 1, 'y': 2&#125;)['x', 'y'] 常用操作+内置方法 按索引存取值（正向存取+反向存取）：即可以取值，也可以改值 123456789101112131415161718l = ['a', 'b', 'c', 'd']print(l[3]) # 正向取值# 输出结果dprint(l[-1]) # 反向取值# 输出结果dl[3] = 'D' # 修改元素值print(l)# 输出结果['a', 'b', 'c', 'D']l[4] = '5555' # 不能根据索引往列表里追加元素值print(l)# 输出结果IndexError: list assignment index out of range 123456789101112131415161718192021222324252627282930313233343536names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[4]) # 正向取值# 输出结果yxxprint(names[-1]) # 反向取值# 输出结果yxxprint(names[-2])# 输出结果xxx# 即可以取值，也可以改值names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names[0] = 'EGON'print(names)# 输出结果['EGON', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(id(names))print(names)names[0] = 'EGON'print(id(names))print(names)# 输出结果3155914092616['egon', 'alex', 'wxx', 'xxx', 'yxx']3155914092616['EGON', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names[5] = 3 # 超出索引限制会报错# 输出结果IndexError: list assignment index out of range 切片（顾头不顾尾，步长） 从一个大列表中切出一个字列表[起始位置:结束位置:步长] 123456l = ['a', 'b', 'c', 'd']l1 = l[1:3]print(l1)# 输出结果['b', 'c'] 1234567891011121314151617181920212223names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[起始位置:结束位置:步长])print(names[0:3]) # 正向取# 输出结果['egon', 'alex', 'wxx']print(names[0:3:2]) # 正向步长# 输出结果['egon', 'wxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[::1])# []内 起始没写，默认从索引0开始# 结束没写，默认到最后结束# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[:]) # [] 冒号左边没有值，默认索引是0，冒号右边没有写值，默认到最后结束 # 如果要获取列表内所有的值，可以省略掉 冒号 左右两边的值# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx'] 反向取值，反向步长（顾头不顾尾）1234567891011121314print(names[起始位置:结束位置:反向步长])names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[3:0:-1]) # 遵循切片顾头不顾尾的规则，agon 获取不到# 输出结果['xxx', 'wxx', 'alex']print(names[3::-1]) # 在结束位置不写值，就能获取到最后一个元素值# 输出结果['xxx', 'wxx', 'alex', 'egon']print(names[-1::-1])# 输出结果['yxx', 'xxx', 'wxx', 'alex', 'egon'] 长度 len()12345l = ['a', 'b', 'c', 'd']print(len(l)# 输出结果4 12345names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(len(names))# 输出结果5 成员运算 in 和 not in123456789101112names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]print('alex' in names)# 输出结果Trueprint(4 in names)# 输出结果Trueprint(5 not in names)# 输出结果True 追加 append()123456l = ['a', 'b', 'c', 'd']l.append('aaa')print(l)# 输出结果['a', 'b', 'c', 'd', 'aaa'] 12345678910111213names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.append('oldboy')print(names)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx', 'oldboy']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.append('oldboy1')names.append('oldboy2')names.append('oldboy3')print(names)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx', 'oldboy1', 'oldboy2', 'oldboy3'] 插入 insert()1234567891011121314151617l = ['a', 'b', 'c', 'd']l.insert(1, 'B')print(l)# 输出结果['a', 'B', 'b', 'c', 'd']l.insert(0, 'B')print(l)# 输出结果['B', 'a', 'b', 'c', 'd']l.insert(0, 'B')l.insert(0, 'egon')print(l)# 输出结果['egon', 'B', 'a', 'b', 'c', 'd'] 12345678910names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.insert(0, oldboy) # 两个参数：索引下标，插入的值print(names)# 输出结果['oldboy', 'egon', 'alex', 'wxx', 'xxx', 'yxx']names.insert(2, 'oldboy')print(names)# 输出结果['egon', 'alex', 'oldboy', 'wxx', 'xxx', 'yxx'] 删除 del, remove(), pop()del 删除1234567891011l = ['a', 'b', 'alex', 'd']del l[2]print(l)# 输出结果['a', 'b', 'd']res = del l[2]print(res)# 输出结果SyntaxError: invalid syntax 123456names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']del names[2] # 删除列表中某一个元素print(names)# 输出结果['egon', 'alex', 'xxx', 'yxx'] 非列表独有的删除，是一种通用的删除方法 remove() 删除 只是单纯的删除操作，没有返回值 1234567891011l = ['a', 'b', 'alex', 'd']l.remove('alex')print(l)# 输出结果['a', 'b', 'd']res = l.remove('alex') # 只是单纯的删除操作，没有返回值print(res)# 输出结果None 12345678910111213141516names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.remove(0) # 单纯的删除，没有返回值print(names)# 输出结果ValueError: list.remove(x): x not in listnames = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.remove('wxx') # remove() 是指定元素值删除print(names)# 输出结果['egon', 'alex', 'xxx', 'yxx']res = names.remove('wxx') # remove() 没有返回值print(res)# 输出结果None pop() 从列表中取走一个元素值 删除一个元素 将该元素当做返回值返回默认从最后一个删除 12345678910111213l = ['a', 'b', 'alex', 'd']res = l.pop() # 默认从最后一个删除print(l)print(res)# 输出结果['a', 'b', 'alex']dl = ['a', 'b', 'alex', 'd']res = l.pop(2)print(res)# 输出结果alex 1234567891011121314151617181920212223names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.pop(0) # pop() 是按照索引下标删除元素值print(names)# 输出结果['alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']res = names.pop(0)print(names)print(res) # pop() 会获取返回删除的元素值# 输出结果['alex', 'wxx', 'xxx', 'yxx']egonres = names.pop(100) # 超过索引限制会报错# 输出结果IndexError: pop index out of rangenames = ['egon', 'alex', 'wxx', 'xxx', 'yxx']if 100 &lt; len(names): # 可以加一个判断 来让它不报错 res = names.pop(100) print(names) print(res) 循环（循环取值）12345678l = ['a', 'b', 'c']for item in l: print(item)# 输出结果abc 1234567891011121314names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]for item in names: print(item)# 输出结果egonalexwxxxxxyxx1234 列表可变类型可变类型：值变，id不变，可变 == 不可hash 12345678l1 = ['a', 'b', 'c']print(id(l1))l1[0] = 'A'print(id(l1))# 输出结果14608203903441460820390344 reverse() 反转（单纯的反转）123456l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.reverse()print(l1)# 输出结果['a', 'b', 'a', 'a', 2.3, 1] 123456names = ['alex', 'wxx', 'lxx']names.reverse()print(names)# 输出结果['lxx', 'wxx', 'alex'] 123456names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]names.reverse() # reverse() 反转，改的是原值print(names)# 输出结果[4, 3, 2, 1, 'yxx', 'xxx', 'wxx', 'alex', 'egon'] count() 统计列表元素值的个数12345l1 = [1, 2.3, 'a', 'b', 'a']print(l1.count('a'))# 输出结果3 12345names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]print(names.count('xxx')) # count()方法 统计列表元素值的个数# 输出结果2 clear() 清空列表所有元素值123456l1 = [1, 2.3, 'a']l1.clear()print(l1)# 输出结果[] 123456names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]names.clear() # clear() 清空列表所有元素值print(names)# 输出结果[] copy() 列表复制123456l1 = [1, 2.3, 'a']l2 = l1.copy()print(l2)# 输出结果[1, 2.3, 'a'] 12345678names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]print(names)lst = names.copy() # copy() 复制一份列表元素值print(lst)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4] extend() 向列表末尾追加多个元素值123456789101112131415l1 = [1, 2.3, 'a', 'a', 'b', 'a']l2 = [4, 5, 6]l1.append(l2[0])l1.append(l2[1])l1.append(l2[2])# 输出结果[1, 2.3, 'a', 'a', 'b', 'a', 4, 5, 6]# 一个一个追加，比较麻烦l1 = [1, 2.3, 'a', 'a', 'b', 'a']l2 = [4, 5, 6]l1.extend(l2)print(l1)# 输出结果[1, 2.3, 'a', 'a', 'b', 'a', 4, 5, 6] index()获取列表元素值的索引下标1234567891011121314l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.index('egon')# 输出结果ValueError: 'egon' is not in listl1 = [1, 2.3, 'a', 'a', 'b', 'a']print(l1.index('a'))# 输出结果2l1 = [1, 2.3, 'a', 'a', 'b', 'a']print(l1.index('a', 0, 3)) # 指定 起始位置,结束位置（顾头不顾尾）# 输出结果2 12345678910names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]# names.index(元素值, 起始位置，结束位置)print(names.index('alex'))# 输出结果1# 没有的元素值，会报错print(names.index('alexabcd'))# 输出结果ValueError: 'alexabcd' is not in list sort 排序 默认从小到大排序 123456names = [1, 10, 3, -1]names.sort() # 默认从小到大排序print(names)# 输出结果[-1, 1, 3, 10] 1234567891011nums = [9, 3, 4, -1, 5, 100, 98]nums.sort(reverse=True) # 从大到小排序print(nums)# 输出结果[-1, 3, 4, 5, 9, 98, 100]nums = [9, 3, 4, -1, 5, 100, 98]nums.sort(reverse=True) # 从大到小排序print(nums)# 输出结果[100, 98, 9, 5, 4, 3, -1] 123456l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.sort()# 输出结果TypeError: '&lt;' not supported between instances of 'str' and 'float'# 字符串 和 浮点类型 之间不支持排序 1234567names = [1, 10, 3, -1, 'a']names.sort()print(names)# 输出结果TypeError: '&lt;' not supported between instances of 'str' and 'int'# 字符串 和 整型 之间不支持排序 列表中的元素值，必须是 同一 类型，才能做比较排序 1234567891011121314151617181920212223names = ['b', 'a', 'c']names.sort()print(names)# 输出结果['a', 'b', 'c']names = ['b', 'a', '+']names.sort()print(names)# 输出结果['+', 'a', 'b']s1 = 'hello's2 = 'z'print(s1 &gt; s2)# 输出结果Falsex = 'hello'y = 'hez'print(y &gt; x)# 输出结果True 字符串 是 根据位置 比较的，先比较两个字符串的第一个位置的字符如果 第一个字符比出大小，后面的字符将不再做比较字符串之间根据 ASCII码 来做比较小写字母 比 大写字母 大 列表比较大小123456789101112131415161718lst1 = [1, 2, 'a', 'b']lst2 = [3, 4]print(lst2 &gt; lst1)# 输出结果Truelst1 = [1, 2, 'a', 'b']lst2 = [1, 2, 3]print(lst2 &gt; lst1)# 输出结果TypeError: '&gt;' not supported between instances of 'int' and 'str'# 第三个位置不是同一种类型，所以报错lst1 = [1, 2, 'a', 'b']lst2 = [1, 2, 'b']print(lst2 &gt; lst1)# 输出结果True 队列：先进先出1234567891011121314151617l = []# 入队l.append('first')l.append('second')l.append('third')print(l)# 输出结果['first', 'second', 'third']# 出队print(l.pop(0))print(l.pop(0))print(l.pop(0))# 输出结果firstsecondthird 堆栈：先进后出1234567891011121314151617l = []# 入栈l.append('first')l.append('second')l.append('third')print(l)# 输出结果['first', 'second', 'third']# 出栈print(l.pop(-1)) # 默认是 -1，不写就是 -1print(l.pop(-1))print(l.pop(-1))# 输出结果thirdsecondfirst 总结 能存多个值，没有类型限制 有序（能够按索引取值的属于有序的） 可变类型 可变：值变，id不变，可变 == 不可hash list（任何能被 for循环的对象）转换成 列表]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python列表类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python集合类型]]></title>
    <url>%2F2018%2F07%2F10%2FPython-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[set 集合类型 用途 主要用于关系运算去重 定义方式 在 {} 内用逗号分隔开多个元素每一个元素必须为不可变类型(int，float，str，tuple)集合内的元素不能重复集合内元素无序 12pythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']linuxers = ['wxx', '吴三江', '张大炮', '王全蛋'] 获取即报名Linux，又报名Python 课程 的 学生姓名 12345678pl = []for name in pythoners: if name in linuxers: pl.append(name)print(pl)# 输出结果['wxx', '吴三江'] 123456789s = &#123;&#125; # 定义空字典print(s, type(s))# 输出结果&#123;&#125; &lt;class 'dict'&gt;s = set() # 定义空集合print(s, type(s))# 输出结果set() &lt;class 'set'&gt; 123456789s = &#123;1, 2&#125; # s = set(&#123;1, 2&#125;)print(type(s))# 输出结果&lt;class 'set'&gt;s = &#123;1, 'a', 3&#125; # s = set(&#123;1, 'a', 3&#125;)print(s, type(s))# 输出结果&#123;1, 3, 'a'&#125; &lt;class 'set'&gt; 12345s = &#123;1, 'a', 3.1, [1,2]&#125;# 输出结果TypeError: unhashable type: 'list'# 列表类型 是 不可hash类型，不能用于 集合 可变类型 不可 hash不可变类型 可 hash集合无法一个值一个值取值 集合类型 元素不能重复12345s = &#123;1,2,2,2,2,22,2,2,2,2&#125;print(s)# 输出结果&#123;1, 2, 22&#125; 集合去重有局限性 不能保证原来的顺序不能针对可变类型去重 1234s = set('hello')print(s)# 输出结果&#123;'o', 'h', 'l', 'e'&#125; 12345678910111213141516171819202122l = [1, 1, 1, 1, 'egon', 'alex', 'egon']s = set(l) # 将 l 列表 转换成 集合print(s)# 输出结果&#123;1, 'egon', 'alex'&#125;s = &#123;'egon', 'alex', 'wxx', 'lxx'&#125;for item in s: # 遍历 集合 print(item)# 输出结果egonlxxwxxalexl = [1, 1, 1, 1, 'egon', 'alex', 'egon']s = set(l) # 将 列表 转换成 集合# print(s)l = list(s) # 再将 集合 转换成 列表print(l)# 输出结果[1, 'egon', 'alex'] 需求：即想针对可变类型去重，又想保证原来的顺序 列表内的元素有可变类型 去重之后要保证原来顺序 1234567891011121314151617181920info = [ &#123;'name':'egon', 'age':18&#125;, &#123;'name':'alex', 'age':73&#125;, &#123;'name':'egon', 'age':18&#125;, &#123;'name':'lxx', 'age':19&#125;, &#123;'name':'egon', 'age':18&#125;, &#123;'name':'lxx', 'age':19&#125;,]l = []for dic in info: if dic not in l: l.append(dic)# print(l)info = lprint(info)# 输出结果[&#123;'name':'egon', 'age':18&#125;, &#123;'name':'alex', 'age':73&#125;, &#123;'name':'lxx', 'age':19&#125;] 12345678910s = &#123;'a', 'asdfsa', (1, 2), 1, 3.1&#125;for item in s: print(item)# 输出结果(1, 2)13.1asdfsaa 长度len()12345678print(len(&#123;1, 2, 3&#125;))# 输出结果3pythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']print(len(pythoners))# 输出结果5 成员运算 in 和 not in12345678print(1 in &#123;1, 2, 3&#125;)# 输出结果Truepythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']print('egon' in pythoners)# 输出结果True 集合的关系运算交集 &amp; ，intersection() 内置方法 获取两个集合的共同部分 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners &amp; linuxers)# 输出结果['wxx', '吴三江'] 123print(pythoners.intersection(linuxers))# 输出结果['wxx', '吴三江'] 差集 -，difference() 内置方法 获取只报名Python，没有报名Linux 的人即集合pythoners 减去 linuxers ，称之为 差集 12345pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners - linuxers)# 输出结果&#123;'艾利克斯', 'oldboy', 'egon'&#125; 123print(pythoners.difference(linuxers))# 输出结果&#123;'艾利克斯', 'oldboy', 'egon'&#125; 获取只报名 linux，没有报名 python 的人 12345pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(linuxers - pythoners)# 输出结果&#123;'王全蛋', '张大炮'&#125; 123print(linuxers.difference(pythoners))# 输出结果&#123;'王全蛋', '张大炮'&#125; 合集，并集 |，union() 内置方法 获取两个集合的总和，把两个集合合到一起，把重复的部分去除获取所有的学生的姓名 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners | linuxers)# 输出结果&#123;'吴三江', 'oldboy', '王全蛋', 'egon', 'wxx', '张大炮', '艾利克斯'&#125; 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners.union(linuxers))# 输出结果&#123;'吴三江', 'oldboy', '王全蛋', 'egon', 'wxx', '张大炮', '艾利克斯'&#125; 对称差集 ^，symmetric_difference()` 内置方法 获取没有同时报名两门课程的学生姓名 123456789pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners ^ linuxers)# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125;print(linuxers ^ pythoners)# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125; 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners.symmetric_difference(linuxers))# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125; == 比较两个值是否相等1234567891011s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2, 3&#125;print(s1 == s2)# 输出结果Trues1 = &#123;1, 2, 3&#125;s2 = &#123;3, 2, 1&#125;print(s1 == s2)# 输出结果True 集合之间做比较，指的是包含 与 被包含的关系 父集 &gt; &gt;=，issuperset() 内置方法12345678910s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1 &gt; s2)print(s1 &gt;= s2)# 判断 s1 是否是 s2 的父集# 判断 s1 是否包含 s2# 输出结果TrueTrue 123456s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2, 4&#125;print(s1 &gt;= s2) # 判断 s1 是否是 s2 的父集# 输出结果False 123456s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1.issuperset(s2)) # 判断 s1 是否是 s2 的父集# 输出结果True 子集 &lt; &lt;=，issubset()内置方法1234567s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s2 &lt;= s1) # 判断 s2 是否是 s1 的子集 # 判断 s2 是否被 s1 包含# 输出结果True 1234567s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s2.issubset(s1)) # 判断 s2 是否是 s1 的子集 # 判断 s2 是否被 s1 包含# 输出结果True 添加集合元素 集合属于可变类型，值变，id不变，不可 hash 123456789s1 = &#123;1, 2, 3, 4, 5&#125;print(id(s1))s1.add(6)print(id(s1))# 输出结果3014527602472&#123;1, 2, 3, 4, 5, 6&#125;3014527602472 12345678910s1 = &#123;'a', 'b', 'c'&#125;print(id(s1))s1.add('d')print(s1)print(id(s1))# 输出结果1981688305928&#123;'b', 'd', 'a', 'c'&#125;1981688305928 删除集合元素remove() 按元素名删除元素12345678910111213141516s1 = &#123;'a', 'b', 'c'&#125;s1.remove('b')print(s1)# 输出结果&#123;'a', 'c'&#125;# 查看是否有返回值s1 = &#123;'a', 'b', 'c'&#125;res = s1.remove('b') # 只是单纯的删除，没有返回值print(res)# 输出结果Nones1.remove('dddd') # 指定元素删除，如果元素不存在，则报错# 输出结果KeyError: 'dddd' discard() 按元素名删除元素1234567891011s1 = &#123;1, 2, 3, 4, 5&#125;s1.discard(3)print(s1)# 输出结果&#123;1, 2, 4, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s1.discard(333333) # 指定元素删除，如果元素不存在，不会报错print(s1)# 输出结果&#123;1, 2, 3, 4, 5&#125; 123456789101112131415161718s1 = &#123;'a', 'b', 'c'&#125;s1.discard('b')print(s1)# 输出结果&#123;'a', 'c'&#125;# 查看是否有返回值s1 = &#123;'a', 'b', 'c'&#125;res = s1.discard('b') # 没有返回值print(res)# 输出结果Nones1 = &#123;'a', 'b', 'c'&#125;s1.discard('dddd') # 指定元素删除，如果元素不存在，不会报错print(s1)# 输出结果&#123;'a', 'b', 'c'&#125; pop() 随即删除，有返回值，将删除的元素值返回出来123456s1 = &#123;'a', 'b', 'c'&#125;res = s1.pop() # 随即删除，有返回值，将删除的元素值返回出来print(res)# 输出结果c 更新集合元素update() 更新集合中的元素值，并且去除重复值12345678910s1 = &#123;1, 2, 3, 4, 5&#125;s1.update(&#123;3, 4, 5, 6, 7&#125;)print(s1)# 输出结果&#123;1, 2, 3, 4, 5, 6, 7&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s1.update('hello') # 先将字符串 hello 转成集合，再更新到 s1 里去# 输出结果&#123;1, 2, 3, 4, 5, 'l', 'e', 'h', 'o'&#125; 清空集合元素12s1 = &#123;1, 2, 3, 4, 5&#125;s1.clear 查看两个集合是否有交集（共同部分）isdisjoint() 判断两个集合没有交集（共同部分），返回 True1234# 查看注释，Ctrl + 点击左键def isdisjoint(self, *args, **kwargs): # real signature unknown """ Return True if two sets have a null intersection. """ pass 1234567891011s1 = &#123;1, 2, 3&#125;s2 = &#123;4, 5, 6&#125;print(s1.isdisjoint(s2))# 输出结果Trues1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1.isdisjoint(s2))# 输出结果False 把找出来的差集，重新覆盖原集合12345678910111213141516171819202122232425262728s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;res = s1.difference(s2) # s1 - s2print(res)# 输出结果&#123;1, 2, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1.difference(s2) # s1 - s2print(s1)# 输出结果&#123;1, 2, 3, 4, 5&#125;# 原 s1 的值其实并没有改变s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1 = s1.difference(s2) # s1 = s1 - s2，将改变后的值重新赋值给 s1 将其改变print(s1)# 输出结果&#123;1, 2, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1.difference_update(s2) # s1=s1.difference # s1=s1-s2，将改变后的值重新赋值给 s1 将其改变print(s1)# 输出结果&#123;1, 2, 5&#125; 1234567891011121314s1 = &#123;'a', 'b', 'c'&#125;s2 = &#123;'b', 'd', 'f'&#125;print(s1.difference(s2))print(s1)# 输出结果&#123;'a', 'c'&#125; # 这是一个新的元素值&#123;'a', 'c', 'b'&#125; # 原 s1 的内容没有改变s1 = &#123;'a', 'b', 'c'&#125;s2 = &#123;'b', 'd', 'f'&#125;s1.difference_update(s2) # 等于 s1 = s1.difference(s2)print(s1)# 输出结果&#123;'a', 'c'&#125; # 将差集的结果直接赋值给s1 将对称差集的结果，重新覆盖原集合1s1.symmetric_difference_update() 将交集的结果，重新覆盖原集合1s1.intersection_update() 用集合去重，不保证顺序1234567l = ['a', 'b', 1, 'a', 'a']print(list(set(l)))names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']print(set(names))# 输出结果&#123;'wxx', 'alex', 'egon'&#125; 将 集合 转回 原来 的类型，不保证顺序12345names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']print(list(set(names)))# 输出结果['egon', 'wxx', 'alex'] 用集合去重，局限性很强不能保证元数据类型的顺序元数据类型中包含的元素必须全都为不可变类型 即想去重，又想保证顺序 遍历集合123s = &#123;'egon', 'alex', 'wxx', 'lxx'&#125;for item in s: print(item) 123456789names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']new_names = []for name in names: if name not in new_names: new_names.append(name)print(new_names)# 输出结果['alex', 'egon', 'wxx'] 使用 keys() 方法1names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx'] list() 方法是把 str字符串 或 tuple元组 转成 list列表12345new_names = list(&#123;&#125;.fromkeys(names).keys())print(new_names)# 输出结果['alex', 'egon', 'wxx'] 列表类型，字典类型，集合类型方式 去除重复的部分，保证原来的顺序12345678910111213141516171819202122232425262728l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = set() # 创建一个空集合new_l = []for d in l: # n, a, s = d['name'], d['age'], d['sex'] # 获取到 字典的值 # print(n, a, s) # s.add((n, a, s)) values = (d['name'], d['age'], d['sex']) print(values) if values not in s: s.add(values) new_l.append(d)print(new_l)# 输出结果('egon', 18, 'male')('alex', 73, 'male')('egon', 20, 'female')('egon', 18, 'male')('egon', 18, 'male')[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 列表类型，字典类型 方式 去除重复的部分，保证原来的顺序123456789101112131415161718l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = []new_l = []for d in l: if d not in s: s.append(d) new_l.append(d)print(new_l)# 输出结果[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 列表类型，字典类型 方式 去除重复的部分，保证原来的顺序12345678910111213141516l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = []for d in l: if d not in s: s.append(d)print(s)# 输出结果[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 去重，保证原来的顺序1234567l = ['a', 'b', 1, 'a', 'a']l_new = []s = set()for item in l: if item not in s: s.add(item) l_new.append(item) 集合总结定义1s = &#123;1, 2, 3&#125; 注意 集合能存多个值集合无序集合内元素不能重复集合内的元素必须为不可变类型，但set集合是可变的 用途 集合是用来进行关系运算，单独取集合的某一个元素是没有意义的，也没有相应的方法1234交集：s1 &amp; s2 取两个集合的共同部分差集：s1 - s2 结果存于 s1 而不存于 s2 的元素集合补集：s1 ^ s2 扣掉 s1 与 s2 共同部分，剩下的部分合到一起并集：s1 | s2 把两个合到一起，去掉重复]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python集合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串类型]]></title>
    <url>%2F2018%2F07%2F05%2FPython-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[str 字符串类型str 基本使用用途 用于 描述型的数据，姓名，性别，地址，国籍 等 定义方式 在单引号，双引号，三引号内包含一串的字符 1234567891011121314151617msg="hello world" # msg=str("hello world") res1=str(1)res2=str(1.2)res3=str([1,2,3])print(type(res1),type(res2),type(res3))info = 'my name is agon'name = 'egon' # name = str('egon')print(name)print(type(name))print(id(name))# 输出结果egon&lt;class 'str'&gt;3172826579048 常用操作+内置的方法12345678910111213141516171819# 按索引取值（正向取+反向取），只能取msg = 'he lo'print(msg[0])print(msg[3])# 输出结果hlmsg = 'he lo'msg[2] = 'A'TypeError: 'str' object does not support item assignment# 字符串不支持更改内容msg = 'hello'print(msg[0:]) # 正向取值print(msg[::-1]) # 反向取值# 输出结果helloolleh 切片（顾头不顾尾，步长）123456789101112131415161718192021msg = 'hello world'print(msg[0:4]) # 从索引 0 开始 到 4 结束# 输出结果hell # 遵循 顾头不顾尾 的规则，输出到 o 前面的字符 l 结束print(msg[0:4:2]) # 步长，隔2步，取一个字符# 输出结果hl# 从一个大字符串中切除一个子字符串（骨头不顾尾，步长）msg = 'hello world'print(msg[1:3])print(msg[6:11])print(msg[6:11:2])# 倒着取值，注意方向要一致msg = 'hello world'print(msg[6:])print(msg[-1:-6:-1])print(msg[-1::-1])print(msg[::-1]) 123456789inp = 'get a.txt'cmd = inp[0:3]filepath = inp[4:]print(cmd)print(filepath)# 输出结果 获取 命令 和 文件名geta.txt 123456inp = 'get a.txt'# inp.split() # 不指定 分割符 默认以空格为分割符res = inp.split(' ')print(res)# 输出结果['get', 'a.txt'] 12345678910111213s = "1234567890"s = "abcdefghij"print(s[-1:]) # 截取最后一个元素print(s[0:3]) # 截取第一位到第三位的字符print(s[:]) # 截取字符串的全部字符print(s[6:]) # 截取第七个字符到结尾print(s[:-3]) # 截取从头开始到倒数第三个字符之前print(s[2]) # 截取第三个字符print(s[::-1]) # 创建一个与原字符串顺序相反的字符串print(s[-3:-1]) # 截取 倒数第三位 和 倒数第一位 之前的字符print(s[-3:]) # 截取 倒数第三位 到结尾print(s[:-12:-2]) # 逆序截取后个数，每 3 个取一个，而且取是逆向取值print(s[:10:2]) # 前 10 个数，每两个取一个 长度len12345msg = 'hello world'print(len(msg)) # 长度是11，索引最大到10# 输出结果5 成员运算 in 和 not in12345678910111213141516171819202122232425msg = 'hello world alex is SB'print('alex' in msg) # 判断 子字符串 'alex' 是否在 msg 变量字符串里print('SB' in msg)print('egon' not in msg)print(not 'egon' in msg)# 输出结果Truemsg = 'alex say my name is alex'if 'alex' in msg: print('存在')# 输出结果存在msg = 'alex say my name is alex'print('alex' in msg)print('alex' not in msg) # 推荐使用这种形式print(not 'alex' in msg)# 输出结果TrueFalseFalse strip 移除字符串左右两边的字符 strip 只能 移除 字符串 左右两边的 字符1234567name = '***egon*****'print(name.strip('*'))print(name)# 输出结果egon # strip 是生成了一个新的值，并不是改变原值***egon***** 12345678name = ' egon '# strip() 不写指定符号，默认去除字符串左右两边的空格name = name.strip()# 将 strip() 生成的新值，重新赋值给 变量name，可以看作是 字符串的变更print(name)# 输出结果egon 12345msg = '* / , alex is sb -*=*******'print(msg.strip('*, /-='))# 输出结果alex is sb 123name = input('&gt;&gt;&gt;: ')name = input('&gt;&gt;&gt;: ').strip()print(name) 1234567while True: # cmd = input('cmd&gt;&gt;: ') # cmd = cmd.strip() # 主要用于用户输入时，去除左右两边的空格字符 cmd = input('cmd&gt;&gt;: ').strip() if len(cmd) == 0:continue if cmd == 'q':break print('%s is running' % cmd) 切分（分割）split1234567891011info = 'root:x:0:0:root:/root:/bin/bash'print(info)res = info.split(':') # 不指定分割符，默认从头切到尾# res = info.split(':', maxsplit=-1)print(res, type(res))print(res[0]) # 经过 split 分割后，获取下标为 0 的元素# 输出结果root:x:0:0:root:/root:/bin/bash['root', 'x', '0', '0', 'root', '/root', '/bin/bash']root 123456789101112cmd = 'get a.txt'res = cmd.split() # split() 不写参数，默认以空格分割print(res[0])print(res[1])# 输出结果 获取 命令 和 文件名geta.txtcmd = 'get a.txt 33333'res = cmd.split(' ', maxsplit=1)print(res) 循环（循环取值） while 循环取值12345678msg = 'hello world'n = 0while True: print(msg[n]) n += 1# 输出信息IndexError: string index out of range 123456789101112131415161718msg = 'hello world'n = 0 # 指定一个计数器while n &lt; len(msg): print(msg[n]) n += 1 # 自加计数器# 输出结果helloworld for循环迭代取值12345678910111213141516msg = 'hello world'for item in msg: print(item)# 输出结果helloworld strip, lstrip, rstrip123456789name='*****hello*****'print(name.strip('*')) # 去除左右两边的字符print(name.lstrip('*')) # 去除左边的字符print(name.rstrip('*')) # 去除右边的字符# 输出结果hellohello**********hello lower, upper12345678910name='hello'print(name.lower()) # 转换小写字母print(name) # lower 方法不改变原值print(name.upper()) # 转换大写字母print(name) # upper 方法不改变原值# 输出结果helloHELLOHello startswith, endswith1234567name='Hello is run'print(name.startswith('Hello')) # 以 Hello 开头print(name.endswith('run')) # 以 run 结尾# 输出结果TrueTrue format 字符串格式化输出 的 三种方法 %s 的方式传值需要记住传值位置1print('name is %s age is %s' % ('egon', 18)) 缺点严格依赖 %s 的位置 123456789101112131415161718192021# format() 里的参数可以不用对应（推荐使用这种方式）print('name is &#123;name&#125; age is &#123;age&#125;'.format(age=18, name='egon'))# 输出方式name is egon age is 18# 此方法类似 %s 的格式化输出print('name is &#123;&#125; age is &#123;&#125;'.format('egon', 18))# 输出结果name is egon age is 18print('name is &#123;0&#125;&#123;0&#125;&#123;0&#125; age is &#123;1&#125;'.format(18, 'egon'))# 输出结果name is 181818 age is egonprint('&#123;1&#125; &#123;0&#125; &#123;1&#125;'.format('egon', 18, 'male'))# 输出结果18 egon 18print('&#123;0&#125; &#123;1&#125; &#123;2&#125;'.format('egon', 18, 'male'))# 输出结果egon 18 male split, rsplit split 可以把 字符串 切割成 列表 1234cmd = 'get|a.txt|3333'print(cmd.split('|', 1))print(cmd.rsplit('|', 1)) 123456789info = 'root:x:0:0:root:/root:/bin/bash'print(info.split(':')) # 这里的分割符指定为(:)冒号，默认分隔符为空格print(info.split(':', -1)) # 默认值为 -1，-1 表示从头切到尾info = 'root:x:0:0:root:/root:/bin/bash' # 获取第一个 rootprint(info.split(':', 1)) # 1 表示切一次，从左往右切割一次# 输出结果['root', 'x:0:0:root:/root:/bin/bash'] 12345info = 'root:x:0:0:root:/root:/bin/bash'print(info.rsplit(':', 1)) # 从右开始切割一次# 输出结果['root:x:0:0:root:/root', '/bin/bash'] join 拼接 join 把 列表 转成 字符串，前提是列表中的所有数据为字符串123456info = 'root:x:0:0:root:/root:/bin/bash'str_to_list = info.split(':')print(str_to_list)# 输出结果['root', 'x', '0', '0', 'root', '/root', '/bin/bash'] 12345678lst = ['root', 'x', '0', '0', 'root', '/root', '/bin/bash']list_to_str = ':'.join(lst)print(list_to_str)print(type(list_to_str))# 输出结果root:x:0:0:root:/root:/bin/bash&lt;class 'str'&gt; iterable 参数 可被 for 循环的 全都是 iterable1234567for i in lst: print(i)# 注意：join 只能连接 所包含的元素 全都为 字符串类型 的列表lst = [1, 2, 3]':'.join(lst)TypeError: sequence item 0: expected str instance, int found replace 替换字符串 replace 不会改变原值123456789msg = 'my name is alex, alex say hello'print(msg.replace('alex', 'egon')) # 不指定，表示全部替换print(msg.replace('alex', 'egon', 1)) # 1 表示 替换第一个print(msg.replace('alex', 'egon', -1)) # -1 表示全部替换# 输出结果my name is egon, egon say hellomy name is egon, alex say hellomy name is egon, egon say hello isdigit 判断 字符串 是否是 纯数字1234567print('10101'.isdigit())# 输出结果Trueprint('abc123'.isdigit())# 输出结果False 判断 bytes 和 unicode 类型，是最常用的用于于判断 字符 是否为 “数字” 的方法 猜年龄演示错误结果 1234567891011121314151617age='abcdefg'int(age)# 不是整型的报错信息ValueError: invalid literal for int() with base 10: 'abcdefg'age = 50while True: age = input('&gt;&gt;: ').strip() if not age.isdigit():continue age = int(age) if age &gt; 50: print('too big') elif age &lt; 50: print('too small') else: print('you got it') break find, rfind, index, rindex, coun1234567891011121314151617181920212223msg = 'my name is egon, egon is nb'print(msg.find('egon')) # 查找 子字符串 在 大字符串中的起始位置 # 找的是 'egon' 在大字符串 msg 中的起始索引# 输出结果11print(msg.find('egon', 1, 5) # 从 1 开始 到 5 结束 # 顾头不顾尾，找不到则返回 -1 不会报错，找到了则显示索引# 输出结果-1print(msg.index('egon', 1, 3)) # 同上，但是找不到会报错# 报错信息ValueError: substring not foundprint(msg.index('egon')) # 不写位置参数，和 find() 效果一样# 输出结果6print(msg.rfind('egon'))print(msg.rindex('egon'))print(msg.count('egon')) # 统计 子字符串 有多少个print(msg.count('egon', 1, 3)) # 顾头不顾尾，如果不指定范围则查找所有 center, ljust, rjust, zfill123456789101112131415print('info'.center(30,'#')) # 居中显示，两个参数，宽度，填充字符# 输出结果#############info##############print('info'.ljust(30,'*')) # 左对齐，两个参数，宽度，填充字符# 输出结果info**************************print('info'.rjust(30,'=')) # 右对齐，两个参数，宽度，填充字符# 输出结果==========================infoprint('info'.zfill(30)) # 用 0 填充 和 rjust 效果一样# 输出结果00000000000000000000000000info expandtabs 控制 tab键 的 空格个数123456789101112131415161718192021print('aaabbbb', end='')print('cccc', end='')# 输出结果aaabbbbccccprint(aaaa\nbbbb)# 输出结果aaaabbbbprint(r'a\tb') # \t 表示制表符 tab，如想取消掉这个制表符效果，在字符串前加 r # r开头的字符串内都是原始字符串，右斜杠没有特殊意义print('a\tb') # r 表示原始字符串(raw string)# 输出结果a\tba bprint('aaa\tbbb'.expandtabs(3)) # expandtabs 控制空格数print('aaa\tbbb'.expandtabs(tabsize=3))# 输出结果aaa bbb captalize, swapcase, title1234567891011print('abc'.capitalize()) # 首字母大写# 输出结果Abcprint('Ab'.swapcase()) # 大小写翻转# 输出结果aBprint('my name is egon'.title()) # 每个单词的首字母大写# 输出结果My Name Is Egon is数字系列 在 Python3 中12345678910111213141516171819202122num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isdigt 判断字符串是否是 bytes，unicodeprint(num1.isdigit()) # 常用（推荐）# 输出结果Trueprint(num2.isdigit())# 输出结果Trueprint(num3.isdigit()) # 不能判断中文数字# 输出结果Falseprint(num4.isdigit()) # 不能判断罗马数字# 输出结果False isnumeric 判断字符串是否是 unicode，中文/繁体数字，罗马数字 bytes 类型没有 isnumeric 方法123456789101112131415161718num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isnumeric: unicode, 中文，罗马print(num2.isnumeric())# 输出结果Trueprint(num3.isnumeric())# 输出结果Trueprint(num4.isnumeric())# 输出结果True isdecimal 判断字符串是否是 uncicode bytes 类型没有 isdecimal 方法123456789101112131415161718num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isdecimal:unicodeprint(num2.isdecimal())# 输出结果Trueprint(num3.isdecimal())# 输出结果Falseprint(num4.isdecimal())# 输出结果False 三者 都不能 判断 浮点数 1234num5 = '4.3'print(num5.isdigit())print(num5.isdecimal())print(num5.isnumeric()) 总结：最常用的是 isdigit，可以判断 bytes 和 unicode 类型，这也是最常见的数字应用场景如果要判断 中文数字 或 罗马数字，则需要用到 isnumeric is其他 判断字符串内是否是空格1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071print(''.isspace())# 输出结果Falseprint(' '.isspace()) # 判断字符串内是否是空格# 输出结果True# 判断字符串是否全部由字母组成print(''.isalpha())# 输出结果Falseprint('abcdefg'.isalpha()) # 判断字符串是否全部由字母组成# 输出结果Trueprint('abc123'.isalpha())# 输出结果False# 判断字符串中是否由字母或数字组成print(''.isalnum())# 输出结果Falseprint('abc123'.isalnum())# 输出结果Trueprint('abcdefg'.isalnum())# 输出结果Trueprint('123456'.isalnum())# 输出结果True# 判断字符串是否全都是小写字母print('Garfield'.islower())# 输出结果Falseprint('garfield'.islower())# 输出结果True# 判断字符串是否全都是大写字母print('Garfield'.isupper())# 输出结果Falseprint('garfield'.isupper())# 输出结果Falseprint('GARFIELD'.isupper())# 输出结果True# 判断字符串是否是标题，也就是单词首字母是否大写print('Garfield'.istitle())# 输出结果Trueprint('garfield'.istitle())# 输出结果Falseprint(''.isprintable())print(''.isidentifier()) str 字符串类型总结 只能存一个值 有序（能够按索引取值的属于有序的） 不可变类型不可变：值变，id也变。不可变==可hash12345678x = 'abc'print(id(x))x = 'bcd'print(id(x))# 输出结果16958601986241695860293792 参考文档http://www.cnblogs.com/linhaifeng/articles/7133357.html#_label3]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python字符串类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典类型]]></title>
    <url>%2F2018%2F07%2F05%2FPython-%E5%AD%97%E5%85%B8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python dict 字典类型用途 可变类型，存放多个值，key:value，key 对 value 有描述性的作用 定义方式 在 {} 内用逗号分隔 多个元素 每个元素都是 key:value 的形式key 必须是不可变类型且唯一，key 通常都是用字符串类型，需要可描述的value 可以是任意数据类型即字典的 key 可以是 int, float, tuple, str, 通常是字符串类型 12345d = &#123;3.1:1, (1,2,3):2222&#125; # d = dict(&#123;3.1:1, (1,2,3):2222&#125;)print(d[(1,2,3)])# 输出结果2222 12345d1 = dict(x=1, y=2, z=3)print(d1)# 输出结果&#123;'x': 1, 'y': 2, 'z': 3&#125; 12345d2 = dict([('name', 'egon'), ['age', 18], ('sex', 'male')])print(d2)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; 1234567891011121314151617info = &#123;'name': 'egon', 'age': 18&#125; # info = dict(&#123;'name': 'egon', 'age': 18&#125;)print(info['name']) # 根据 key 取值# 输出结果egoninfo = &#123;'name': 'egon', 'age': 18&#125;print(id(info)) # 修改前，查看 idinfo['name'] = 'EGON' # 根据 key 取值，然后修改 valueprint(id(info)) # 修改前，查看 idprint(info)# 输出结果15523023659361552302365936&#123;'name': 'EGON', 'age': 18&#125; 添加一个 key123456d = &#123;'name': 'egon', 'age': 18&#125;d['sex'] = 'male'print(d)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; key 必须是独一无二的12345d = &#123;'name': 'egon', 'age': 18, 'age': 19, 'age': 20&#125;print(d)# 输出结果&#123;'name': 'EGON', 'age': 20&#125; # 只认最后一个key key 必须是不可变类型123456info = &#123;'name': 'egon', [1, 2]: 18&#125;print(info[[1, 2]])# 输出结果TypeError: unhashable type: 'list'# 列表是 可变类型，不可hash，不支持key 元组是不可变类型，可 hash，支持 key12345info = &#123;'name': 'egon', (1, 2): 18&#125;print(info[(1, 2)])# 输出结果18 常用操作+内置方法 按 key 存取值：可存值，也可取值123456d = &#123;'x': 1&#125;d['x'] = 2print(d)# 输出结果&#123;'x': 2&#125; 123456789101112d = &#123;'x': 1&#125;print(id(d))print(d)d['x'] = 2print(id(d))print(d)# 输出结果2536822683256&#123;'x': 1&#125;2536822683256&#123;'x': 2&#125; 123456d = &#123;'x': 1&#125;d['y'] = 3print(d)# 输出结果&#123;'x': 1, 'y': 3&#125; 长度len123456789101112info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(len(info))# 输出结果3d = &#123;'name': 'egon', 'age': 18&#125;print(len(d))# 输出结果2 成员运算 in 和 not in 判断的是字典的 key1234567891011121314info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print('x' in info)# 输出结果Trued = &#123;'name': 'egon', 'age': 18&#125;print(18 in d)# 输出结果Falsed = &#123;'name': 'egon', 'age': 18&#125;print('name' in d)# 输出结果True 删除123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;del info['x']print(info)# 输出结果&#123;'y': 2, 'z': 3&#125; 1234567info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.popitem()) # 随机删，将删除的内容以元组格式返回print(info)# 输出结果('z', 3)&#123;'x': 1, 'y': 2&#125; 1234567891011121314151617181920212223242526d = &#123;'name': 'egon', 'age': 18&#125;d.pop('xx') # 如果指定了一个不存在的 key# 输出结果KeyError: 'xx'd.pop('sex', None) # 指定了 None 就不会报错了res = d.pop('sex', None)print(res)# 输出结果None# pop() 删除 key 对应的元素，并返回 value 值res = d.pop('name', None) # 删除存在的 key 时，可以不用写 Noneprint(res)# 输出结果egonprint(d)# 输出结果&#123;'age': 18&#125;info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('x')) # 根据 key 删除，把删除的 value 返回出来print(info)# 输出结果1&#123;'y': 2, 'z': 3&#125; 12345info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx')) # 如果没有这个 key，在没有指定 default 值的情况下，会报错# 输出结果KeyError: 'xxxxx' 123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx', '没有找到key')) # 指定default值的情况下，会输出 default 的值# 输出结果没有找到key&#123;'x': 1, 'y': 2, 'z': 3&#125; 123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx', None)) # 通常 default值 写None# 输出结果None&#123;'x': 1, 'y': 2, 'z': 3&#125; 键keys()，值values()，键值对items()1234d = &#123;'name': 'egon', 'age': 18&#125;d.keys() # 取 keyd.values() # 取 valued.items() # 取 key value Python2 中字典的格式Python 2.7.15 12345678&gt;&gt;&gt; d = &#123;'name': 'egon', 'age': 18&#125;&gt;&gt;&gt; d.keys()['age', 'name'] # 5个鸡蛋&gt;&gt;&gt; d.values()[18, 'egon']&gt;&gt;&gt; d.items()[('age', 18), ('name', 'egon')]&gt;&gt;&gt; 1234567891011121314&gt;&gt;&gt; msg_dic = &#123;... 'apple': 10,... 'tesla': 100000,... 'mac': 3000,... 'lenovo': 30000,... 'chicken': 10,... &#125;&gt;&gt;&gt; print(msg_dic.keys())['tesla', 'mac', 'lenovo', 'apple', 'chicken'] # 5个鸡蛋&gt;&gt;&gt; print(msg_dic.values())[100000, 3000, 30000, 10, 10]&gt;&gt;&gt; msg_dic.items()[('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('apple', 10), ('chicken', 10)]&gt;&gt;&gt; Python3 做了优化，节省内存Python 3.6.5 123456789101112131415161718192021222324252627d = &#123;'name': 'egon', 'age': 18&#125;for k in d.keys(): print(k)# 输出结果nameaged = &#123;'name': 'egon', 'age': 18&#125;for v in d.values(): print(v)# 输出结果egon18d = &#123;'name': 'egon', 'age': 18&#125;for item in d.items(): # k, v = ('name', 'egon') print(item)# 输出结果('name', 'egon')('age', 18)d = &#123;'name': 'egon', 'age': 18&#125;for k,v in d.items(): # k, v = ('name', 'egon') print(k,v)# 输出结果name egonage 18 python3 做出 python2 中的结果123456789d = &#123;'name': 'egon', 'age': 18&#125;print(list(d.keys()))print(list(d.values()))print(list(d.items()))# 输出结果['name', 'age']['egon', 18][('name', 'egon'), ('age', 18)] 123456789101112131415&gt;&gt;&gt; msg_dic = &#123;... 'apple': 10,... 'tesla': 100000,... 'mac': 3000,... 'lenovo': 30000,... 'chicken': 10,... &#125;&gt;&gt;&gt; msg_dic.keys()dict_keys(['apple', 'tesla', 'mac', 'lenovo', 'chicken']) # 一只有5个鸡蛋的老母鸡&gt;&gt;&gt; res = msg_dic.keys()&gt;&gt;&gt; type(res)&lt;class 'dict_keys'&gt;&gt;&gt;&gt; type(res) is listFalse&gt;&gt;&gt; 123456789101112for k in msg_dic.keys(): # 这种方式比较鸡肋，不加 .keys() 默认是循环 key print(k)等于for k in msg_dic: print(k)# 输出结果appleteslamaclenovochicken 1234567891011121314151617msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;for v in msg_dic.values(): # 只获取value print(v)# 输出结果1010000030003000010 12345678910for x in msg_dic.items(): # 获取 key 和 value print(x)# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]# 输出结果('apple', 10)('tesla', 100000)('mac', 3000)('lenovo', 30000)('chicken', 10) 12345678910# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]for x in msg_dic.items(): print(x[0], x[1])# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 12345678910# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]# k, v = ('apple', 10)for k, v in msg_dic.items(): print(k, v)# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 循环（循环取值）12345678910111213d = &#123;'name': 'egon', 'age': 18&#125;for k in d: # d 不加 .keys() 默认也是取 key print(k)# 输出结果nameaged = &#123;'name': 'egon', 'age': 18&#125;for k in d: print(k, d[k])# 输出结果name egonage 18 1234567891011121314151617msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;for k in msg_dic: print(k, msg_dic[k])# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 内置方法1234567891011121314151617181920212223242526msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;print(msg_dic['applexxxxx']) # key 不存在的情况下，会报错# 输出结果KeyError: 'applexxxxx'if 'applexxxxx' in msg_dic: # 利用 if 判断 key 是否存在 print(msg_dic['applexxxxx'])else: print(None)# 代码比较多print(msg_dic.get('applexxxxx')) # key 不存在的情况下，默认返回None# 输出结果None# 也可以自定义返回值print(msg_dic.get('applexxxxx', 'xxxxx'))# 输出结果xxxxx dict.get() 取值12345678910111213141516d = &#123;'name': 'egon', 'age': 18&#125;d['sex']# 输出结果KeyError: 'sex'# 为了避免这种问题res = d.get('sex', '没有这个key')print(res)# 输出结果没有这个keyd = &#123;'name': 'egon', 'age': 18&#125;res = d.get('name', None) # 通常写Noneprint(res)# 输出结果egon dict.popitem() 随机删除123456d = &#123;'name': 'egon', 'age': 18&#125;res = print(d.popitem()) # 随机删，将删除的内容以元组格式返回print(d, res)# 输出结果&#123;'name': 'egon'&#125; ('age': 18) dict.update() 更新1234567891011d = &#123;'name': 'egon', 'age': 18&#125;d.update(&#123;'x': 1, 'name': 'EGON'&#125;) # 老字典 d 没有的则添加，有的则以新字典为准进行修改print(d)# 输出结果&#123;'name': 'EGON', 'age': 18, 'x': 1&#125;d1 = &#123;'x': 1, 'y': 2&#125;d1.update(&#123;'x': 2, 'z': 3&#125;) # 有原值就更新，没有的就新增print(d1)# 输出结果&#123;'x': 2, 'y': 2, 'z': 3&#125; dict.setdefault() 有则不改，无则增加123456789101112131415161718d = &#123;'name': 'egon', 'age': 18&#125;res = d.setdefault('name': 'EGON'&#125;) # 当key存在时，不修改值，会返回原值print(res)# 输出结果egond = &#123;'name': 'egon', 'age': 18&#125;res = d.setdefault('sex': 'male'&#125;) # 当key不存在时，则新增一个元素，会返回一个新值print(res)# 输出结果maled = &#123;'name': 'egon', 'age': 18&#125;d.setdefault('name': 'EGON'&#125;) # 当key存在时，不修改值d.setdefault('sex': 'male'&#125;) # 当key不存在时，则新增一个元素print(d)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; 12345678910&#123;&#125;.setdefault() # 有则不改，无则增加d = &#123;'x': 1, 'y': 2&#125;d.setdefault('x', 1000) # 当key存在时 则不改变 key 对应的值，返回原值res = d.setdefault('x', 1000)print(d)print(res)# 输出结果&#123;'x': 1, 'y': 2&#125;1 123456789d = &#123;'x': 1, 'y': 2&#125;d.setdefault('z', 1000) # key不存在 则增加一个 key:value，返回新增的valueres = d.setdefault('z', 1000)print(d)print(res)# 输出结果&#123;'x': 1, 'y': 2, 'z': 1000&#125;1000 1234567891011121314151617181920212223242526272829303132333435# 统计单词个数统计 s = 'hello alex alex say hello sb sb' 中每个单词的个数结果如：&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;s = 'hello alex alex say hello sb sb'words = s.split()print(words)# 输出结果['hello', 'alex', 'alex', 'say', 'hello', 'sb', 'sb']d = &#123;&#125;for word in words: if word not in d: d[word] = 1 else: d[word] += 1# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;d = &#123;&#125;words = s.split()for word in words: # print(word, words.count(word)) d[word] = words.count(word)print(d)# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;d = &#123;&#125;words = s.split()for word in words: d.setdefault(word, words.count(word))print(d)# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125; dict.fromkeys 用于字典的初始化，快速造出字典123456789101112131415161718192021222324252627282930&#123;&#125;.fromkeys(序列类型, 值)序列类型：有索引的类型（字符串，列表，元组）# 用于字典的初始化# items = ['name', 'age', 'sex']items = ('name', 'age', 'sex')dic = d.fromkeys(items, None)print(dic)# 输出结果&#123;'name': None, 'age': None, 'sex': None&#125;d = &#123;&#125;.fromkeys(['name', 'age', 'sex'], '初始值')print(d)# 输出结果&#123;'name': '初始值', 'age': '初始值', 'sex': '初始值'&#125;info = &#123;&#125;.fromkeys('hello', None)print(info)# 输出结果&#123;'h': None, 'e': None, 'l', None, 'o', None&#125;# 字典key 不能重复，所以这里只有一个 l# 实现 不用 formkeys，从以下元组中取出没一个元素，造一个字典items = ('name', 'age', 'sex')dic = &#123;&#125;for item in items: dic[item] = Noneprint(dic)# 输出结果&#123;'name': None, 'age': None, 'sex': None&#125; dict 字典类型总结 能存多个值，没有类型限制 无序（能够按索引取值的属于有序） 可变类型可变：值变，id不变。可变==不可hash 参考文档http://www.cnblogs.com/linhaifeng/articles/7133357.html#_label6]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python字典类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS禁止密码登录]]></title>
    <url>%2F2018%2F07%2F03%2FCentOS%E7%A6%81%E6%AD%A2%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[CentOS 禁止密码登录 允许 sshkey 密钥登录，禁止密码登录 编辑 SSH 配置文件12345678910111213141516vim /etc/ssh/sshd_config# 找到以下配置项#RSAAuthentication yes#PubkeyAuthentication yes#AuthorizedKeysFile .ssh/authorized_keys# 去调上面 3 行前面的 (#)注释# 找到下面 1 行PasswordAuthentication yesPermitRootLogin yes# 修改为PasswordAuthentication no # 禁止密码登录PermitRootLogin no # 禁止 root 登录PermitRootLogin without-password # 禁止 root 密码登录 重启 SSH 服务12systemctl reload sshdsystemctl -l status sshd 参考文档https://blog.csdn.net/u013372487/article/details/71307323]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>CentOS禁止密码登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper可视化界面zkui搭建与配置]]></title>
    <url>%2F2018%2F06%2F28%2FZookeeper%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2zkui%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Zookeeper可视化界面zkui搭建与配置一个允许在 Zookeeper 上进行 CRUD 操作的 UI 控制面板。 下载地址https://github.com/DeemOpen/zkui 运行环境jdk 7 初始化环境 zkui 是基于 java 语言开发，首先就要我们安装 jdk 环境。因为 zkui 需要我们手工进行编译、构建和打包，所以还需要安装 maven 环境。 安装 jdk1.712tar -zxvf jdk-7u80-linux-x64.tar.gz -C /data/chown -R root:root /data/jdk1.7.0_80/ 添加环境变量12345678910cat &gt;&gt; /etc/profile.d/jdk.sh &lt;&lt; “EOF”#!/bin/bashexport JAVA_HOME=/data/jdk1.7.0_80export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binEOFsource /etc/profilejava –version 生成 zkui 的 jar 包 zkui 的源码包，我们可以在 github 上进行下载https://github.com/DeemOpen/zkui.git1234567cd /data/tools/git clone https://github.com/DeemOpen/zkui.gitcd zkui/ll -h# 使用 mvn 命令进行编译构建打包mvn clean install 可以看到 maven 打包后生成了 zkui-2.0-SNAPSHOT.jar 和 zkui-2.0-SNAPSHOT-jar-with-dependencies.jar 两个文件，其中 zkui-2.0-SNAPSHOT-jar-with-dependencies.jar 是我们需要的 jar 文件。 启动 zkui zkui 运行的 jar 文件生成后，我们就可以直接运行该文件了。在运行该文件之前，我们还需要修改 zkui 的配置文件 config.cfg。config.cfg 文件中配置了，zkui 需要连接的 zookeeper 集群的 IP 地址和端口，访问 ui 的用户名和密码，以及 zkui 监听的端口号 123456789cd zkui/vim config.cfgserverPort=9090 # Web服务端口zkServer=10.1.1.127:2181,10.1.1.128:2181,10.1.1.129:2181 # 一个或多个 Zookeeper 节点地址ldapAuth=falseldapDomain=mycompany,mydomainldapUrl=ldap://&lt;ldap_host&gt;:&lt;ldap_port&gt;/dc=mycom,dc=comldapRoleSet=&#123;"users": [&#123; "username":"domain\\user1" , "role": "ADMIN" &#125;]&#125;userSet = &#123;"users": [&#123; "username":"admin" , "password":"manager","role": "ADMIN" &#125;,&#123; "username":"appconfig" , "password":"appconfig","role": "USER" &#125;]&#125; 默认用户信息 用户名：Admin（Admin权限，支持CRUD操作）密码：manager用户名：appconfig（Readonly权限，支持读取操作）密码：appconfig LDAP 配置 如果你想使用 LDAP 身份验证，则提供 LDAP url。这将优先于 roleSet property 文件认证。ldapUrl=ldap://&lt;ldap_host&gt;:&lt;ldap_port&gt;/dc=mycom,dc=com如果不提供此功能，则将使用默认 roleSet 文件认证。 12nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &gt; /data/app/zkui/logs/stdout.log 2&gt;&amp;1 &amp;netstat -tunlp | grep 9090 访问 http://x.x.x.x:9090 参考文档https://www.ilanni.com/?p=13646]]></content>
      <categories>
        <category>Zookeeper笔记</category>
      </categories>
      <tags>
        <tag>Zookeeper可视化界面zkui搭建与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ集群安装与配置]]></title>
    <url>%2F2018%2F06%2F27%2FActiveMQ%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ActiveMQ集群安装与配置ActiveMQ 集群是依赖于 ZooKeeper 集群而存在的在此我们把 ZooKeeper 集群和 ActiveMQ 集群安装在同样三台机器上。 ActiveMQ 集群原理 ActiveMQ 集群原理，使用 ZooKeeper 集群注册所有的 ActiveMQ Broker。只有其中的一个 Broker 可以对外提供服务，被视为 master。而其他的 Broker 处于待机状态，被视为 slave。而此时 slave 只是做数据的主从同步。 如果 master 因故障而不能提供服务，ZooKeeper 集群会从 slave 中选举出一个Broker 充当 master。slave 连接 master 并同步它们的存储状态，slave 不接受客户端连接。所有的存储操作都将被复制到连接至 master 的 slave 上。 如果 master 宕机了，得到了最新更新的 slave 会成为 master。而故障节点在恢复后会重新加入到集群中并连接 master 进入 slave 模式。 需要同步的消息操作都将等待存储状态被复制到其他节点的操作完成后才能完成。 所以，如果你配置了 replicas=3，那么假定大小是 (3/2)+1=2。master 将会存储并更新然后等待 (2-1)=1 个 slave 存储和更新完成，才汇报 success。 至于为什么是 2-1，熟悉 ZooKeeper 集群的应该知道，有一个 node 要作为观擦者存在。当一个新的 master 被选中，你需要至少保障一个假定 node 在线以能够找到拥有最新状态的 node。这个 node 可以成为新的 Master。因此，推荐运行至少 3 个 replica nodes，以防一个 node 失败了，服务中断。（原理与 Zookeeper 集群的高可用实现方式类似）。 初始化环境 至少需要三台机器，这三台机器都已经安装 ActiveMQ 服务，ZooKeeper 集群也已经配置完毕。这三台机器的 IP 分别为 10.1.1.127，10.1.1.128，10.1.1.129 查看 ZooKeeper 集群的情况1/data/app/zookeeper/bin/zkServer.sh status 环境初始化完毕后，开始配置 ActiveMQ 集群。 配置 ActiveMQ 集群 ActiveMQ 集群的配置比较简单，我们只需要修改 ActiveMQ 的配置文件 activemq.xml 中部分内容即可。ActiveMQ 根目录下的 conf/activemq.xml 文件，原来默认内容如下：1234vim conf/activemq.xml +81&lt;persistenceAdapter&gt;&lt;kahaDB directory=”$&#123;activemq.data&#125;/kahadb”/&gt;&lt;/persistenceAdapter&gt; 修改后的内容如下：12345678910111213vim conf/activemq.xml +81&lt;persistenceAdapter&gt;&lt;replicatedLevelDBdirectory=”$&#123;activemq.data&#125;/leveldb”replicas=”3″bind=”tcp://0.0.0.0:0″zkAddress=”10.1.1.127:2181,10.1.1.128:2181,10.1.1.129:2181″zkSessionTimeout=”4s”hostname=”10.1.1.127″sync=”local_disk”zkPath=”/activemq/leveldb-stores”/&gt;&lt;/persistenceAdapter&gt; 配置的含义解释如下：directory：表示 ActiveMQ 集群消息持久化保存到服务器上的路径，注意该路径一定要先创建好。replicas：表示 ActiveMQ 集群的节点个数。bind：表示当这个节点成为 master 后，绑定的机器的地址与端口。此处 0.0.0.0:0 表示绑定到本机所有可用 IP，而端口是随机的。zkAddress：表示 ZooKeeper 的 IP 和 port。如果是 ZooKeeper 集群的话，则用逗号隔开。zkSessionTimeout：表示 ActiveMQ 与 ZooKeeper 集群连接的会话超时时间。hostname：表示本机的 IP 地址。服务器根据不同的 IP 地址做出改变，其他配置相同。sync：在消息被消费完成前，同步信息所存贮的策略。如果有多种策略用逗号隔开，ActiveMQ 会选择较强的策略。而如果有 local_mem，local_disk 这两种策略的话，那么 ActiveMQ 则优先选择 local_disk 策略，存储在本地硬盘。zkPath：表示 ActiveMQ 在 ZooKeeper 集群上创建的 znode 节点的路径，也即是ZooKeeper 选举信息交换的存贮路径。注意：这 3 个 ActiveMQ 节点中的 brokerName 配置必须相同，否则不能加入集群。 启动 ActiveMQ 集群 ActiveMQ 集群配置完毕后，我们现在来启动 ActiveMQ 集群。但是在正式启动 ActiveMQ 集群之前，一定要先启动 ZooKeeper集群。 要启动 ActiveMQ 集群，我们只需要启动这 3 台服务器的 ActiveMQ 服务即可。如下：12/data/app/activemq/bin/activemq startps -ef | grep mq ActiveMQ 集群启动完毕，根据 ZooKeeper 的策略，会从这三台 ActiveMQ 服务器选一台作为 master 对外提供服务，其他两台作为 slave 等待运行，而 slave 只是做数据上的主从同步。 所以，ActiveMQ 集群后，访问http://10.1.1.127:8161/admin/http://10.1.1.128:8161/admin/http://10.1.1.129:8161/admin/只会有一个成功 那么现在在 ActiveMQ 集群中，如何查看哪一台服务器是 master 节点呢？我们可以通过查看这三台服务器哪一台服务器监听 8161 端口，来判断哪台服务器是 master 节点。 现在在切换到服务器上查看监听的端口，如下：1netstat -tunlp | grep 8161 可以很明显的看出，目前只有 10.1.1.127 这台服务器监听 8161 端口的。那就说明目前10.1.1.127 是 master 节点。其他两个节点是 slave 节点，处于待机状态，没有监听 8161 端口。 现在我们再来看访问 10.1.1.127 服务器 ActiveMQ 管理控制台看看，如下：http://10.1.1.127:8161/admin到此说明 ActiveMQ 集群已经部署完毕。 验证 ActiveMQ 集群高可用 要验证 ActiveMQ 集群的高可用，我们只需要关闭能访问http://x.x.x.x:8161/admin/ 的 ActiveMQ 服务，然后访问其他两个。 如果其中有一个能访问，那就说明 ActiveMQ+ZooKeeper 集群高可用已经配置成功。通过第四章节，我们知道目前 master 节点是 10.1.1.127 这台服务器。现在我们来关闭10.1.1.127 这台服务器的 ActiveMQ 服务，看看 ActiveMQ 集群，是否能正常访问。如下： 12ps -ef | grep mqkill -9 3889 我们已经把 10.1.1.127 这台服务器的 ActiveMQ 服务已经关闭了。现在我们再来看看目前哪台服务器是 master 节，也即是查看哪台服务器的 8161 端口对外提供服务器。如下：12netstat -tunlp | rep 8161ps -ef | rep mq 可以很明显的看出目前 10.1.1.128 这台服务器是 master 节点。现在我再来通过管理控制台访问10.1.1.128 的 8161 端口看看。如下：http://10.1.1.128:8161/admin/ 我们可以很明显的看出 10.1.1.127 这台服务器的 ActiveMQ 服务停止后，并没有影响 ActiveMQ 集群的正常运行。这也就说明了 ActiveMQ 集群是正常工作的。到此，有关 ActiveMQ 集群的搭建与配置已经全部完毕。 参考文档https://www.ilanni.com/?p=13569]]></content>
      <categories>
        <category>ActiveMQ笔记</category>
      </categories>
      <tags>
        <tag>ActiveMQ集群安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ安装与配置]]></title>
    <url>%2F2018%2F06%2F27%2FActiveMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ActiveMQ安装与配置 操作系统 CentOS7建议 ActiveMQ 集群 和 Zookeeper 集群部署在同一台服务器上，否则随着时间的增加，ActiveMQ 集群容易出现假死的情况。 JMS 支持的消息传递模型 JMS 支持两种消息传递模型：队列（Queue）和 主题（Topic）。 点对点传递模型 点对点（point-to-point，简称 PTP）Queue 消息传递模型。 通过该消息传递模型，一个应用程序（即消息生产者）可以向另外一个应用程序（即消息消费者）发送消息。 在此传递模型中，消息目的地类型是队列（即 Destination 接口实现类实例由 Session 接口实现类实例通过调用其 createQueue 方法并传入队列名称而创建）。 消息首先被传送至消息服务器端特定的队列中，然后从此对列中将消息传送至对此队列进行监听的某个消费者。同一个队列可以关联多个消息生产者和消息消费者，但一条消息仅能传递给一个消息消费者。 如果多个消息消费者正在监听队列上的消息，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。 如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。这种消息传递模型是传统意义上的懒模型或轮询模型。 在此模型中，消息不是自动推动给消息消费者的，而是要由消息消费者从队列中请求获得。 发布/订阅传递模型 发布/订阅（publish/subscribe，简称 pub/sub）Topic 消息传递模型。 通过该消息传递模型，应用程序能够将一条消息发送给多个消息消费者。在此传送模型中，消息目的地类型是主题（即 Destination 接口实现类实例由 Session 接口实现类实例通过调用其 createTopic 方法并传入主题名称而创建）。 消息首先由消息生产者发布至消息服务器中特定的主题中，然后由消息服务器将消息传送至所有已订阅此主题的消费者。 主题目标也支持长期订阅。长期订阅表示消费者已注册了主题目标，但在消息到达目标时该消费者可以处于非活动状态。 当消费者再次处于活动状态时，将会接收该消息。如果消费者均没有注册某个主题目标，该主题只保留注册了长期订阅的非活动消费者的消息。 与 PTP 消息传递模型不同，pub/sub 消息传递模型允许多个主题订阅者接收同一条消息。JMS 一直保留消息，直至所有主题订阅者都接收到消息为止。 pub/sub 消息传递模型基本上是一个推模型。在该模型中，消息会自动广播，消息消费者无须通过主动请求或轮询主题的方法来获得新的消息。 具体区别对比如下 类型 Topic Queue 概要 Publish Subscribe messaging 发布订阅消息 Point-to-Point 点对点 有无状态 Topic 数据默认不落地，是无状态的。 Queue 数据默认会在 mq 服务器上以文件形式保存，比如Active MQ 一般保存在 $AMQ_HOME/data/kr-store/data 下面。也可以配置成 DB 存储。 完整性保障 并不保证 publisher 发布的每条数据，Subscriber 都能接受到。 Queue 保证每条数据都能被 receiver 接收。 消息是否会丢失 一般来说 publisher 发布消息到某一个 topic 时，只有正在监听该 topic 地址的 sub 能够接收到消息；如果没有 sub 在监听，该 topic 就丢失了。 Sender 发送消息到目标 Queue，receiver 可以异步接收这个 Queue 上的消息。Queue 上的消息如果暂时没有 receiver 来取，也不会丢失。 消息发布接收策略 一对多的消息发布接收策略，监听同一个 topic 地址的多个 sub 都能收到 publisher 发送的消息。Sub 接收完通知 mq 服务器。 一对一的消息发布接收策略，一个 sender 发送的消息，只能有一个 receiver 接收。receiver 接收完后，通知 mq 服务器已接收，mq 服务器对 queue 里的消息采取删除或其他操作。 初始化环境在此我们安装的是 ActiveMQ 5.14.5，ActiveMQ 5.14.5 使用的是 jdk1.7。ActiveMQ 5.15.0 使用的是 jdk1.8。 安装 jdk1.71234cd /data/tools/wget -c http://mirrors.linuxeye.com/jdk/jdk-7u80-linux-x64.tar.gztar -zxvf jdk-7u80-linux-x64.tar.gz -C /data/chown -R root:root /data/jdk1.7.0_80 添加环境变量123456vim /etc/profileexport JAVA_HOME=/data/jdk1.7.0_80export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binsource /etc/profilejava -version 关闭 防火墙 和 selinux，同步服务器时间123456ntpdate -u cn.ntp.org.cnsed -i ‘/SELINUX/s/enforcing/disabled/’ /etc/selinux/configsetenforce 0systemctl disable firewalld.servicesystemctl stop firewalld.serviceshutdown -r now 安装 ActiveMQ ActiveMQ 官网http://activemq.apache.org/ 下载 ActiveMQhttp://activemq.apache.org/download.htmlhttp://archive.apache.org/dist/activemq/ 下载 ActiveMQ5.14.51234mkdir -pv /data/app/activemqcd /data/tools/wget -c http://mirrors.hust.edu.cn/apache/activemq/5.14.5/apache-activemq-5.14.5-bin.tar.gztar -zxvf apache-activemq-5.14.5-bin.tar.gz -C /data/app/activemq –strip-components 1 查看 ActiveMQ 目录结构1ll -h 文件名/目录名 详解 activemq-all-5.14.5.jar ActiveMQ 所有 jar bin ActiveMQ 启动命令的二进制执行文件及一些命令脚本 conf ActiveMQ 配置目录，包含最基本的 ActiveMQ 配置文件 data ActiveMQ 数据目录，默认为空。包含 ActiveMQ 的进程文件、数据文件、日志文件。该目录也是 ActiveMQ 消息持久化的目录 docs 用户使用帮助相关文件 examples 操作 ActiveMQ 相关实例 lib ActiveMQ 需要的类库 webapps ActiveMQ 控制台应用目录 webapps-demo ActiveMQ 使用实例目录 LICENSE ActiveMQ 所有包使用的 Apache 开源消息协议 NOTICE ActiveMQ 版权信息 README 用户使用引导文件，包括一些文档及 URL 启动 ActiveMQ12/data/app/activemq/bin/activemq starttail -f /data/app/activemq/data/activemq.log ActiveMQ 启动方式 普通启动1/data/app/activemq/bin/activemq start 后台启动并指定日志文件1nohup /data/app/activemq/bin/activemq start &gt; /data/app/activemq/logs/smlog 2&gt;&amp;1 &amp; ActiveMQ 管理控制台 ActiveMQ 默认的管理后台端口是 8161，默认管理用户名和密码均是 admin。ActiveMQ 默认的管理后台端口，可以在 ActiveMQ 的配置文件 jetty.xml 中查看到12vim /data/app/activemq/conf/jetty.xml +110&lt;property name=”port” value=”8161″/&gt; ActiveMQ 默认管理用户名和密码均是 admin，如果要修改默认用户名和密码的话，可以通过修改 jetty-realm.properties 文件来达到目的123vim /data/app/activemq/conf/jetty-realm.propertiesadmin: password@123, adminuser: user@123, user 注意：ActiveMQ 用户名和密码的格式是1username: password, rolename 登陆管理控制台http://x.x.x.x:8161/admin 管理控制台介绍 在 ActiveMQ 的管理控制台，关注比较多的是 Queues队列 和 Topics主题。 Queues队列 选项 字段 详解 Number Of Pending Messages 表示还有多少条消息没有被消费，实际上是表示消息的积压程度。 Number Of Consumers 表示在该队列上还有多少消费者在等待接受消息。其实就是消费者的数量。 Messages Enqueued 表示生产了多少条消息。 Messages Dequeued 表示消费了多少条消息。 Topics主题 选项 字段 详解 Number Of Consumers 表示在该队列上还有多少消费者在等待接受消息。 Messages Enqueued 表示生产了多少条消息。 Messages Dequeued 表示消费了多少条消息。 参考文档https://www.ilanni.com/?p=13543]]></content>
      <categories>
        <category>ActiveMQ笔记</category>
      </categories>
      <tags>
        <tag>ActiveMQ安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os模块]]></title>
    <url>%2F2018%2F06%2F21%2Fos%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os 模块 os 模块是与操作系统交互的一个接口 模块方法 注释 os.getcwd() 获取当前工作目录，即当前 python 脚本工作的目录路径 os.chdir(&quot;dirname&quot;) 改变当前脚本工作目录；相当于 shell 下 cd os.curdir 返回当前目录: (&#39;.&#39;) os.pardir 获取当前目录的父目录字符串名：(&#39;..&#39;) os.makedirs(&#39;dirname1/dirname2&#39;) 可生成多层递归目录 os.removedirs(&#39;dirname1&#39;) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(&#39;dirname&#39;) 生成单级目录；相当于 shell 中 mkdir dirname os.rmdir(&#39;dirname&#39;) 删除单级空目录，若目录不为空则无法删除，报错；相当于 shell 中 rmdir dirname os.listdir(&#39;dirname&#39;) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录 os.stat(&#39;path/filename&#39;) 获取文件/目录信息 os.sep 输出操作系统特定的路径分隔符，Windows下为&quot;\\&quot;，Linux下为&quot;/&quot; os.linesep 输出当前平台使用的行终止符，Windows下为&quot;\t\n&quot;，Linux下为&quot;\n&quot; os.pathsep 输出用于分割文件路径的字符串，Windows下为;，Linux下为: os.name 输出字符串指示当前使用平台。Windows-&gt;&#39;nt&#39;，Linux-&gt;&#39;posix&#39; os.system(&quot;bash command&quot;) 运行shell命令，直接显示 os.environ 获取系统环境变量 os.path.abspath(path) 返回 path 规范化的绝对路径 os.path.split(path) 将 path 分割成目录和文件名二元组返回 os.path.dirname(path) 返回 path 的目录。其实就是 os.path.split(path) 的第一个元素 os.path.basename(path) 返回 path 最后的文件名。如何 path 以 / 或 \ 结尾，那么就会返回空值。即 os.path.split(path) 的第二个元素 os.path.exists(path) 如果 path 存在，返回 True；如果 path 不存在，返回 False os.path.isabs(path) 如果 path 是绝对路径，返回 True os.path.isfile(path) 如果 path 是一个存在的文件，返回 True。否则返回 False os.path.isdir(path) 如果 path 是一个存在的目录，则返回 True。否则返回 False os.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回 path 所指向的文件或者目录的最后存取时间 os.path.getmtime(path) 返回 path 所指向的文件或者目录的最后修改时间 os.path.getsize(path) 返回 path 的大小 列出指定目录下的所有文件和子目录 包括隐藏文件，并以列表方式打印 12345import osprint(os.listdir(r'.'))# 输出结果['01 时间模块.py', '02 random模块.py', '03 os模块.py', '今日内容.txt'] 获取 文件/目录 信息12345678910import osprint(os.stat('今日内容.txt'))# 输出结果os.stat_result(st_mode=33206, st_ino=4503599627409980, st_dev=239211959, st_nlink=1, st_uid=0, st_gid=0, st_size=280, st_atime=1526694304, st_mtime=1526694304, st_ctime=1526694102)# 获取文件大小，以 bytes 为单位print(os.stat('今日内容.txt').st_size)# 输出结果280 获取 文件 大小信息12345import osprint(os.path.getsize(r'E:\PycharmProjects\SH_s1\day07\今日内容.txt'))# 输出结果280 os.system(&quot;bash command&quot;) 方法 运行shell命令，直接显示 123456789import osos.system('tasklist') # 输出 Windows 下当前所有进程列表# os.system() 只是单纯的执行命令，并不能把命令执行后的结果做进一步的处理res = os.system('tasklist')print('res----&gt;', res) # res变量只是命令的执行成功与否的执行状态# 输出结果res----&gt; 0 os.environ 方法 获取系统环境变量 123456789全局的用于在程序任何地方都需要用到它的结果的时候import osos.environ['login'] = 'yes'print(os.environ['login'])# 输出结果yes os.path.split(path) 方法 将 path 分割成 目录 和 文件名 二元组返回 12345678910print(os.path.split('/a/b/c/d.txt'))# 输出结果('/a/b/c', 'd.txt')print(os.path.split('/a/b/c/d.txt')[0])print(os.path.split('/a/b/c/d.txt')[1])# 输出结果/a/b/cd.txt os.path.dirname(path) 方法 返回 path 的 目录其实就是 os.path.split(path) 的第一个元素 123print(os.path.dirname('a/b/c/d.txt'))# 输出结果a/b/c os.path.basename(path) 方法 返回 path 最后的 文件名如何 path 以 / 或 \ 结尾，那么就会返回空值即 os.path.split(path) 的第二个元素 123print(os.path.basename('a/b/c/d.txt'))# 输出结果d.txt os.path.join(path1[, path2[, …]]) 方法 用于拼接路径将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 123print(os.path.join('a', 'b', 'c', 'd.txt'))# 输出结果a\b\c\d.txt 123print(os.path.join('a', 'b', 'D:\\', 'c', 'd.txt'))# 输出结果D:\c\d.txt 123print(os.path.join('a', 'b', 'd', 'c', '/', 'd.txt'))# 输出结果/d.txt os.path.normcase(path) 方法 只用于 Windows 系统，规范 Windows 目录在 Windows 平台上会将路径中所有字符转换为小写，将路径中的左斜杠转换为 Windows 中的右斜杠在 Linux 和 Mac 平台上，该函数会原样返回 path 123print(os.path.normcase('c:/windOws\\system32\\'))# 输出结果c:\windows\system32\ os.path.normpath(path) 方法 用于规范路径如 (..) 点点 (/) 斜杠 123456789101112print(os.path.normpath('c:\\windOws/a/b/../system32\\'))# 输出结果c:\windOws\a\system32print(os.path.normpath('c://windows\\System32\\../Temp/'))# 输出结果c:\windows\Tempa = '/Users/jieli/test1/\\\a1/\\\\aa.py/../..'print(os.path.normpath(a))# 输出结果/Users/jieli/test1 os 路径处理 常用路径处理方法 123os.path.dirname(os.path.dirname(os.path.abspath(__file__)))os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) OpenStack 中获取路径方式 1234567891011121314151617181920OpenStack 获取路径方式res = os.path.join( os.path.abspath(__file__), '..', '..')print(res)print(os.path.normpath(res))# 输出结果E:\PycharmProjects\SH_s1\day07\03 os模块.py\..\..E:\PycharmProjects\SH_s1# 合并一下print(os.path.normpath( os.path.join( os.path.abspath(__file__), '..', '..' ))) 12345678910import osimport os,syspossible_topdir = os.path.normpath(os.path.join( os.path.abspath(__file__), os.pardir, # 上一级 os.pardir, os.pardir))sys.path.insert(0, possible_topdir) 参考文档http://www.cnblogs.com/linhaifeng/articles/6384466.html#_label3]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>os模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调整Linux的网络栈Buffer_Size来提升网络性能]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%B0%83%E6%95%B4Linux%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A0%88Buffer_Size%E6%9D%A5%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[调整 Linux 的网络栈 Buffer Size 来提升网络性能 有两台位于不同数据中心的服务器，都用来处理很多并行的大文件传输。但是处理大文件，网络性能非常差。并且涉及到一个大文件，会导致性能降级。怎样通过调整 Linux下面的 TCP 来解决这个问题？ 默认，Linux 的 stack 是没有为广域网之间的大文件高速传输而配置的，这样做是为了节约内存资源。为了使连接的系统服务之间能有更加高速的网络处理更多的网络包，你可以很容易的通过增加网络 buffer size 来调整 Linux 网络 stack。 默认的 Linux buffer size 的最大值是非常小的，tcp 的内存是基于系统的内存自动计算的，你能通过键入以下命令找到实际的值 1cat /proc/sys/net/ipv4/tcp_mem 默认的和最大的接收数据包内存大小 12cat /proc/sys/net/core/rmem_defaultcat /proc/sys/net/core/rmem_max 默认的和最大的发送数据包内存的大小 12cat /proc/sys/net/core/wmem_defaultcat /proc/sys/net/core/wmem_max 最大的内存 buffers 的选项 1cat /proc/sys/net/core/optmem_max 调整值 为所有的协议队列设置操作系统层面的最大的发送 buffer size(wmem) 和 接收 buffer size (rmem)为 12MB。换句话说，设置内存数量，分配给每一个为了传送文件而打开或者是创建的 tcp socket。 警告！在大多数的 Linux 中 rmem_max 和 wmem_max 被分配的值为 128k，在一个低延迟的网络环境中，或者是 apps 比如 DNS、Web Server，这或许是足够的。尽管如此，如果延迟太大，默认的值可能就太小了，所以请记录以下在你的服务器上用来提高内存使用方法的设置。 12echo 'net.core.wmem_max=12582912' &gt;&gt; /etc/sysctl.confecho 'net.core.rmem_max=12582912' &gt;&gt; /etc/sysctl.conf 还需要设置 minimum size, initial size, and maximum size in bytes 12echo 'net.ipv4.tcp_rmem= 10240 87380 12582912' &gt;&gt; /etc/sysctl.confecho 'net.ipv4.tcp_wmem= 10240 87380 12582912' &gt;&gt; /etc/sysctl.conf 打开 window scaling，这是一个用来扩展传输窗口的选项 1echo 'net.ipv4.tcp_window_scaling = 1' &gt;&gt; /etc/sysctl.conf 确保定义在 RFC1323 中的 timestamps 打开 1echo 'net.ipv4.tcp_timestamps = 1' &gt;&gt; /etc/sysctl.conf 确保 select acknowledgments 1echo 'net.ipv4.tcp_sack = 1' &gt;&gt; /etc/sysctl.conf 这个 “select acknowledgments” 不知道该如何翻译，翻译为“选择确认？” 当连接关闭的时候，TCP 默认缓存了很多连接指标在 route cache 中，以至于在不久的将来，连接建立的时候，可以用这些值来设置初始化条件。通常，这提升了整体的性能，但是，有时候会引起性能下降， 如果设置的话，TCP 在关闭的时候不缓存这些指标。 1echo 'net.ipv4.tcp_no_metrics_save = 1' &gt;&gt; /etc/sysctl.conf 当 interface 接收到的数据包数量比内核处理速度的快的时候， 设置 input 队列最大的 packets 数量值。 1echo 'net.core.netdev_max_backlog = 5000' &gt;&gt; /etc/sysctl.conf 现在重载这些改变，使其生效 1sysctl -p 使用 tcpdump 命令查看 通过 eth0 数据包流量的变化 1tcpdump -ni eth0 参考文档https://segmentfault.com/a/1190000000473365 推荐阅读 请参考内核文档/networking/ip-sysctl.txt获取更加多的信息 请查看 sysctl 的 man 手册]]></content>
      <categories>
        <category>Linux内核优化笔记</category>
      </categories>
      <tags>
        <tag>调整Linux的网络栈Buffer_Size来提升网络性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat中Connector常用配置]]></title>
    <url>%2F2018%2F06%2F15%2FTomcat%E4%B8%ADConnector%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Tomcat 中 Connector 常用配置 模式 描述 BIO 阻塞式 I/O，采用传统的 java I/O 进行操作，该模式下每个请求都会创建一个线程，适用于并发量小的场景 NIO 同步非阻塞，比传统 BIO 能更好的支持大并发，Tomcat 8.0 后默认采用该模式 APR Tomcat 以JNI形式调用http服务器的核心动态链接库来处理文件读取或网络传输操作，需要编译安装 APR 库 AIO 异步非阻塞，Tomcat 8.0 后支持 配置方法：在 tomcat/conf/ 下 server.xml 12345`&lt;Connector port="8080" protocol="HTTP/1.1"/&gt;`BIO: protocol="org.apache.coyote.http11.Http11Protocol"NIO: protocol="org.apache.coyote.http11.Http11NioProtocol"AIO: protocol="org.apache.coyote.http11.Http11Nio2Protocol"APR: protocol="org.apache.coyote.http11.Http11AprProtocol" BIO（blocking I/O） 阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作（即 java.io 包及其子包）。默认的模式，性能最差，没有经过任何优化处理和支持。 NIO（non-blocking I/O） Java SE 1.4 及后续版本提供的一种新的 I/O 操作方式（即 java.nio 包及其子包）。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API。拥有比传统 I/O 操作（BIO）更好的并发运行性能。要让 Tomcat 以 NIO 模式来运行，修改配置文件：tomcat/conf/server.xml 修改以下内容123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 修改 protocol 的值为 org.apache.coyote.http11.Http11NioProtocol1234&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; 重启 Tomcat 后生效 在 Tomcat 6.0 之后，提供了 NIO 的方式，可以有效的提升性能，特别是在大量长连接/数据上传+下载等 Web 应用中此时 portocal=”org.apache.coyote.http11.Http11NioProtocol”Tomcat 支持：BIO，NIO，NIO2，APR 四种 I/O 模式，Tomcat 8.5 之前 默认为 BIO Tomcat 8.5 and 9.0 have completely dropped the BIO connector.Tomcat 8.5 和 9.0 完全删除了 BIO 连接器默认 NIO 模式 对于互联网应用，我们应该在 NIO、NIO2 之间做选择，因为它能够有效的提升性能（主要是并发能力）其中 NIO2 即为 AIO，需要 JDK 1.7+、Linux 2.6+ 才能支持。BIO：JDK 1.5+，tomcat 5.x+NIO：JDK 1.6+，tomcat 6.x+NIO2：JDK 1.7+，tomcat 7.x+为了保守起见，我们暂且基于 NIO 模式 查看 Tomcat Connector 运行模式方法一：在 http://x.x.x.x:8080/manager/status 中查看服务器状态 方法二：根据 Tomcat 启动日志信息判断BIO12INFO: Initializing ProtocolHandler ["http-bio-8080"]Aug 04, 2015 10:20:35 PM org.apache.coyote.AbstractProtocol init NIO12INFO: Initializing ProtocolHandler ["http-nio-8080"]Aug 04, 2015 10:27:58 PM org.apache.coyote.AbstractProtocol init APR12INFO: Initializing ProtocolHandler ["http-apr-8080"]Aug 04, 2015 10:33:45 PM org.apache.coyote.AbstractProtocol init 整合Tomcat apr 设置环境变量方法一：在 tomcat/bin/catalina.sh 中增加1行在 echo “Using CATALINA_BASE: $CATALINA_BASE” 的上一行添加CATALINA_OPTS=”-Djava.library.path=/data/apr/lib” 方法二：在 /etc/profile 中加入1export CATALINA_OPTS=-Djava.library.path=/usr/local/apr/lib 使配置生效1source /etc/profile 修改配置文件1234567vim tomcat/conf/server.xml &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;# 修改 `protocol` 的值为 `org.apache.coyote.http11.Http11NioProtocol`&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; 重启 Tomcat，启动日志出现以下内容证明此时以 APR 模式启动 参考文档：https://blog.csdn.net/fd2025/article/details/80007435]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat中Connector常用配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回到页首按钮显示百分比]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%9B%9E%E5%88%B0%E9%A1%B5%E9%A6%96%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E7%99%BE%E5%88%86%E6%AF%94%2F</url>
    <content type="text"><![CDATA[回到页首按钮显示百分比 Back-to-top 按钮显示百分比 编辑配置文件 Next主题配置文件 /hexo/themes/next/_config.yml 12# Scroll percent label in b2t button. scrollpercent: false 将 scrollpercen: 的值改为 true 即可]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>回到页首按钮显示百分比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加在线联系]]></title>
    <url>%2F2018%2F06%2F10%2FHexo%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[Hexo添加在线联系 当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。 配置方法 首先到 DaoVoice 上注册一个账号，注册完成后会得到一个 app_idhttp://dashboard.daovoice.io 获取 appid 的步骤 在 DaoVoice 的应用设置 -&gt; 安装到网站中的找到自己的 app_id然后在主题 /next/layout/_partials/head.swig 文件中最后添加代码 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 主题配置文件中添加配置 在主题配置文件 /next/_config.yml 中添加相应的配置 123# Online contactdaovoice: truedaovoice_app_id: 这里输入前面获取的app_id 调整位置 最后聊天图标的位置可能和一些东西重叠这个使用可以在控制面板中应用设置 -&gt; 聊天设置里面设置相对右边和底部的位置 参考文档https://www.ezlippi.com/blog/2018/01/next-chat.htmlhttps://meta.tn/a/c40f12eb1b892bbb8cda053c03c688e3f20e4f642164080ef463cd4a7bc3b042http://www.niww.me/2018/03/02/hexo-daovoice/]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加在线联系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题背景]]></title>
    <url>%2F2018%2F06%2F10%2FNext%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Next主题背景个性化DIY 整理了一下博客，加个背景图片（BackGroundImage）调整一下视觉感官，背景图片 是动态变化的，每次刷新都会更新一张图 一个图片网站 分享一个非常 Nice 的图片网站，感觉这个国外的图片社区网站真的秒杀一众图片网站啊，不仅图片质量高，免费，而且还提供了随机拉取图片的服务 API，太赞，对于想实现动态背景，简直是福音https://source.unsplash.com/ 添加背景图片 修改 \themes\next\source\css\_custom\custom.styl 文件这个是 Next 故意留给用户自己个性化定制一些样式的文件，添加以下代码 123456body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; URL 括号中直接添加图片的地址链接，也可以置换成你所喜欢的任意图片。repeat、attachment、position 就是调整图片的位置，不重复出现、不滚动等。]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next主题背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加看板娘]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98%2F</url>
    <content type="text"><![CDATA[添加看板娘 实现效果 用 Git Bash Here 在站点根目录执行如下代码 12cd D:\hexo\npm install hexo-helper-live2d --save 然后打开 /themes/next/layout/_layout.swig 将下面代码放到 &lt;/body&gt; 之前{ { live2d() } }注意：由于官方更新了包，所以画删除线的不用做了 然后在这里可以看到一些已有的模型，记下想要的模型名字，使用安装命令https://huaji8.top/post/live2d-plugin-2.0/ 1npm install "模型的包名" 模型的包名 12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 以 hijiki 为例12345678910$ npm install "live2d-widget-model-hijiki" --savenpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)+ live2d-widget-model-hijiki@1.0.5added 1 package and audited 3800 packages in 8.046sfound 2 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for details$ npm install live2d-widget-model-tororo --save 在 配置文件 末尾添加代码 安装完成后，还需要在一些小小的修改在 _config.yml（Hexo站点 或 Next主题 皆可）中，加入以下内容 /blog/_config.yml或/blog/next/themes/_config.yml 123456789101112131415## 看板娘live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki display: position: right width: 150 height: 300 mobile: show: true # false 手机端不显示 详细配置1234567891011121314151617181920live2d: enable: true # 是否开启 scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url model: use: live2d-widget-model-wanko # 调用模型名，必须要先下载 display: position: right # 在博客的左边还是右边显示 width: 150 # 边框宽度 height: 300 # 边框高度 mobile: show: true # 是否在手机上显示 # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 根据需要可修改use:后的包名；调整长度和宽度；选择是否停用插件等。 参考文档https://wangyuyang.me/2018/04/06/对基于HEXO的NexT主题的美化/https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.mdhttps://alvabill.ml/hexo搭建个人博客-NexT主题优化/]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>添加看板娘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome自带的长截屏功能]]></title>
    <url>%2F2018%2F06%2F10%2FChrome%E8%87%AA%E5%B8%A6%E7%9A%84%E9%95%BF%E6%88%AA%E5%B1%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Chrome自带的长截屏功能 在 Google Chrome 里面，打开开发人员工具 按F12或网站上任意空白处右键 – 选择 “检查” 或者“审查元素” 快捷键 Ctrl + Shift + P，会看到右边的审查元素出现了一个输入框输入 screenshot 然后回车保存图片]]></content>
      <categories>
        <category>Chrome笔记</category>
      </categories>
      <tags>
        <tag>Chrome自带的长截屏功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chevereto图床]]></title>
    <url>%2F2018%2F06%2F10%2FChevereto%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[Chevereto图床 Chevereto 是一款采用 PHP 语言开发的网络相册脚本程序，支持多语言，提供中文语言包的下载的开源在线图片存储分享服务系统，支持本地上传和在线获取两种图像上传方式，并集成了 TinyURL 网址缩短服务。Chevereto 这套程序可以像 Discuz 或 WordPress 一样随意架设在任何空间上。而它的功能除了一般图片空间单纯的从电脑上传图片外，也支援利用网址也可以上传，最屌的是还有 TinyURL 的缩短网址的功能可以使用，因此这套 Chevereto 可以说是比市面上的图片空间好太多了。他是把图片上传到空间的，相信一般大家都一定会使用免费空间，在此建议大家在挑主机时尽可能使用 cPanel 的空间，因为可以使用 cPanel 特有的 「Cron Jobs」 来备份你上传的图片。 Chevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirements Clevereto 错误 404 解决方法 如果 Web服务 是 Nginx，基本第一步安装好后再次打开网站会出现 404 错误。因为 Chevereto 默认提供基于 Apache 环境的伪静态规则 需要设置以下 Rewrite 伪静态规则123456789101112131415location / &#123; if (-f $request_filename/index.html)&#123; rewrite (.*) $1/index.html break; &#125; if (-f $request_filename/index.php)&#123; rewrite (.*) $1/index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125; try_files $uri $uri/ /api.php;&#125;location /admin &#123; try_files $uri /admin/index.php?$args;&#125; 官方推荐配置123456789101112131415161718192021222324252627282930# Disable access to .ht* fileslocation ~ /\.ht &#123; deny all;&#125;# Disable access to sensitive files in app pathlocation ~ /(app|content|lib)/.*\.(po|php|lock|sql)$ &#123; deny all;&#125;# Disable log on not found images + image replacement# Image not found replacementlocation ~* (jpe?g|png|gif) &#123; log_not_found off; error_page 404 /content/images/system/default/404.gif;&#125;# Enable CORS header (avoids font rendering issues)location ~ \.(ttf|ttc|otf|eot|woff|woff2|font.css|css|js)$ &#123; add_header Access-Control-Allow-Origin "*";&#125;# Force serve upload path as static contentlocation ~ /images &#123;&#125;# Pretty URLs# Route dynamic request to index.phplocation / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 参考文档 https://www.zhujibiji.com/2017/11/install-chevere-to-build-your-image-sharing-website/https://lala.im/2478.html]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>Chevereto图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图床的选择]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%BA%8A%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[关于图床的选择为什么要使用图床？ Hexo 文章中的图片，我们可以放到本地，然后一起部署到 Github 中，这样完全没有问题。然而 github pages 空间毕竟有限（貌似只有 300M）,另外图片的管理太混乱了，一些原创的图片可能被盗链。 很多技术人写作都用的是 MarkDown 轻量级标记语言进行博客写作，这种写作让我们不用像使用 Word 那样那么麻烦地调整排版和格式，只需专心写作并且照样完成排版的一种方式。但是，基本所有支持 MarkDown 本地写作工具都只能采用导入本地图片引用的方式，对于一篇需要大量图片阐述的文章以及该文章上传至网络图片丢失，这不得不是个很糟糕的问题。那么有什么比较好的解决方式吗？很多人采用的图片寄存于网络，用服务厂商作为图片存储的地方，大家都叫为 「图床」 。 那么像 CSDN 博客、简书平台不是都可以吗？是的，它们平台写文章的时候都可以导入图片然后得到一个图片网络地址。但是，图片数量多，一张一张上传，这不是贼烦嘛！那么有专门可以作 「图床」 功能的服务商吗？有的，比如七牛云。 网上谷歌搜下还是能搜到很多图床网站的，先随便列举一些 公共图床SM.MS https://sm.ms/SM.MS 是由 V2EX @Showfom 自建的，无外链限制，无流量限制的图床，支持 HTTPS，速度不错，已经运行两年多了。 极简图床 https://jiantuku.com/#/ 路过图床 https://imgchr.com/ Imgur https://imgur.com/Imgur 是一家国外老牌的图片存储服务商，国外速度很快，口碑不错，支持 HTTPS。但是国内速度很不稳定，所以追求国内速度的同学慎用。 Qchan图床http://tuchuang.org/ 微博图床 微博图床，可以自定义支持七牛，界面简洁美观，支持 Chrome 插件，注册后还可以同步上传历史。 自建图床 目前自建图床方案有两种 是利用云服务商提供的存储服务来作为图床，通过 API 来管理图片 是在 VPS 上安装开源的图片或文件管理程序，只要能提供外链，基本都可以作为图床来用。 建图床（云服务） 七牛云，又拍云，阿里云OSS 自建图床（开源方案） 如果你有 VPS，并且网络速度 OK 的话，自建图床也是一个不错的选择。 Lychee https://github.com/electerious/LycheeLychee 是一个开源免费的基于 PHP 的图片管理系统，支持 Docker 部署，可以直接当做图床来用，Lychee 还支持很多扩展。 树洞外链 https://yun.aoaoao.me/https://github.com/HFO4/shudong-share树洞外链 是一款免费开源的 PHP 外链网盘系统，界面简洁友好，支持七牛、本地、远程、阿里云OSS、又拍云五种储存方式，支持多用户系统，多上传方案策略。 Chevereto https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirementsChevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。 使用图床的目的是希望文章的图片资源能有更好的加载速度和稳定的显示效果。]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>关于图床的选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之堆溢出处理]]></title>
    <url>%2F2018%2F06%2F10%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java 虚拟机之堆溢出处理在 Java 程序的运行过程中，如果堆空间不足，则有可能抛出内存溢出错误 (Out Of Memory)，简称为 OOM。 如下文字显示了典型的堆内存溢出 1Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:20) 一旦发生这类问题，系统就会被迫退出。如果发生在生产环境，可能会引起严重的业务中断。为了能够不断改善系统，避免或减少这类错误的发生，需要在发生错误时，获得尽可能多的现场信息，以帮助研发人员排查现场问题。 Java 虚拟机提供了参数 -XX:+HeapDumpOnOutOfMemoryError，使用该参数，可以在内存溢出时导出整个堆信息。和它配合使用的还有 -XX:HeapDumpPath，可以指定导出堆的存放路径。 使用如下参数执行上述代码 1-Xms5m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/app/tomcat/logs/P02.dump 显然 20M 堆空间不足以容纳 25M 内存，系统比如发生内存溢出，在发生错误后，控制台输出如下 1java.lang.OutOfMemoryError: Java heap space Dumping heap to /data/app/tomcat/logs/P02.dump... Heap dump file created [23067302 bytes in 0.160 secs] Exception in thread “main” java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:19) 可以看到，虚拟机将当前的堆导出，并保存到 /data/app/tomcat/logs/P02.dump 文件下启动最小空间 5M，配了 20M 最大空间 ，发生了 内存溢出错误，dump 路径为 /data/app/tomcat/logs/P02.dump 使用 MAT 等工具打开该文件进行分析，可以很容易地找到这些 byte 数组和保存它们的 Vector 对象实例]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java虚拟机之堆溢出处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编译安装]]></title>
    <url>%2F2018%2F06%2F08%2FPython-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一般情况下，Linux 都会预装 Python，但是这个预装的 Python 版本一般都比较低，很多 Python 的新特性都没有，必须重新安装新一点的版本Python下载地址https://www.python.org/https://www.python.org/ftp/python/https://www.python.org/ftp/python/2.7.15/https://www.python.org/ftp/python/3.7.0/ 查看 Python 版本1234567python -V# CentOS 6.xPython 2.6.6# CentOS 7.xpython 2.7.5 做好链接，保留旧版本 pythoncd /usr/bin/cp /usr/bin/python /usr/bin/python_bak 如果发现 yum 不能用了，解决 yum 无法使用的问题因为 yum 依赖系统默认安装的 python 版本, 处理如下：vim /usr/bin/yum#!/usr/bin/python修改为-&gt; #!/usr/bin/python2.6 或 #!/usr/bin/env python2.6import systry: import yumexcept ImportError:……省略…… 这里不更改 原 Python 版本 安装依赖1yum -y install readline readline-devel sqlite sqlite-devel zlib zlib-devel openssl openssl-devel bzip2 bzip2-devel bzip2-libs 缺少 readline 支持的 IPythonWARNING: IPython History requires SQLite, your history will not be savedWARNING: Readline services not available or not loaded.WARNING: The auto-indent feature requires the readline library 下载 Python12wget -c https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xzwget -c https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tar.xz 安装 Python安装 Python 2.7.15123456tar -xvf Python-2.7.15.tgzcd Python-2.7.15/./configure \--prefix=/data/python2.7.15 --enable-optimizationsmake -j 4make install 安装 Python 3.7.0123456tar -xvf Python-3.7.0.tgzcd Python-3.7.0/./configure \--prefix=/data/python3.7.0 --enable-optimizationsmake -j 4make install 添加 Python 环境变量12345vim /etc/profile.d/python.sh#!/bin/bashexport PATH=$PATH:/data/python3.7.0/binsource /etc/profile 或 12echo -e '\nexport PATH=$PATH:/data/python2.7.15/bin' &gt;&gt; /etc/profileecho -e 'export PATH=$PATH:/data/python3.7.0/bin' &gt;&gt; /etc/profile PS：如果安装 easy_intall 时报 zlib 没有安装，Linux下直接 yum -y install zlib zlib-devel，然后重新编译 Python2.7.15 继续就可以了cp /usr/bin/python /usr/bin/python_bakln -svnf /data/python2.7.15/bin/python2.7 /usr/bin/python setuptools 安装 下载地址https://pypi.python.org/pypi/setuptoolshttps://pypi.python.org/simple/setuptools/ 1234tar -zxvf setuptools-40.0.0.tar.gzcd setuptools-40.0.0python3 setup.py buildpython3 setup.py install 安装 pip pip 下载地址https://pypi.org/project/pip/ 1234tar -xvf pip-18.0.tar.gzcd pip-18.0/python3 setup.py buildpython3 setup.py install 安装 IPython IPython 是一个 python 的交互式 Shell，比默认的 Python Shell 好用一点，支持变量自动补全，自动缩进，支持 Bash Shell 命令，内置了许多很有用的功能和函数IPython 下载地址https://pypi.org/project/ipython/ 1234tar -zxvf ipython-6.4.0.tar.gzcd ipython-6.4.0/python3 setup.py buildpython3 setup.py install pip 安装 python 第三方库1234pip3 install requestspip3 install pyapi-gitlabpip3 install readlinepip3 install rlcompleter2 Python 组件更新123pip3 install --upgrade pippip3 install --upgrade setuptoolspip3 install --upgrade requests]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志切割]]></title>
    <url>%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志切割 12345678910111213141516vim logcut.sh#!/bin/bashday=$(date +"%Y-%m-%d")yesterday=$(date -d "yesterday" +%Y-%m-%d)logsdir=(/data/app/*/logs)for logdir in $&#123;logsdir[@]&#125;do for logfile in $(ls $&#123;logdir[@]&#125; | egrep "stdout.log|catalina.out") do cp $logdir/$logfile $logdir/$&#123;logfile%.log&#125;.$&#123;day&#125;.log cp $logs/$file $logs/$&#123;file%.out&#125;.$&#123;day&#125;.out cat /dev/null &gt; $logdir/$logfile donedone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志切割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志压缩]]></title>
    <url>%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志压缩打包 压缩 7 天前日志每个月 1 号，创建上个月的目录，年-月 2018-04将 gz 压缩文件拷贝到 年-月 2018-04 目录中 1234567891011121314151617181920vim compresslog.sh#!/bin/bashday=$(date +"%d")month=$(date +"%Y-%d")lastmonth=$(date +"%Y-%m" -d "last month")lastweek=$(date +"%Y-%m-%d" -d "last week")logsdir=(/data/app/*/logs)for logs in $&#123;logsdir[@]&#125;do find $logs/ -mtime +7 -regextype posix-extended -regex ".*\.(log|out|txt)" -exec gzip &#123;&#125; \;done[ $day == 01 ] &amp;&amp; cd $&#123;logsdir[@]&#125; &amp;&amp; mkdir -pv $lastmonthfor logdir in $&#123;logsdir[@]&#125;do [ -d $logdir/$lastmonth ] || mkdir -pv $logdir/$lastmonth mv $logdir/*gz $logdir/$lastmonthdone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM 磁盘扩展]]></title>
    <url>%2F2018%2F06%2F07%2FLVM%E7%A3%81%E7%9B%98%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[LVM 磁盘扩展 查看磁盘空间1df -h 查看 LV 信息1lvs 查看 VG 信息1vgs 创建 PV1pvcreate /dev/vdb 扩展已有的 VG 容量1vgextend vgdata /dev/vdb Couldn&#39;t&#39; create temporary archive name.因为磁盘实在太小了或已经没有空间了，无法执行，删除一些数据就好了 12vgextend vgdata /dev/sdaVolume group "vgdata" successfully extended 查看 VG 信息1vgs 扩展已有 LV 容量123lvextend -l +100%FREE /dev/vgdata/lvdatalvextend -L +99.99G -n /dev/vgdata/lvdatalvextend -L +1020M -n /dev/vgdata/lvdata -L # 指定逻辑卷的大小，单位为 kKmMgGtT 字节，也就是 Size-l # 指定逻辑卷的大小，单位为 PE 数 重新加载逻辑卷12345# 加载 ext 文件系统resize2fs /dev/vgdata/lvdata# 加载 xfs 文件系统xfs_growfs /dev/vgdata/lvdata]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>LVM 磁盘扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建LVM]]></title>
    <url>%2F2018%2F06%2F07%2FLVM%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[创建 LVM LVM 创建过程创建PV -&gt; 创建VG -&gt; 创建LV -&gt; 格式化LV -&gt; mount挂载 常用命令pvcreate 设备名vgcreate 卷组名 物理卷lvcreate -L 大小 -n 逻辑卷名 卷组名 LVM 常用命令表 功能 管理物理卷 管理卷组 管理逻辑卷 Scan 扫描 pvscan vgscan lvscan Create 创建 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Extend 扩展 vgextend lvextend Reduce 减少 vgreduce lvreduce 安装 LVM1yum -y install lvm2 创建 PV12pvcreate /dev/vdbPhysical volume "/dev/vdb" successfully created 创建 VG12vgcreate vgdata /dev/vdbVolume group "vgdata" successfully created 创建 LV12345lvcreate -L 49.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created.lvcreate -L 99.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created. 文件系统格式化12345# 格式化 ext 文件系统mkfs.ext4 /dev/vgdata/lvdata# 格式化 xfs 文件系统mkfs.xfs /dev/vgdata/lvdata 挂载逻辑卷到目录12mkdir -pv /datamount /dev/vgdata/lvdata /data 编辑 /etc/fstab1234vim /etc/fstab...省略.../dev/mapper/vgdata-lvdata /data xfs defaults 0 0...省略... ###]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>创建LVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加文章结束标记]]></title>
    <url>%2F2018%2F06%2F07%2FNext%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[添加文章结束标记 编辑 /hexo/themes/next/layout/_macro/post.swig 文件在 if theme.wechat_subscriber.enabled and not is_index 上面添加如下代码 代码片段123456&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt;&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125; &lt;div&gt; &#123;% include 'wechat-subscriber.swig' %&#125; &lt;/div&gt;&#123;% endif %&#125; 显示效果1————— The End —————]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加文章结束标记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加音乐]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[Next 添加音乐 去网易云音乐搜索喜欢的音乐，点击生成外链播放器，复制代码直接放到博文末尾即可height 设为 0 可隐藏播放器，但仍然可以播放音乐auto 设成 0 可手动播放，默认是 1 自动播放 编辑 /hexo/themes/next/layout/_custom/sidebar.swig 文件里，播放器会显示在站点预览中或编辑 /hexo/themes/next/layout/_macro/sidebar.swig 文件里 123# 将代码粘贴到一个合适的位置&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2188265841&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加分类及标签]]></title>
    <url>%2F2018%2F06%2F06%2FHexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Hexo添加分类及标签创建 分类 选项 生成 分类 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page categories 成功后会提示 1INFO Created: ~/hexo/source/categories/index.md 根据上面的路径，找到 index.md 这个文件，打开后默认内容是这样的 1234---title: 文章分类date: 2018-06-06 22:49:07--- 添加 type: &quot;categories&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "categories"--- 给文章添加 “categories” 属性 打开需要添加分类的文章，为其添加 categories 属性下方的 categories: Hexo笔记 表示添加这篇文章到 Hexo笔记 这个分类注意：hexo 一篇文章只能属于一个分类，也就是说如果在 - Hexo笔记 下方添加 - xxxhexo 不会产生两个分类，而是把分类嵌套（即该文章属于 - Hexo笔记 下的 - xxx 分类） 123456---title: Hexo添加分类及标签date: 2018-06-06 22:44:41categories: - Hexo笔记--- 至此，成功给文章添加分类，点击首页的 分类 可以看到该分类下的所有文章当然，只有添加了 categories: xxx 的文章才会被收录到首页的 分类 中 创建标签选项 生成 标签 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page tags 成功后会提示 1INFO Created: ~/hexo/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的 1234---title: 标签date: 2018-06-06 22:49:07--- 添加 type: &quot;tags&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "tags"--- 给文章添加tags属性打开需要添加标签的文章，为其添加 tags 属性下方的tags:Hexo添加分类及标签- 表格- 表单验证就是这篇文章的标签了 12345678910---title: Hexo添加分类及标签date: 2018-06-06 22:49:07categories: - Hexo笔记tags:- Hexo添加分类及标签- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的标签可以看到该标签下的所有文章当然，只有添加了 tags: xxx 的文章才会被收录到首页的标签中细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的所以我们可以打开 \hexo\scaffolds/post.md 文件，在 tages:上面加入categories:1234567vim /hexo/scaffolds/post.md---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 保存后执行hexo new &quot;文章名&quot;命令生成的文件，页面里就有categories:项了\hexo\scaffolds\ 目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加分类及标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置网站的图标Favicon]]></title>
    <url>%2F2018%2F06%2F06%2FHexo%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%AB%99%E7%9A%84%E5%9B%BE%E6%A0%87Favicon%2F</url>
    <content type="text"><![CDATA[Hexo 设置网站的图标 Favicon ico图标使用 32x32去别的网站下载或 PS 制作，并将图标名称改为 favicon.ico然后把图标放在 \next\themes\next\source\images\ 目录下也可以放在 hexo\source\images 目录下，这个目录没有可以自己手动创建 修改 next主题配置文件，\next\themes\next\_config.yml 文件12345678favicon: small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo设置网站的图标Favicon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加访问量]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Next添加访问量 使用 Next 主题自带的不蒜子统计，仅限于在文章页面显示阅读量，不在首页显示 修改 themes\next\ _config.yml 文件123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数(UV) site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量(PV) site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 总访问量 (PV) 总访问量独立访客 (UV) 访问人数网站的浏览次数为 PV网站的访客数为 UVPV 计算方式，单个用户连续点击 N 篇文章，记录 N 次访问量UV 计算方式，单个用户连续点击 N 篇文章，只记录 1 次访客数可以根据需要添加相应的统计功能 查看底部显示效果]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加访问量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next修改小型代码块颜色]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E4%BF%AE%E6%94%B9%E5%B0%8F%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%9D%97%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Next 修改小型代码块颜色 修改 \themes\next\source\css\ _variables\base.styl 文件可以加入自定义颜色，如下中已经给出了许多种颜色 12345678910111213// Colors// colors for use across theme.// --------------------------------------------------$whitesmoke = #f5f5f5$gainsboro = #eee$gray-lighter = #ddd...$blue = #0684bd$blue-deep = #262a30$orange = #fc6423 修改 $code-background 与 $code-foreground 的值 以下的各个参数自己根据需求进行设置即可 1234567// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 13px$code-foreground = $black-light //设置成自己喜欢的颜色即可$code-background = $gainsboro //设置成自己喜欢的颜色即可$code-border-radius = 4px 在 \themes\next\source\css\ _variables\base.styl 文件内还有很多的参数，可以酌情进行修改]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next修改小型代码块颜色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next头像圆形旋转]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E5%A4%B4%E5%83%8F%E5%9C%86%E5%BD%A2%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[头像变成圆形，鼠标停留在上面发生旋转效果 介绍一下实现头像圆形，鼠标经过旋转或者一直让旋转效果修改 Hexo 目录下 \themes\next\source\css\_common\components\sidebar\sidebar-author.styl 文件 头像圆形修改 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转修改 修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 方法二：修改 themes/next/source/css/_common/components/sidebar/sidebar-author.styl 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 头像循环旋转效果修改 修改 sidebar-author.styl 文件，添加如下代码 12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next头像圆形旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置首页隐藏指定文章]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Next设置首页隐藏指定文章 修改 next 主题文件夹下的 layout 中的 index.swig 文件定位修改 post_template.render(post, true) 1234567891011\themes\next\layout\index.swig...省略...&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.visible !== 'hide' %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt;...省略... 其中修改的是为文章的首页显示添加判断条件 在新的 post 中添加 visible 字段来控制是否首页显示 例如：当前这篇文章 12345title: Next设置首页隐藏指定文章date: 2018-06-06 01:08:59categories: Next笔记tags: Next设置首页隐藏指定文章visible: hide 这里如果加上 hide 则该文章就不会在文章首页显示，如果留空则表示默认显示]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置首页隐藏指定文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks 安装]]></title>
    <url>%2F2018%2F06%2F06%2FShadowsocks%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Shadowsocks 安装 123456yum -y install python-pippip install --upgrade pippip install shadowsockswhich ssserverpip install M2Cryptopip install gevent 123456789101112131415161718vim /etc/systemd/system/shadowsocks.service[Unit]Description=Shadowsocks[Service]Type=simpleTimeoutStartSec=0PIDFile=/data/shadowsocks/var/run/ssserver.pidExecStart=/usr/bin/ssserver -c /data/shadowsocks/conf/shadowsocks.json -d start \ --pid-file /data/shadowsocks/var/run/ssserver.pid \ --log-file /data/shadowsocks/logs/ssserver.logRestart=on-abortRestartSec=10sPrivateTmp=true[Install]WantedBy=multi-user.targettail -f /data/shadowsocks/logs/ssserver.log 123456789101112131415mkdir -pv /data/shadowsocks/&#123;conf,logs,var/run&#125;cd /data/shadowsocks/vim shadowsocks.json&#123; "server":"149.28.231.171", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "8888":"gmlyo", "8889":"glmyo" &#125;, "timeout":300, "method":"aes-256-cfb", "fast_open":false&#125; 1234567systemctl daemon-reloadsystemctl start shadowsockssystemctl -l status shadowsockssystemctl enable shadowsockssystemctl stop shadowsockssystemctl restart shadowsocksjournalctl -fu shadowsocks 12345678910111213141516171819202122232425262728293031323334# 查看防火墙状态systemctl status firewalldsystemctl -l status firewalld# 查看防火墙，添加的端口也可以看到firewall-cmd --list-all# 显示所有公共区域（public）所有设置firewall-cmd --zone=public --list-all# 查看开放的服务firewall-cmd --list-services# 显示服务列表firewall-cmd --get-services# 永久添加开放端口firewall-cmd --zone=public --permanent --add-port=8888/tcpfirewall-cmd --zone=public --permanent --add-port=1194/udp# 查询刚插入的规则是否生效firewall-cmd --zone=public --query-port=1985/tcp# 查询指定的端口是否永久开放firewall-cmd --zone=public --permanent --query-port=1985/tcp# 永久删除正在开放的端口firewall-cmd --zone=public --permanent --remove-port=8080/tcpfirewall-cmd --zone=public --permanent --remove-port=1194/udp# 重新加载配置firewall-cmd --reload# 查看所有打开的端口firewall-cmd --zone=public --list-portsfirewall-cmd --zone=dmz --list-ports]]></content>
      <categories>
        <category>Shadowsocks笔记</category>
      </categories>
      <tags>
        <tag>Shadowsocks 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat APR 安装]]></title>
    <url>%2F2018%2F06%2F05%2FTomcat-APR-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Tomcat APR 安装 APR(Apache portable Run-time libraries) 可移植运行时库，是 Apache HTTP 服务的支持库，提供了一组映射到下层操作系统的 API。Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高 Tomcat 对静态文件的处理性能。改善 Tomcat 对静态文件的处理性能，同时如果使用了 HTTPS 方式传输的话，也可以提升 SSL 的处理性能。默认情况下，Tomcat 是用 BIO 的方式来实现网络通信的，性能非常低。Tomcat apr 也是在 Tomcat 上运行高并发应用的首选模式。APR 使用 JNI 的方式来读取文件以及进行网络传输，从操作系统级别来解决异步的 I/O 问题，大幅度的提高性能。如果操作系统不支持某个特定的功能，APR 将提供一个模拟的实现，这样程序员使用 APR 编写真正可在不同平台上移植的程序 安装依赖12345Tomcat 和 JDKyum install -y apr-develyum install -y gcc gcc-develyum install -y openssl openssl-develyum install -y expat-devel 下载 apr 下载地址：https://apr.apache.org/download.cgi 1234cd /data/tools/wget -c http://mirrors.shu.edu.cn/apache//apr/apr-1.6.3.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-util-1.6.1.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-iconv-1.2.2.tar.gz 安装 apr1234567891011121314151617181920212223# 解压并进入解压目录cd /data/tools/tar -zxvf apr-1.6.3.tar.gzcd apr-1.6.3/# 配置，安装在 /data/ 目录下./configure --prefix=/data/apr# 报错信息config.status: executing libtool commandsrm: cannot remove 'libtoolT': No such file or directoryconfig.status: executing default commands# 解决方法# 编辑 configure 文件cd apr-1.6.3/vim configure把 $RM "$cfgfile" 这行代码注释掉或 把 $RM "$cfgfile" 这行删除掉或 写成 $RM -f "$cfgfile"重新再运行 ./configure 就可以了# 编译安装make -j 4make install 安装 apr-iconv1234567891011# 解压并进入解压目录cd /data/tools/tar -zxvf apr-iconv-1.2.2.tar.gzcd apr-iconv-1.2.2/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-iconv \--with-apr=/data/apr# 编译安装make -j 4make install 安装 apr-util123456789101112131415161718192021222324252627# 解压并进入解压目录cd /data/tools/tar -zxvf apr-util-1.6.1.tar.gzcd apr-util-1.6.1/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-util \--with-apr=/data/apr \--with-apr-iconv=/data/apr-iconv/bin/apriconv# 编译安装make -j 4# 报错信息xml/apr_xml.c:35:19: fatal error: expat.h: No such file or directory #include &lt;expat.h&gt; ^compilation terminated.make[1]: *** [xml/apr_xml.lo] Error 1make[1]: Leaving directory `/data/tools/apr-util-1.6.1'make: *** [all-recursive] Error 1# 解决办法# 缺少 expat 开发库，安装 expat 库yum install -y expat-devel# 重新执行make -j 4make install 配置 Tomcat 使用 apr 库 什么是 tomcat-native ？tomcat-native 库为 Tomcat 提供了本地实现tomcat-native 依赖于三个组件：APR，OpenSSL，JDK 大致就是通过 tomcat-native 库，使 tomcat 运行时通过 APR 更多的调用本地 API，达到提升性能的目的。由于依赖关系，安装时，先安装 APR，OpenSSL，然后再安装 tomcat-native，最后配置 tomcat 启动时依赖的库路径。 安装配置 Tomcat native 具体的安装步骤其实在 tomcat 自带的 tomcat-native.tar.gz 文件中就有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 进入 Tomcat bin 目录cd /data/app/tomcat/bin/# 解压 tomcat-native.tar.gz 后进入解压目录tar -zxvf tomcat-native.tar.gz# cd tomcat-native-1.2.8-src/native/ # Tomcat7cd tomcat-native-1.1.33-src/jni/native/# 配置 指定 JDK 的目录并加入 SSL./configure \--prefix=/data/apr \--with-apr=/data/apr/bin/apr-1-config \--with-java-home=/data/jdk1.8.0_172 \--with-ssl=yes# 编译安装make -j 4make installwarning: remember to run 'libtool --finish /usr/local/apr/lib'libtool --finish /data/apr/lib-bash: libtool: command not foundyum -y install libtool libtool-devellibtool --finish /data/apr/lib###################################################################################################cd tomcat-native-1.2.16-src/native//data/apr/build-1/libtool --mode=install /bin/install -c -m 755 libtcnative-1.la /data/apr/liblibtool: install: /bin/install -c -m 755 .libs/libtcnative-1.so.0.2.16 /data/apr/lib/libtcnative-1.so.0.2.16libtool: install: (cd /data/apr/lib &amp;&amp; &#123; ln -s -f libtcnative-1.so.0.2.16 libtcnative-1.so.0 || &#123; rm -f libtcnative-1.so.0 &amp;&amp; ln -s libtcnative-1.so.0.2.16 libtcnative-1.so.0; &#125;; &#125;)libtool: install: (cd /data/apr/lib &amp;&amp; &#123; ln -s -f libtcnative-1.so.0.2.16 libtcnative-1.so || &#123; rm -f libtcnative-1.so &amp;&amp; ln -s libtcnative-1.so.0.2.16 libtcnative-1.so; &#125;; &#125;)libtool: install: /bin/install -c -m 755 .libs/libtcnative-1.lai /data/apr/lib/libtcnative-1.lalibtool: install: /bin/install -c -m 755 .libs/libtcnative-1.a /data/apr/lib/libtcnative-1.alibtool: install: chmod 644 /data/apr/lib/libtcnative-1.alibtool: install: ranlib /data/apr/lib/libtcnative-1.alibtool: finish: PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/data/jdk1.8.0_144/bin:/data/jdk1.8.0_144/jre/bin:/root/bin:/sbin" ldconfig -n /data/apr/lib----------------------------------------------------------------------Libraries have been installed in: /data/apr/libIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the '-LLIBDIR'flag during linking and do at least one of the following: - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the 'LD_RUN_PATH' environment variable during linking - use the '-Wl,-rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to '/etc/ld.so.conf'See any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------# 将 apr 加载到 ldconfig 中vim /etc/ld.so.conf.d/apr.conf/data/apr/lib/data/apr-util/lib/data/apr-iconv/lib# 重新加载以下 ldconfigldconfig -v | grep apr/data/apr/lib: libapr-1.so.0 -&gt; libapr-1.so.0.6.3/data/apr-util/lib: libaprutil-1.so.0 -&gt; libaprutil-1.so.0.6.1/data/apr-iconv/lib: libapriconv-1.so.0 -&gt; libapriconv-1.so.0.2.2 CentOS 6.x 安装配置 Tomcat native CentOS 6.x 会出现以下这类问题 1234checking OpenSSL library version &gt;= 1.0.2... Found OPENSSL_VERSION_NUMBER 0x1000105f (OpenSSL 1.0.1e 11 Feb 2013)Require OPENSSL_VERSION_NUMBER 0x1000200f or greater (1.0.2)configure: error: Your version of OpenSSL is not compatible with this version of tcnative OpenSSL 版本与 tcnative 版本不兼容CentOS 7.2 或以上版本不会出现这类问题需要手工安装 OpenSSL 1.0.2 或以上版本 123456789101112# 下载 OpenSSLwget -c https://www.openssl.org/source/openssl-1.0.2p.tar.gz或wget -c https://www.openssl.org/source/openssl-1.1.0i.tar.gz# 安装 OpenSSLtar -xvf openssl-1.1.0i.tar.gzcd openssl-1.1.0i/./config --prefix=/usr/local/openssl./config -tmake -j 4make install 123456789101112131415161718192021222324252627282930313233# 将 openssl 的 lib 加入系统 ldconfig 中vim /etc/ld.so.conf.d/openssl.conf/usr/local/openssl/lib# 加载一下ldconfig -vldconfig -v | grep libssl# 查看 OpenSSL 版本/usr/local/openssl/bin/openssl version -a# 如果遇到以下错误openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directoryopenssl: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory# 是由于 OpenSSL 库的位置不正确造成的# 做一下软链接，就好了ln -svnf /usr/local/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1ln -svnf /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1# 配置环境变量vim /etc/profile.d/openssl.sh#!/bin/bashexport OPENSSL_HOME=/usr/local/opensslexport PATH=$PATH:$OPENSSL_HOME/binopenssl version -a# 或把原来的命令备份一下，做个软链接ll -h /usr/bin/opensslmv /usr/bin/openssl&#123;,_bak&#125;mv /usr/include/openssl&#123;,openssl_bak&#125;ln -svnf /usr/local/openssl/bin/openssl /usr/bin/opensslln -svnf /usr/local/openssl/include/openssl /usr/include/openssl 有 两 种方式配置 Tomcat 使用 apr 库方式一：配置 Tomcat Native 环境变量 在 Linux 系统中，只要 $LD_LIBRARY_PATH 变量值所在路径包含 Tomcat 本地库默认就使用 org.apache.coyote.http11.Http11AprProtocol 12345vim /etc/profile.d/apr.sh#!/bin/bashexport LD_LIBRARY_PATH=/data/apr/libsource /etc/profile 方式二：将 apr 库路径参数添加到 Tomcat 系统变量中（推荐） 编辑 $CATALINA_HOME/bin/setenv.sh 文件（如果文件不存在，新建文件） 1export CATALINA_OPTS="$CATALINA_OPTS -Djava.library.path=/data/apr/lib" 修改 $TOMCAT_HOME/conf/server.xml 12345&lt;Connector port="8000" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443"protocal 修改为 org.apache.coyote.http11.Http11AprProtocol，重启 tomcat 测试 启动 Tomcat，若在控制台或日志出现类似如下示例信息则表示 APR 配置成功 1INFO: Loaded APR based Apache Tomcat Native library 1.1.33. 检查是否安装成功如果看到下面的启动日志，表示成功 123456Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["http-apr-8080"]Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["ajp-apr-8009"]Sep 17, 2017 1:59:19 PM org.apache.catalina.startup.Catalina startINFO: Server startup in 31002 ms]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat APR 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不通过inventory文件，指定host运行Ansible]]></title>
    <url>%2F2018%2F06%2F05%2F%E4%B8%8D%E9%80%9A%E8%BF%87inventory%E6%96%87%E4%BB%B6%EF%BC%8C%E6%8C%87%E5%AE%9Ahost%E8%BF%90%E8%A1%8CAnsible%2F</url>
    <content type="text"><![CDATA[如何不通过 inventory 文件，直接指定 host 运行 Ansible？ 使用过 ansible 的都知道，不管是运行 Ad-Hoc 还是 playbook，都需要指定一个 inventory 文件，或者使用默认的 inventory 文件。但是现在有一个主机，它尚未在 inventory 文件中配置，那么我们该如何用 ansible 对其进行操作呢？ 一般我们执行都是这样的 12345ansible 192.168.35.215 -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125; 这时需要在 inventory 文件 /etc/ansible/hosts 中配置 192.168.35.215 信息 12[NgxProxy]192.168.35.215 如果没有在 inventory 文件中配置该主机信息，又想用 ansible 对其进行操作就需要用到逗号 , 字符，使用方法如下 123456# Host and IP addressansible all -i example.com,ansible all -i 93.184.216.119,# Requires 'hosts: all' in your playbookansible-playbook -i example.com, playbook.yml 需要注意的是，需要指定范围为 all 12345ansible all -i 192.168.35.215, -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;]]></content>
      <categories>
        <category>Ansible笔记</category>
      </categories>
      <tags>
        <tag>如何不通过 inventory 文件，直接指定 host 运行 Ansible？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客生成一个站点地图]]></title>
    <url>%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[给博客生成一个站点地图 安装 hexo-generator-seo-friendly-sitemap1npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件 _config.yml 中添加12sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客生成一个站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客添加feed]]></title>
    <url>%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[给博客添加 feed 安装 hexo-generator-feed1npm install hexo-generator-feed --save 配置到站点配置文件 _config.yml12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 最后，在你 next 主题下的 _config.yml 下，添加 RSS 订阅链接即可1rss: /atom.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客添加feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora快捷键]]></title>
    <url>%2F2018%2F06%2F04%2FTypora%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Typora常用快捷键 功能 快捷键 新建界面窗口 Ctrl + Shift + N 新建文件 Ctrl + N 打开文件 Ctrl + O 序列表 输入-之后输入空格 序列表 输入数字+“.”之后输入空格 务列表 -[空格]空格 文字 标题 Ctrl + 数字 表格 Ctrl + t 成目录 [TOC]按回车 选中一整行 Ctrl + l 选中单词 Ctrl + d 选中相同格式的文字 Ctrl + e 跳转到文章开头 Ctrl + home 跳转到文章结尾 Ctrl + end 搜索 Ctrl + f 替换 Ctrl + h 引用 输入&gt; 后输入空格 代码块 Ctrl + Alt + f 加粗 Ctrl + b 斜体 Ctrl + i 字体 Ctrl + 数字 下划线 Ctrl + u 删除线 Alt + Shift + 5 插入图片 直接拖动到指定位置即可或Ctrl + Shift + i 插入链接 Ctrl + k]]></content>
      <categories>
        <category>Typora笔记</category>
      </categories>
      <tags>
        <tag>Typora快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安全加固心得]]></title>
    <url>%2F2018%2F06%2F04%2FNginx%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Nginx安全加固心得 Nginx 发展多年，自身的安全漏洞比较少，发现软件漏洞，一般利用软件包管理器升级一下就好了。本文侧重讲述的不是 Nginx 自身的安全，而是利用 Nginx 来加固 Web应用，干一些应用防火墙（WAF）干的活。在做安全加固的时候，我们一定要头脑清晰，手里拿着刀，一刀一刀的切，将我们不想要的流量干掉，除去隐患。 屏蔽 IP 假设我们的网站只是一个国内小站，有着公司业务，不是靠广告生存的那种，那么可以用 Geoip 模块封杀掉除中国和美国外的所有IP。这样可以过滤大部分来自国外的恶意扫描或者无用访问。不用担心封杀了网络蜘蛛。主流的网络蜘蛛（百度/谷歌/必应/搜狗）已经包含在了我们的IP范围内了。如果是公网的登录后台，更应该屏蔽彻底一点。 123if ( $geoip_country_code !~ ^(CN|US)$ ) &#123; return 403;&#125; （很多人担心geoip库不够准确，诚然，中国城市级别的IP段会有误差，但是国家级别的IP段一般是没有问题的，并且geoip库可以随时在线更新） 封杀各种 user-agent user-agent 也即浏览器标识，每个正常的web请求都包含用户的浏览器信息，除非经过伪装，恶意扫描工具一般都会在user-agent里留下某些特征字眼，比如 scan，nmap 等。我们可以用正则匹配这些字眼，从而达到过滤的目的，请根据需要调整。 123456if ($http_user_agent ~* "java|python|perl|ruby|curl|bash|echo|uname|base64|decode|md5sum|select|concat|httprequest|httpclient|nmap|scan" ) &#123; return 403;&#125;if ($http_user_agent ~* "" ) &#123; return 403;&#125; 这里分析得不够细致，具体的非法 user-agent 还得慢慢从日志中逐个提取。通过上面两个大招，相信你的日志里很快就会有大量的 403 记录。，我们接着干。如果网站提供公共 api，注意与开发者约定好 UA，防止撞墙 封杀特定的 URL 特定的文件扩展名，比如 .bak 123location ~* \.(bak|save|sh|sql|mdb|svn|git|old)$ &#123; rewrite ^/(.*)$ $host permanent;&#125; 知名程序，比如 phpmyadmin 123location /(admin|phpadmin|status) &#123; deny all; &#125; 封杀特定的 http 方法和行为，比如 123456if ($request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 405;&#125;if ($http_range ~ "\d&#123;9,&#125;") &#123; return 444;&#125; 强制网站使用域名访问，可以逃过IP扫描，比如123if ( $host !~* 'abc.com' ) &#123; return 403;&#125; url 参数过滤敏感字，比如1234567if ($query_string ~* "union.*select.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; if ($query_string ~* "concat.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; 强制要求referer123if ($http_referer = "" ) ｛ return 403;｝ 如果不想用403，也可以rewrite一个url，比如一个400页面 123456&lt;html&gt; &lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor="white"&gt; &lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx/1.2.0&lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 小结 可以将上述规则结合起来使用，同时匹配多条规则时才会封杀，下面是一个来自老外的稍微复杂一点的例子： 123456789101112131415set $add 1; location /index.php &#123; limit_except GET POST &#123; deny all; &#125; set $ban ""; if ($http_referer = "" ) &#123;set $ban $ban$add;&#125; if ($request_method = POST ) &#123;set $ban $ban$add;&#125; if ($query_string = "action=login" )&#123;set $ban $ban$add;&#125; if ($ban = 111 ) &#123; access_log /var/log/[133]nginx/ban IP; return 404; &#125; proxy_pass http://127.0.0.1:8000; #here is a patch &#125; 其它方法 封杀IP 定时做日志分析，手动将恶意IP加入 iptables 拒绝名单，推荐使用 ipset 模块。 12yum install -y ipset ipset-serviceipset create badip hash:net maxelem 65535iptables -I INPUT -m set --match-set badip src -p tcp --dport 80 -j DROP/etc/init.d/iptables saveipset add badip 1.1.1.2ipset add badip 2.2.2.0/24/etc/init.d/ipset save ipset 还支持 timeout，类似 redis 的 TTL，timeout 之后会自动删除，比较人性化。比如下面的例子就是 timeout 默认 3600 秒，支持自定义 timeout 12ipset destroy badipipset create badip hash:net maxelem 65535 timeout 3600ipset add badip 1.1.1.1ipset add badip 2.2.2.0/24 timeout 60ipset add badip 3.3.3.0/24 timeout 7200 在日志分析的自动化程度比较高，准确率比较好的情况下，可以考虑通过条件触发 ipset。 限速 适当限制客户端的请求带宽，请求频率，请求连接数，这里不展开论述。根据具体需求，阀值应当稍稍宽泛一点。特别要注意办公室/网吧场景的用户，他们的特点是多人使用同一个网络出口。 目录只读 如果没有上传需求，完全可以把网站根目录弄成只读的，加固安全。做了一点小动作，给网站根目录搞了一个只读的挂载点。这里假设网站根目录为 /var/www/html 1234mkdir -pv /datamkdir -pv /var/www/htmlmount --bind /data /var/www/htmlmount -o remount,ro --bind /data /var/www/html 网站内容实际位于/data，网站内容更新就往/data里更新，目录/var/www/html无法执行任何写操作，否则会报错“Read-only file system”，极大程度上可以防止提权篡改。 overlayfs 这种方法跟上面的方法类似，但是有所区别假设网站根目录/var/www/html有一个目录upload是要求可读写的，其他只读即可，那么仔细看下面的操作 123456mkdir -pv /data/lowermkdir -pv /data/uppermkdir -pv /data/workermv /var/www/html/upload /data/upper/mv /var/www/html/* /data/lower/mount -t overlayfs overlay -o lower=/data/lower,upper=/data/upper,workdir=/data/worker /var/www/html 这样就完美实现了读写分离，底层目录只读，上层目录可写。如果程序被篡改，上层目录 /data/upper 除了 upload 内容之外，还会生成其他文件。overlayfs 因为特殊的机制，建议使用 Linux 内核4.0+，否则比较消耗硬盘的 inode。 定时总结和丰富过滤规则]]></content>
      <categories>
        <category>Nginx笔记</category>
      </categories>
      <tags>
        <tag>Nginx安全加固心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置阅读全文]]></title>
    <url>%2F2018%2F06%2F03%2FNext%E8%AE%BE%E7%BD%AE%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[如何设置「阅读全文」？ 在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。NexT 提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在 主题配置文件 中添加： 123auto_excerpt: enable: true # 改成 true length: 150 # 默认展示的高度 默认截取的长度为 150 字符，可以根据需要自行设定建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外，这种方式也可以让 Hexo 中的插件更好的识别。 需要注意的是，点击「阅读全文」之后，文章会自动定位到 所在位置，想要修改成从头阅读需要修改 主题配置文件 _config.yml 文件： 12# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: false]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置阅读全文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next开启站内搜索]]></title>
    <url>%2F2018%2F06%2F03%2FNext%E5%BC%80%E5%90%AF%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[Next 如何开启站内搜索？ NexT 主题支持集成 Swiftype、微搜索、Local Search 和 Algolia,Swiftype 和 Algolia 都只有一段时间的试用期，可以采用 Hexo 提供的Local Search，原理是通过 hexo-generator-search 插件在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 Local Search 由 flashlab 贡献 安装步骤安装 hexo-generator-search 在站点的根目录下执行以下命令 1npm install hexo-generator-search --save 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令1npm install hexo-generator-searchdb --save 启用搜索 编辑 站点配置 文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置 文件，启用本地搜索功能 123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next开启站内搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装]]></title>
    <url>%2F2018%2F06%2F03%2FHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Hexo 简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 安装 进入 D:\Blog\gmlyo\ 自定义目录，右键鼠标，点击 Git Bash Here，输入 npm 命令即可安装 12345678910111213141516右击 Git Bash Herecd /d/Blog/gmlyo/npm install hexo -g 或 npm install hexo-cli -ghexo init 或 hexo init blog; cd blog/# 第一句是安装 hexo# 第二句是安装 hexo 部署到 git page 的 deployer# 两个都需要安装# Hexo 初始化配置（有点漫长的等待。。。）npm initHexo 初始化完成后，Hexo 将会在指定文件夹中新建所需要的文件hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # 或 hexo generatehexo s # 或 hexo server 可以在打开浏览器访问 http://localhost:4000/ 查看 查看 hexo 版本信息12345678910111213141516171819# 查看 hexo 版本信息hexo -vhexo: 3.7.1hexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64http_parser: 2.8.0node: 10.3.0v8: 6.6.346.32-node.9uv: 1.20.3zlib: 1.2.11ares: 1.14.0modules: 64nghttp2: 1.29.0napi: 3openssl: 1.1.0hicu: 61.1unicode: 10.0cldr: 33.0tz: 2018c 常用 Hexo 命令123456# 生成静态文件，会在当前目录下生成一个新的叫做 public 的文件夹hexo generate (hexo g)# 启动本地 Web 服务，用于博客的预览hexo server (hexo s)# 部署播客到远端（比如github, heroku等平台）hexo deploy (hexo d) 其他常用命令12hexo new "postName" # 新建文章hexo new page "pageName" # 新建页面 常用简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 常用组合12hexo d -g # 生成部署hexo s -g # 生成预览]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kickstart自动应答文件]]></title>
    <url>%2F2018%2F06%2F03%2FKickstart%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Kickstart 自动应答文件 Cobbler vim /var/lib/cobbler/kickstarts/centos7.5-ks.cfg1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Cobbler for Kickstart Configurator for CentOS 7 by clsninstallurl --url=$treetextlang en_US.UTF-8keyboard uszerombrbootloader --location=mbr --driveorder=sda --append="crashkernel=auto rhgb quiet"#Network information$SNIPPET('network_config')#network --bootproto=dhcp --device=eth0 --onboot=yes --noipv6 --hostname=CentOS7timezone --utc Asia/Shanghaiauthconfig --enableshadow --passalgo=sha512rootpw --iscrypted $default_password_cryptedclearpart --all --initlabel# Disk partitioning informationpart pv.374 --fstype="lvmpv" --ondisk=sda --size=2052part pv.671 --fstype="lvmpv" --ondisk=sda --size=20484part pv.639 --fstype="lvmpv" --ondisk=sda --size=1 --growpart /boot --fstype="xfs" --ondisk=sda --size=500volgroup vgswap --pesize=4096 pv.374volgroup vgroot --pesize=4096 pv.671volgroup vgdata --pesize=4096 pv.639logvol / --fstype="xfs" --size=20480 --name=lvroot --vgname=vgrootlogvol swap --fstype="swap" --size=2048 --name=lvswap --vgname=vgswaplogvol /data --fstype="xfs" --size=1 --grow --name=lvdata --vgname=vgdatafirstboot --disableselinux --disabledfirewall --disabledlogging --level=inforeboot%pre$SNIPPET('log_ks_pre')$SNIPPET('kickstart_start')$SNIPPET('pre_install_network_config')# Enable installation monitoring$SNIPPET('pre_anamon')%end%packages@^minimal@compat-libraries@core@debugging@developmentbash-completionchronydos2unixkexec-toolslrzsznmapsysstattelnettreevimwgetnet-tools%end%postsystemctl disable postfix.service%end]]></content>
      <categories>
        <category>Cobbler笔记</category>
      </categories>
      <tags>
        <tag>Kickstart自动应答文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 绑定自定义域名]]></title>
    <url>%2F2018%2F06%2F03%2FHexo%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[如何将自己购买的域名连接到 Github Pages？ 12345678在 source 目录下新建 CNAME 文件，在首行添加网站域名如：www.gmlyo.com注意前面没有 https://，http:// 等信息，然后重新重新生成并部署站点hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # hexo generadehexo d # hexo deploy或hexo d -g 设置域名解析1234561、先添加一个CNAME，主机记录写@，后面记录值写上你的 xxx.github.io2、再添加一个CNAME，主机记录写www，后面记录值也是 xxx.github.io这样别人用 www 和不用 www 都能访问你的网站其实 www 的方式，会先解析成 https://xxx.github.io，然后根据 CNAME 再变成 http://www.gmlyo.com，即中间是经过一次转换的。注：除了使用 CNAME 记录也有人使用 A 记录，后面的记录值是写 Github Page 里面的 IP 地址，但有时候 IP 地址会更改，导致最后解析不正确，所以还是推荐用 CNAME 别名记录要好些，不建议用 IP。3、等待10分钟左右，域名生效后刷新浏览器，使用自定义域名访问网站即可 Hexo 部署后，CNAME 会被自动删除，如何解决？123将需要上传至 Github 的文件放在 source 目录下如：CNAME, README.md, favicon.ico, images 目录等将这些都放在 source 目录下，每次上传就不会消失了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 绑定自定义域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 删除文章]]></title>
    <url>%2F2018%2F06%2F03%2FHexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hexo 如何删除文章？ 1234567891011删除文章的过程很简单，先删除本地文件，然后通过生成和部署命令将远程仓库中的文件也一并删除。以最开始默认形成的 hello-world.md 这篇文章为例首先进入 D:\Blog\gmlyo\source\_posts\ 文件夹中找到 hello-world.md 文件，在本地直接执行删除。然后依次执行hexo cleanhexo ghexo d再去主页查看就会发现博客上面已经什么都没有了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 删除文章</tag>
      </tags>
  </entry>
</search>
