<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python闭包函数]]></title>
    <url>%2F2018%2F08%2F27%2FPython%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python 闭包函数 前提：函数的作用域关系是在函数定义阶段就已经固定死的，与调用位置无关 闭包函数介绍 定义在函数的内部的函数 该内部函数包含对其外层函数作用域名字的引用 闭包函数通常需要结合函数对象的概念，将闭包函数返回到外部使用 示例一123456789101112def outter(): x = 100 def inner(): print(x) return innerf = outter()x = 200f()# 执行结果100 示例二1234567891011121314def outter(): x = 100 def inner(): print(x) return innerdef foo(): x = 300 f()foo()# 执行结果100 示例三 12345678910111213141516171819def outter(): x = 100 def inner(): print(x) return innerf = outter()def foo(): x = 300 def bar(): x = 400 f() bar()foo()# 执行结果100 闭 指的是 -&gt; 定义在函数的内部的函数闭 指的就是将一个函数闭合在另一个函数内部包 指的是 -&gt; 该内部函数包含对其外层函数作用域名字的引用 闭包函数的使用12345def outter(): x = 1 def inner(): print(x) return inner 闭包函数的基本形式 1234def outter(x): def inner(): print(x) return inner 求两个数的和 直接通过参数为其传值 12345def sum2(x, y): res = x + y return ressum2(1, 2) 将 值 包给 函数 sum2 12345678910def outter(x, y): # x = 1 # y = 2 def sum2(): res = x + y return res return sum2sum2 = outter(1, 2)sum2() 示例12345import requestsresponse = requests.get('https://www.jd.com')# if response.status_code = 200:print(response.text) 通过参数的形式为函数体传值 123456789import requestsdef get(url): response = requests.get(url) print(len(response.text))get('https://www.baidu.com')get('https://www.jd.com')get('https://www.tmall.com') 将值包给函数 12345678910111213141516171819202122232425262728import requestsdef outter(url): # url = 'https://www.jd.com' def get(): response = requests.get(url) print(len(response.text)) return getjd = outter('https://www.jd.com')jd()jd()jd()# 执行结果117377117377117377baidu = outter('https://www.baidu.com')baidu()baidu()baidu()# 执行结果244324432443 123456789def outter(): x = 1 def foo(): print(x) return foof = outter()print(f)f()]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python闭包函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数之 global 与 nonlocal 关键字]]></title>
    <url>%2F2018%2F08%2F26%2FPython%E5%87%BD%E6%95%B0%E4%B9%8Bglobal%E4%B8%8Enonlocal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Python 函数 global 与 nonlocal 关键字 global global 是用于在函数内去修改全局作用域的名字 12345678910x = 1def func(): x = 2func()print(x)# 执行结果1 12345678910x = []def func(): xfunc()print(x)# 执行结果[] 在局部名称空间，修改一个可变类型的变量名字 12345678910x = []def func(): x.append(1) # 在局部名称空间，修改一个可变类型的变量func()print(x)# 执行结果[1] 在 局部名称空间 造一个值覆盖全局的变量名字global 在局部声明名字是来自于全局的 1234567891011x = 1def func(): global x # 在 局部名称空间 造一个值覆盖全局的名字 x = 2func()print(x)# 执行结果2 nonlocal global 修改的是 全局名称空间 的所定义 的 名字但无法修改 当前层函数的 外面一层 的 局部名字 12345678910111213141516x = 222def f1(): x = 111 def f2(): global x x = 0 f2() print('f1---&gt;', x)f1()print(x)# 执行结果f1---&gt; 1110 nonlocal 声明变量是来自于当前层外层的名字只能找到 当前层函数 的外面一层的 名字如果没有则抛出异常：SyntaxError: no binding for nonlocal &#39;x&#39; found必须是在函数内，不能跳出函数123456789101112131415x = 222def f1(): def f2(): # x = 111 nonlocal x x = 0 f2() print('f1---&gt;', x)f1()print(x)# 执行结果SyntaxError: no binding for nonlocal 'x' found 12345678910111213141516x = 222def f1(): x = 111 def f2(): nonlocal x x = 0 f2() print('f1---&gt;', x)f1()print('global===&gt;', x)# 执行结果f1---&gt; 0global===&gt; 222]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数之 global 与 nonlocal 关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python名称空间与作用域]]></title>
    <url>%2F2018%2F08%2F23%2FPython%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Python 名称空间与作用域 什么是名称空间？名称空间就是存放名字与值绑定映射关系的地方要取到值必须通过名字才能找到，而名字又在名称空间中存放着，所以在取值时首先是去名称空间中找名字找到了名字就拿到值的内存地址了 名称空间氛围三种内置名称空间 存放的 python 解释器自带的名字生命周期：在解释器启动时生成，在解释器关闭时回收12345678print(len)print(max)print(print)# 执行结果&lt;built-in function len&gt;&lt;built-in function max&gt;&lt;built-in function print&gt; 全局名称空间 除了内置的与局部的之外的名字，都属于全局名称空间生命周期：在程序文件执行时就立刻生成，在程序执行完毕后就回收 1234567891011x = 1y = 2def foo(): x = 1 y = 2foo()if y &gt; x: z = 3 局部名称空间 存放的是函数内部定义的名字生命周期：在调用函数时临时生成，在调用函数结束后，立刻回收12345def foo(): x = 1 y = 2foo() 加载顺序 内置名称空间 -&gt; 全局名称空间 -&gt; 局部名称空间 全局查找 12345len = 100print(len)# 执行结果100 12345# len = 100print(len)# 执行结果&lt;built-in function len&gt; 局部查找 12345678910len = 100def foo(): len = 2222 print(len)foo()# 执行结果2222 加载名称空间的目的是为了将名字与值的绑定关系存放起来，存的目的是为取，也就是说，当我们在查找名字时，必然是在三者之一找到 查找顺序 局部名称空间 -&gt; 全局名称空间 -&gt; 内置名称空间基于当前所在的位置往后查找1234567891011x = 100y = 200# 注：函数的形参名属于局部名称空间def foo(x, y): print(x, y)foo(1, 2)# 执行结果1, 2 示例示例一 顺序 调用 f1() 找到 f2() f2() 打印 from f212345678910def f1(): x = 1 def f2(): print('from f2') f2()f1()# 执行结果from f2 示例二 顺序 调用 f1() 找到 f2() f2() 找到局部名称变量 x 打印 from f2 x1234567891011def f1(): x = 1 def f2(): x = 2 print('from f2', x) f2()f1()# 执行结果from f2 2 示例三 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 找到 名字变量 x f2() 打印 from f2 11234567891011def f1(): x = 1 def f2(): # x = 2 print('from f2', x) f2()f1()# 执行结果from f2 1 示例四 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 最终没有找到 名字变量 x 抛出异常NameError: name &#39;x&#39; is not defined1234567891011def f1(): # x = 1 def f2(): # x = 2 print('from f2', x) f2()f1()# 执行结果NameError: name 'x' is not defined 示例五 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在 全局名称空间 里找到 名字变量 x f2() 打印 from f2 111123456789101112x = 111def f1(): # x = 1 def f2(): # x = 2 print('from f2', x) f2()f1()# 执行结果from f2 111 示例六 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在 全局名称空间 里找到 名字变量 x f2() 打印 from f2 111注：名称空间并不是往上找，只要有就能找到123456789101112def f1(): # x = 1 def f2(): # x = 2 print('from f2', x) f2()x = 111f1()# 执行结果from f2 111 示例七 顺序 调用 f1() 找到 f2() f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在局部名称空间没有 名字变量 x，继续往外层寻找 f2() 在 全局名称空间 里找到 名字变量 x 名字变量 x=2222 被重新赋值 x=111 f2() 打印 from f2 11112345678910111213x = 2222def f1(): # x = 1 def f2(): # x = 2 print('from f2', x) f2()x = 111f1()# 执行结果from f2 111 作用域 域是范围，作用域指的是作用范围 分为两大类全局作用范围 包含 内置名称空间 与 全局名称空间 中的名字特点：全局有效，全局存活1234567891011121314151617def f1(): def f2(): def f3(): print(len) f3() f2()f1()def foo(): print(len)foo()# 执行结果&lt;build-in function len&gt;&lt;build-in function len&gt; 内置名字，具备一个特点，无论在任何位置，都能访问的到这叫全局有效 12345678910111213141516171819x = 1def f1(): def f2(): def f3(): print(x) f3() f2()f1()def foo(): print(x)foo()# 执行结果11 局部作用范围 包含 局部名称空间 的名字特点：局部有效，临时存活 gloabls 与 locals12345678x = 1def foo(): y = 2print(globals)# 执行结果&lt;built-in function globals&gt; 返回 全局作用域 中的名字123456789x = 1111111111def foo(): y = 2print(globals()) # 返回 全局作用域 中的名字# 执行结果&lt;built-in function globals&gt;&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x7fa1f58357f0&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': '/data/app/SH_weekend_s2/day04/04_名称空间与作用域.py', '__cached__': None, 'x': 1111111111, 'foo': &lt;function foo at 0x7fa1f5766bf8&gt;&#125; 查看 全局名称空间 包含的 内置名称空间 的名字12345678x = 1111111111def foo(): y = 2print(dir(globals()['__builtins__'])) # 返回 全局作用域中 包含的 内置名称空间 的名字# 执行结果['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] 查看 局部作用域12345678x = 1111111111def foo(): y = 2print(locals() is globals())# 执行结果True 在全局作用范围内查看，locals() 和 gloables() 是一样的全局查看就是 优先查看自己，再查看局部的在全局作用范围查看检索范围就是 全局名称空间，以及内置名称空间123456789x = 1111111111def foo(): y = 2 print(locals())foo()# 执行结果&#123;'y': 2&#125; 打破函数层级限制的解决方案 如何打破函数层级的访问限制？让能够在任意位置都可以访问到一个内部函数123456789def outter(): def inner(): print('from inner') inner()outter()# 执行结果from inner 如何在任何位置都能访问到 inner() 函数？12345678910def outter(): def inner(): print('from inner') return innerf = outter()print(f)# 执行结果&lt;function outter.&lt;locals&gt;.inner at 0x7f2b7b0a0c80&gt; 返回 inner() 的存地址return inner，注意这里 inner 不能加括号然后调用 outter() 函数，将其赋值给 一个 全局名称空间 的名字变量打印这个名字变量，输出 inner() 的内存地址 名字变量 加 括号 执行，就可以访问 内部函数inner() 内的内容了12345678910def outter(): def inner(): print('from inner') return innerf = outter()f()# 执行结果from inner 定义个 全局名称空间 foo() 函数通过 foo() 调用 全局名称空间 的 名字变量 f，也能访问到 内部函数inner() 内的内容了 12345678910111213141516def outter(): def inner(): print('from inner') return innerf = outter()def foo(): print(f) f()foo()# 执行结果&lt;function outter.&lt;locals&gt;.inner at 0x7f8aaa6f6c80&gt;from inner 基于函数对象的概念将一个内部函数返回到全局使用，从而打破了函数的的层级限制 也可以将 内部函数 inner() 返回到 foo() 内 12345678910111213def outter(): def inner(): print('from inner') return innerdef foo(): f = outter() f()foo()# 执行结果from inner 函数的作用域关系是在函数定义阶段就已经固定死的，与函数的调用位置无关即在调用函数时，一定要跑到定义函数的位置寻找作用域关系 示例示例一 注意查看 x 变量的位置1234567891011121314x = 111def outter(): def inner(): print('from inner', x) return innerdef foo(): x = 222 f()foo()# 执行结果from inner 111 示例二 注意查看 x 变量的位置1234567891011121314151617x = 111def outter(): x = 33333 def inner(): print('from inner', x) return innerf = outter()def foo(): x = 222 f()foo()# 执行结果from inner 33333 示例三 注意查看 x 变量的位置1234567891011121314151617x = 111def outter(): def inner(): print('from inner', x) return innerx = 4444f = outter()def foo(): x = 222 f()foo()# 执行结果from inner 4444]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python名称空间与作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数嵌套]]></title>
    <url>%2F2018%2F08%2F21%2FPython%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[Python 函数嵌套 函数的嵌套调用 在调用一个函数时，其内部的代码又调用了其他的函数12345678910def bar(): print('from bar')def foo(): print('from foo')foo()# 执行结果from foofrom bar 求两个数的最大值12345def max2(x, y): if x &gt; y: return x else: return y 求四个数的最大值12345678910def max4(a, b, c, d): res1 = max2(a, b): res2 = max2(res1, c) res3 = max2(res2, d) return res3print(max4(1, 2, 3, 4))# 执行结果4 函数的嵌套定义 在一个函数的内部又定义了另外一个函数123456789def f1(): x = 1 def f2(): print('from f2')print(f1)# 执行结果&lt;function f1 at 0x00000288E1A51E18&gt; 123456789101112def f1(): x = 1 def f2(): print('from f2') print(x) print(f2)f1()# 执行结果1&lt;function f1.&lt;locals&gt;.f2 at 0x0000024BD90F89D8&gt; 12345678910def f1(): x = 1 def f2(): print('from f2') f2()f1()# 执行结果from f2]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数嵌套</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数对象]]></title>
    <url>%2F2018%2F08%2F20%2FPython%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Python 函数对象 函数是第一类对象，意味着函数可以当做数据去使用 可以被引用123456789101112def foo(): print('from foo')print(foo)func = fooprint(func)func() # 加括号运行# 执行结果&lt;function foo at 0x00000221E334E18&gt;&lt;function foo at 0x00000221E334E18&gt;from foo 可以当做参数传给另外一个函数123456789101112def foo(): print('from foo')def bar(x): # x=foo 的内存地址 print(x) x() # 在调用 bar 的时候触发 foobar(foo)# 执行结果&lt;function foo at 0x00000221E334E18&gt;from foo 可以当作函数的返回值123456789101112131415def foo(): print('from foo')def bar(): return foof = bar()print(f)print(f is foo)f()# 执行结果&lt;function foo at 0x00000221E334E18&gt;Truefrom foo 可以当作容器类型的元素12345678910111213def f1(): print('from f1')def f2(): print('from f2')l = [f1, f2]print(l)l[1]()# 执行结果[&lt;function f1 at 0x000001E9A24A89D8&gt;, &lt;function f2 at 0x000001E9A24A8A60&gt;]from f2 示例（基于函数对象思想）12345678910111213141516171819202122232425262728293031323334353637def pay(): print('pay function')def withdraw(): print('withdraw')def auth(): print('auth function')def shopping(): print('shopping function')def transer(): print('transfer function')while True: print(""" 1 支付 2 取款 3 购物 4 转账 5 退出 """) choice = input('请输入您要执行的操作：').strip() if choice == '1': pay() elif choice == '2': withdraw() elif choice == '3': shopping() elif choice == '4': transfer() elif choice == "5": break else: print('输入错误，请重新输入') 示例优化01 1234567891011121314151617181920def pay(): print('pay function')def withdraw(): print('withdraw')def auth(): print('auth function')func_dic = &#123;&#125; '1': pay, '2': withdraw, '3': authprint(func_dic)func_dic['2']()# 执行结果&#123;'1': &lt;function pay at 0x0000029EF7F589D8&gt;, '2': &lt;function withdraw at 0x0000029EF7F58A60&gt;, '3': &lt;function auth at 0x0000029EF7F58AE8&gt;&#125;withdraw function 示例优化02 1234567891011121314151617181920212223242526272829303132333435363738def pay(): print('pay function')def withdraw(): print('withdraw')def auth(): print('auth function')def shopping(): print('shopping function')def transer(): print('transfer function')func_dic = &#123; '1': pay, '2': withdraw, '3': auth, '4': shopping, '5': transfer&#125;while True: print(""" 1 支付 2 取款 3 认证 4 购物 5 转账 """) choice = input('请输入您要执行的操作（按q退出）：').strip() # choice = '1' if choice == 'q': break if choice not in func_dic: print('输入错误，请重新输入') continue func_dic[choice]()]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数参数-命名关键字参数]]></title>
    <url>%2F2018%2F08%2F20%2FPython%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python 函数参数-命名关键字参数命名关键字参数 函数参数格式 def foo(位置形参, 默认形参, **args, 命名关键字参数, **kwargs) 12def foo(x, y=1, **args, m, **kwargs): print(x, y, args, m, kwargs) m 为 命名关键字参数 命名关键字参数：凡是在 * 后 ** 之前定义的的参数称之为 命名关键字参数注意： 在调用函数时，传值的形式必须是 key=value 的形式 1234567def foo(x, y, *, m, n): print(x, y, m, n)foo(1, 2, 3, 4)# 执行结果TypeError: foo() takes 2 positional arguments but 4 were given 需要改成 1234567def foo(x, y, *, m, n): print(x, y, m, n)foo(1, 2, n=3, m=4)# 执行结果1 2 4 3 以下 m=1 表示为命名关键字参数指定一个默认值 1234567def foo(x, y, *, m=1, n): print(x, y, m, n)foo(1, 2, n=3) # m=1 命名关键字参数有值了，可以不传值# 执行结果1 2 1 3 命名关键字参数示例123456789def foo(x, y, *args, m=1, n): print(x, y, m, n) print(args)foo(1, 2, 3, 4, 5, n=222, m=11)# 执行结果1 2 11 222(3, 4, 5) 1234567def foo(x, y=1, *args, m, **kwargs): print(x, y, args, m, kwargs)foo(1, 2, 3, 4, 5, 6, m=200, n=300, a=400)# 执行结果1 2 (3, 4, 5, 6) 200 &#123;'n': 300, 'a': 400&#125; 常用函数参数形式12345678def foo(x, y): passdef foo(x, y=1): passdef wrapper(*args, **kwargs): index(*args, **kwargs) 示例：求和函数 12345678910def my_sum(*args): res = 0 for item in args: res += item return resprint(my_sum(1, 2, 3, 5, 6))# 执行结果21]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python 函数参数-命名关键字参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数参数-可变长参数]]></title>
    <url>%2F2018%2F08%2F15%2FPython%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python函数参数-可变长参数 可变长参数 指的是在调用函数时，传入的实参个数可以不固定实参两种形式： 位置实参 关键字实参所以对应的，形参也必须对应两种解决方案，专门用于接收溢出的位置实参和关键字实参 接收溢出的位置实参 星（*）：接收溢出的位置实参，存成元组类型，然后赋值给（*）后边跟的那个变量名 用法一：在形参中使用（*）12345678910111213def foo(x, y, *args): print(x, y) print(z)foo(1, 2, 3, 4, 5) # 3, 4, 5 是溢出的# 执行结果1, 2(3, 4, 5)foo(1, 2, 3, 4, 5, 6, 7, 8, 9) # 3, 4, 5, 6, 7, 8, 9 是溢出的# 执行结果1 2(3, 4, 5, 6, 7, 8, 9) 用法二：在实参中用（*）123456789def foo(x, y, *args): # args = ((3, 4, 5, 6, 7, 8, 9)) print(x, y) print(z)foo(1, 2, (3, 4, 5, 6, 7, 8, 9))# 执行结果1 2(3, 4, 5, 6, 7, 8, 9) 实参中使用星（*），将实参打散成位置实参，再传值给形参 123456789def foo(x, y, *args): # args = (3, 4, 5, 6, 7, 8, 9) print(x, y) print(z)foo(1, 2, *(3, 4, 5, 6, 7, 8, 9)) # foo(1, 2, 3, 4, 5, 6, 7, 8, 9)# 执行结果1 2(3, 4, 5, 6, 7, 8, 9) 123456789def foo(x, y, *args): # args = (3, 4, 5,) print(x, y) print(z)foo(1, 2, *[3, 4, 5]) # foo(1, 2, 3, 4, 5)# 执行结果1 2(3, 4, 5) 123456789def foo(x, y, *args): print(x, y) print(z)foo(1, 2, *'abc') # foo(1, 2, 'a', 'b', 'c')# 执行结果1 2('a', 'b', 'c') 注意以下传参问题：1234567def foo(x, y): print(x, y)foo(1, *(2, 3, 4, 5)) # foo(1, 2, 3, 4, 5)# 执行结果TypeError: foo() takes 2 positional arguments but 5 were given 1234567def foo(x, y): print(x, y)foo(1, (2, 3, 4, 5))# 执行结果1, (2, 3, 4, 5) 1234567def foo(x, y): print(x, y)foo(*(1, 2, 3, 4, 5)) # foo(1, 2, 3, 4, 5)# 执行结果TypeError: foo() takes 2 positional arguments but 5 were given 示例：求和函数，传一堆数字，求这堆数字的和 123456789101112131415161718def my_sum(*args): res = 0 for n in args: res = res + n return resres1 = my_sum(1, 2, 3)res2 = my_sum(1, 2, 3, 4)res3 = my_sum(1, 2, 3, 4, 5)print(res1)print(res2)print(res3)# 执行结果61015 接收溢出的关键字实参 星星（**）：接收溢出的关键字实参，存成字典类型，然后赋值给（**）后面跟的那个变量名 用法一：在形参中使用（**）1234567891011def foo(x, y, **kwargs): # kwargs=&#123;'a':2, 'b':4, 'c':4&#125; print(x) print(y) print(z)foo(1, a=2, b=3, c=4, y=5)# 执行结果15&#123;'a': 2, 'b': 4, 'c': 4&#125; 用法二：在实参中使用（**）1234567891011def foo(x, y, **kwargs): print(x) print(y) print(z)foo(1, &#123;'a':2, 'c':3, 'b':10, 'y':111&#125;)# 执行结果1&#123;'a':2, 'c':3, 'b':10, 'y':111&#125;&#123;&#125; 1 赋值给了 x{‘a’:2, ‘c’:3, ‘b’:10, ‘y’:111} 赋值给了 y没有溢出的关键字参数，所以 **kwargs 为空 1234567891011def foo(x, y, **kwargs): # kwargs=&#123;'a':2, 'c':3, 'b':10&#125; print(x) print(y) print(z)foo(1, **&#123;'a':2, 'c':3, 'b':10, 'y':111&#125;) # foo&#123;1, y=111, a=2, b=10, c=3&#125;# 执行结果1111&#123;'a':2, 'c':3, 'b':10&#125; 1 赋值给了 x111 赋值给了 y{‘a’:2, ‘c’:3, ‘b’:10} 为溢出的关键字参数，赋值给了 **kwargs 12345678910def foo(x, y, **kwargs): print(x) print(y) print(z)foo(1, **&#123;'a':2, 'c':3&#125;) # foo(1, c=3, a=2)# 执行结果TypeError: foo() missing 1 required positional argument: 'y'缺少1个所需的位置参数：'y' 示例：把字典里的每个值取出来，分别赋值给 x, y, z 123456789101112def foo(x, y, z): print(x) print(y) print(z)d = &#123;'x': 1, 'y': 2, 'z': 3&#125;foo(d['x'], d['y'], d['z'])# 执行结果123 123456789101112def foo(x, y, z): print(x) print(y) print(z)d = &#123;'x': 1, 'y': 2, 'z': 3&#125;foo(**d) # foo(x=1, y=2, z=3)# 执行结果123 12345678910def foo(x, y, z): print(x) print(y) print(z)d = &#123;'x': 1, 'y': 2, 'z': 3, 'a': 10&#125;foo(**d) # foo(x=1, y=2, z=3, a=10)# 执行结果TypeError: foo() got an unexpected keyword argument: 'a' 12345678910def foo(x, y, z): print(x) print(y) print(z)d = &#123;'x': 1, 'y': 2,&#125;foo(**d) # foo(x=1, y=2)# 执行结果TypeError: foo() missing 1 required positional argument: 'z' 接收任意形式，任意长度的参数123456789def foo(*args, **kwargs): # args=(1, 2, 3) print(x) print(y)foo(1, 2, 3, a=1, b=2, c=3)# 执行结果(1, 2, 3)&#123;'a': 1, 'b': 2, 'c': 3&#125; 示例场景 12345678910def index(name, gender): print('welcome %s gender is %s' % (name, gender))def wrapper(*args, **kwargs): # args=(1,2,3) kwargs=&#123;'a':1, 'b':2&#125; index(*args, **kwargs) # index(*(1,2,3), **&#123;'a':1,'b':2&#125;) # index(1,2,3,a=1,b=2)wrapper(1, 2, 3, a=1, b=2)# 执行结果TypeError: index() got an unexpected keyword argument 'a' 123456789101112def index(name, gender): print('welcome %s gender is %s' % (name, gender))def wrapper(*args, **kwargs): # args=('zhangsan','male') kwargs=&#123;&#125; index(*args, **kwargs) # index(*('zhangsan','male'), **&#123;&#125;) # index('zhangsan','male')# wrapper('zhangsan', 'male')# wrapper(gender='male', name='zhangsan')wrapper('zhangsan', gender='male')# 执行结果welcome zhangsan gender is male]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python函数参数-可变长参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数参数]]></title>
    <url>%2F2018%2F08%2F12%2FPython%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Python函数参数 函数的参数氛围两大类：形参与实参 形参：指的是在定义函数时，括号指定的参数，本质就是“变量名”实参：指的是在调用函数时，括号内传入的值，本质就是值 123456789def foo(x, y): # x=1, y=2 print(x) print(y)foo(1, 2)# 输出结果12 只有在调用函数时才会在函数体内发生实参（值）与形参（变量名）的绑定关系该绑定关系只在调用函数时临时生效，在调用函数结束后就解除绑定 123456789def foo(x, y): # x=1, y=2 print(x) print(y)foo(1.3, &#123;'a': 1&#125;)# 输出结果1.3&#123;'a': 1&#125; 在传值的时候没有类型限制 位置参数 位置形参：在定义函数时，按照从左到右的顺序依次定义的形参称之为位置形参位置实参：在调用函数时，按照从左到右的顺序依次传入的值 1234567def foo(x, y, z): print(x, y, z)foo(1, 2, 3)# 输出结果1 2 3 位置形参：在定义函数时，按照从左到右的顺序依次定义的形参称之为位置形参凡是按照位置定义的形参，在调用函数时必须为其传值，多一个不行少一个也不行 12345678def foo(x, y, z): print(x, y, z)foo(1, 2)# 输出结果TypeError: foo() missing 1 required positional argument: 'z'# 缺少 1 个所需的位置参数 1234567def foo(x, y, z): print(x, y, z)foo(1, 2, 3, 4)# 输出结果TypeError: foo() takes 3 positional arguments but 4 were given 位置实参：在调用函数时，按照从左到右的顺序依次传入的值在传值时按照顺序与形参一一对应 1234567def foo(x, y, z): print(x, y, z)foo(3, 2, 1)# 输出结果3 2 1 缺点：基于位置的方式传值，按照顺序与形参一一对应，对应错了，传值就错了 1234567891011def register(name, sex, age): print(name) print(sex) print(age)register('egon', 'male', 18)# 输出结果egonmale18 关键字实参 关键字实参：在调用函数时，按照 key=value 的形式定义的实参，称之为关键字实参在传值时，可以完全打乱顺序，仍然能为指定的参数传值 1234567891011def register(name, sex, age): print(name) print(sex) print(age)register(name='egon', sex='male', age=18)# 输出结果egonmale18 123456789def register(name, sex, age): print(name) print(sex) print(age)register(sex='male', age=18)# 输出结果TypeError: register() missing 1 required positional argument: 'name' 在调用函数时，可以混合使用位置实参和关键字实参但是位置实参必须在关键字实参的左边 123456789def register(name, sex, age): print(name) print(sex) print(age)register(name='egon', 'male', age=18)# 输出结果SyntaxError: positional argument follows keyword argument 不能为同一个形参重复传值 123456789def register(name, sex, age): print(name) print(sex) print(age)register('male', name='egon', age=18)# 输出结果TypeError: register() got multiple value for argument 'name' 1234567891011def register(name, sex, age): print(name) print(sex) print(age)register('egon', age=18, sex='male')# 输出结果egonmale18 默认参数 形参在定义时就已经为其赋值可以传值也可以不传值经常需要变得参数定义成位置形参，变化较小的参数定义成默认参数（形参）注意： 在定义阶段已经赋值，在调用阶段可以不用为其传值 默认参数的定义应该在位置形参右边 默认参数通常应该定义成不可变类型 1234567891011def foo(x, y, z=3): print(x) print(y) print(z)foo(1, 2)# 输出结果123 如需传值，以新的值为准 1234567891011def foo(x, y, z=3): print(x) print(y) print(z)foo(1, 2, 4)# 输出结果124 经常需要变得参数定义成位置形参，变化较小的参数定义成默认参数（形参） 1234567def register(name, sex='female', age): print(name) print(sex) print(age)# 执行结果SyntxError: non-default argument follows default argument 默认参数的定义应该在位置形参右边 1234567891011121314151617181920212223def register(name, age, sex='female'): print(name) print(sex) print(age)register('wxx', 38)register('lxx', 48)register('cxx', 28)register('alex', 73, 'male')# 输出结果wxxfemale38lxxfemale48cxxfemale28alexmale73 默认形参的值只在定义阶段生效一次，在函数定义之后发生的改动无效 12345678910111213m = 10def foo(x, y, z=m): print('x: %s' % x) print('y: %s' % y) print('z: %s' % z)m = 123456foo(1, 2)# 执行结果x: 1y: 2z: 10 默认参数通常应该定义成不可变类型 123456789101112def foo(name, hobby, l=[]): # 这里 l=[] 默认参数为可变类型 l.append(hobby) print('%s 的爱好是 %s' % (name, l))foo('张三', 'read')foo('李四', '吃饭')foo('王五', '睡觉')# 执行结果张三 的爱好是 ['read']李四 的爱好是 ['read', '吃饭']王五 的爱好是 ['read', '吃饭', '睡觉'] 问题：三次调用之间彼此之间有关联，一次调用基于上次的结果继续调用注意：函数定义的时候一定要做到函数的解耦合性 12345678910111213def foo(name, hobby,): l = [] l.append(hobby) print('%s 的爱好是 %s' % (name, l))foo('张三', 'read')foo('李四', '吃饭')foo('王五', '睡觉')# 执行结果张三 的爱好是 ['read']李四 的爱好是 ['吃饭']王五 的爱好是 ['睡觉'] 123456789101112def foo(name, hobby, l=None): if l is None: l = [] l.append(hobby) print('%s 的爱好是 %s' % (name, l))foo('张三', 'read', ['music', 'movie']])foo('李四', '吃饭', ['撸串',])# 执行结果张三 的爱好是 ['music', 'movie', 'read']张三 的爱好是 ['撸串', '吃饭'] 1234567891011121314151617def foo(name, hobby, l=None): if l is None: l = [] l.append(hobby) print('%s 的爱好是 %s' % (name, l))l1 = []foo('张三', 'read', l1)foo('张三', '音乐', l1)foo('张三', '旅行', l1)foo('李四', '吃饭')foo('王五', '睡觉')# 执行结果张三 的爱好是 ['read', '音乐', '旅行']李四 的爱好是 ['吃饭']王五 的爱好是 ['睡觉']]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack_network模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack_network%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[network模块 返回 Minion 主机的网络信息 获取 minion01 主机 ping 域名信息1salt 'minion01' network.ping www.baidu.com 获取 minion 的主机名1salt '*' network.get_hostname 获取指定网络接口的 mac 地址1salt '*' network.hw_addr eth0 获取主机是否在某个子网内 在就返回True，如果不在的话就返回 False，多子网用空格隔开1salt '*' network.in_subnet 192.168.1.0/24 查看 minion 端绑定的 IP 地址 多 IP 也会显示出来，127.0.0.1 除外1salt '*' network.ip_addrs 显示所有接口的详细信息 但是别名的网卡类似于 eth0:1 这种不会显示1salt '*' network.interfaces 显示指定网卡接口上面的 IP 只会显示IP不会显示其他内容1salt '*' network.interface_ip eth0 network.interface 会连网关子网掩码也显示 修改某一个 minion 的主机名 显然这一步操作只适合在初始化的时候而且不适合执行所有主机1salt 'agent1.salt' network.mod_hostname test1.salt 显示的 ping 的结果信息 如果不加 return_boolean=True 显示的是 ping 的结果信息，加了就是如果 ping 通了就返回 True，ping不通就返回 False1salt '*' network.ping www.baidu.com return_boolean=True timeout=3 timeout=3 就是 ping 的时间，3秒超时这样能快速返回结果这个其实挺好用的，比如我们可以测试哪些主机的 DNS 设置有问题不能正常解析啊，或者是我们内网 DNS 指向了一个非公网的域名解析，可以通过这个看哪些主机设置了内网 DNS 而哪些没设置内网 DNS 获取主机所属的子网1salt '*' network.subnets]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack_network模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack_host模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack_hosts%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[hosts 模块 通过这个命令可以查看详细用法1salt '*' sys.doc hosts 我们生产中如果没有用内建 DNS 服务，使用 hosts 模块修改 /etc/hosts 还是经常会用到的 hosts.add_host 追加123salt '*' hosts.add_host 192.168.1.113 minion01# hosts.add 会先判断 /etc/hosts 里面有没有这个 IP 192.168.1.113# 如果有 minion01 会将 alias 名追加到这个 IP 后面，跟之前的解析别名一起使用这个 IP 12salt '*' hosts.add_host 192.168.1.114 minion01# 如果没有这个 IP，则会新创建一行 hosts 记录，但是 192.168.1.113 那条还是存在的。两条记录 hosts.set_host 覆盖123salt '*' hosts.set_host 192.168.1.114 minion02hosts.set_host 这个的不同之处就是，如果这个 IP 不存在则创建新的一条 hosts 记录，如果 hosts 存在这个 IP 的解析记录。会完全覆盖掉也就是旧的 IP 解析记录完全变成现在的结果 hosts.rm_host 删除123salt '*' hosts.rm_host 192.168.1.114 minion02# 删除 192.168.1.114 minion02 这条解析记录# 如果 192.168.1.114 这行有多条解析记录，而只会删除 minion02 这条记录，其他的 192.168.1.114 xxx.xxx，还会存在不会删除，可以说是有选择性的删除 查看 hosts 解析的用法 123# 192.168.1.114 这个 IP 对应的别名解析salt '*' hosts.get_alias 192.168.1.114# 如果有则返回对应的 hosts 别名解析记录，没有则什么都不返回 123# 这个就是返回 minion01 在 /etc/hosts 里面对应的 IPsalt '*' hosts.get_ip minion01# 但是有个问题，如果有多条只会返回文件最上方的那一条对应的 IP 地址 12# 如果有这条别名解析记录，则返回True，如果没有则返回Falsesalt '*' hosts.has_pair 192.168.1.113 minion01 1234# 类似于 cat /etc/hosts 的操作salt '*' hosts.list_hosts# 不同的是，这相当于一个汇总，会以第一行是 IP：下一行是其对应的别名解析的方式来呈现# 比如一个 IP 有好几行的解析，这所有的解析记录都会汇总到这个 IP 下面，注释过的别名解析的行不会出现在这个汇总信息里面 dnsutil 模块 Minion 主机通用 DNS 操作添加 192.168.2.71 www.test.com 到 minion01 端 /etc/hosts 下1salt 'minion01' dnsutil.hosts_append /etc/hosts 192.168.2.71 www.test.com]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack_host模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack_group模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack_group%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[group 模块 添加指定用户组 group.add 方法123[root@salt-master ~]# salt 'salt-minion02' group.add user1 1000salt-minion02: True 返回用户组信息 group.info 方法12345678910[root@salt-master ~]# salt 'salt-minion02' group.info user1salt-minion02: ---------- gid: 1000 members: name: user1 passwd: x 返回所有用户组的信息 group.getent 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485[root@salt-master ~]# salt 'salt-minion02' group.getentsalt-minion02: |_ ---------- gid: 0 members: name: root passwd: x |_ ---------- gid: 1 members: - bin - daemon name: bin passwd: x |_ ---------- gid: 2 members: - bin - daemon name: daemon passwd: x |_ ---------- gid: 3 members: - bin - adm name: sys passwd: x |_ ---------- gid: 4 members: - adm - daemon name: adm passwd: x |_ ---------- gid: 5 members: name: tty passwd: x |_ ---------- gid: 6 members: name: disk passwd: x |_ ---------- gid: 7 members: - daemon name: lp passwd: x |_....... 添加一个用户到指定组中 group.adduser 方法必须是一个已经存在的组和已存在的用户123[root@salt-master ~]# salt 'salt-minion02' group.adduser user1 zabbixsalt-minion02: True 将用户从用户组中移除 group.deluser 方法123[root@salt-master ~]# salt 'salt-minion02' group.deluser user1 zabbixsalt-minion02: True 移除指定用户组 group.delete 方法123[root@salt-master ~]# salt 'salt-minion02' group.delete user1salt-minion02: True]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack_group模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack_user模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack_user%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[user模块 用于用户管理，如创建用户，删除用户，更改用户信息等官方文档https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.useradd.html 在 minion 端上创建一个用户 语法1salt '*' user.add name &lt;uid&gt; &lt;gid&gt; &lt;groups&gt; &lt;home&gt; &lt;shell&gt; 创建用户 创建一个 test 用户，其它都和 useradd 一样默认12345salt * user.add test[root@salt-master ~]# salt 'salt-minion02' user.add test 610 605 zabbix /home/test /bin/bashsalt-minion02: True 获取用户信息 user.info 方法返回用户信息123456789101112131415161718192021[root@salt-master ~]# salt 'salt-minion02' user.info testsalt-minion02: ---------- fullname: gid: 605 groups: - zabbix home: /home/test homephone: name: test passwd: x roomnumber: shell: /bin/bash uid: 610 workphone: 获取所有系统用户信息的列表 user.getent 方法返回所有系统用户信息的列表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@salt-master ~]# salt 'salt-minion02' user.getent salt-minion02: |_ ---------- fullname: root gid: 0 groups: - root home: /root homephone: name: root passwd: x roomnumber: shell: /bin/bash uid: 0 workphone: |_ ---------- fullname: bin gid: 1 groups: - bin - daemon - sys home: /bin homephone: name: bin passwd: x roomnumber: shell: /sbin/nologin uid: 1 workphone: ...... 查看所有用户 查看所有用户1salt * user.list_users 列出指定用户所属组的列表 user.list_groups 方法列出指定用户所属组的列表123[root@salt-master ~]# salt 'salt-minion02' user.list_groups zabbixsalt-minion02.contoso.com: - zabbix 创建用户指定 shell 创建用户时指定 shell1salt * user.add test shell=/sbin/nologin 创建用户时指定不创建家目录 创建用户时指定不创建家目录1salt * user.add test createhome=False 创建用户时指定附加组 创建用户时指定附加组1salt * user.add test groups=nginx 将用户加入到其他组，为附加组 将 test 用户加入到 nginx 组，此为附加组1salt * user.chgroups test nginx 查看用户所有的组 查看 test 用户所有的组1salt * user.list_groups test 删除用户 user.delete 方法删除 test 用户1salt * user.delete test remove=True 在 minion 端删除一个用户123[root@salt-master ~]# salt 'salt-minion02' user.delete testsalt-minion02: True 修改用户名 user.rename 方法123[root@salt-master ~]# salt 'salt-minion02' user.rename test testusersalt-minion02.contoso.com: False 虽然返回 False 但是操作是成功完成了的 编辑 user.sls 文件12345678vim /srv/salt/nginx/create_users.sls# usernginx_user: user.present: # 用户创建 - name: nginx - createhome: False # 不用家目录 - gid_from_name: True - shell: /sbin/nologin # 指定shell]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack_user模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack_archive模块]]></title>
    <url>%2F2018%2F08%2F08%2FSaltStack_archive%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[archive 模块 主要用于打包，压缩和归档使用官方文档https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.archive.html实现系统层面的压缩包调用，支持 gunzip、gzip、rar、tar、unrar、unzip 等 可以设置为 “jinja” 或另一个受支持的模板引擎，以便在执行之前呈现命令参数1salt '' archive.tar cjvf /tmp/salt.tar.bz2 &#123;&#123;grains.saltpath&#125;&#125; template=jinja 将 /tmp/file_1,/tmp/file_2 打包压缩成 tarfile.tar.bz2 文件 到 /tmp 目录下1salt '' archive.tar cjvf /tmp/tarfile.tar.bz2 /tmp/file_1,/tmp/file_2 解压缩 foo.tar 文件到 /target/directory 目录下1salt '*' archive.tar xf foo.tar dest=/target/directory 执行压缩命令1234567salt '*' archive.tar zcvf /root/test.tar.gz /root/python,/root/testa192.168.10.249:- tar: Removing leading `/' from member names- /root/python/- /root/python/p2- /root/python/p1- /root/testa 通过该方法压缩的文件，解压后带有全路径，可通过 cwd 指定执行的目录123456salt '*' archive.tar zcvf /root/test/test.tar.gz python,testa cwd=/root192.168.10.249:python/python/p2python/p1testa 执行解压缩命令123456salt '*' archive.tar zxvf /root/test/test.tar.gz dest=/root/test192.168.10.249:- python/- python/p2- python/p1- testa 12345678# 采用 gzip 压缩 sourcefile.txt 文件salt '*' archive.gzip sourcefile.txt# 采用 gzip 压缩 test.txt 文件salt 'minion01' archive.gzip test.txt# 采用 gunzip 解压 sourcefile.txt.gz 包salt '*' archive.gunzip sourcefile.txt.gz 12345# 解压在 /root 目录下salt 'minion01' archive.tar xf /tmp/access.tar.gz# 压缩在 /tmp 目录下salt 'minion01' archive.tar /tmp/test.txt 1234567891011121314151617181920# 打包指定文件，多个文件使用空隔分开，打包后的名称为 test.zipsalt minion* archive.cmd_zip /opt/test.zip /tmp/test.sh# 打包目录salt minion* archive.cmd_zip /opt/test.zip /tmp/init# 将 init.zip 解压至 /root 目录下面salt minion* archive.cmd_unzip /opt/init.zip /root/# 将 test.sh 打包为 test.sh.gz，打包后就在当前目录salt minion* archive.gzip /tmp/test.sh# 将 test.sh.gz 解压，解压后就在当前目录salt minion* archive.gunzip /tmp/test.sh.gz# 对 /tmp/init 目录打包后压缩为 tar.gzsalt minion* archive.tar czvf /opt/init.tar.gz /tmp/init# 解压 init.tar.gz，默认放到 /root 目录下面，因为 minion 进程是以 root 用户启动的salt minion* archive.tar xvzf /opt/init.tar.gz api 调用12client.cmd('*', 'archive.gunzip', ['sourcefile.txt.gz'])client.cmd('minion01', 'archive.tar', ['xf', '/tmp/access.tar.gz']) 通过 Python 扩展模块，使用 API通过调用 master client 模块，实例化一个 LocalClient 对象，再调用 cmd() 方法来实现12345678910# API 实现 archive.gzipvim archive_gzip.pyimport salt.clientclient = salt.client.LocalClient()res = client.cmd('*', 'archive.gzip', '/tmp/test.txt')print(res)# 执行结果返回一个字典&#123;'minion01': '/tmp/test.txt.gz'&#125;]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack_archive模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SaltStack常用模块]]></title>
    <url>%2F2018%2F08%2F07%2FSaltStack%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[SaltStack 常用模块 SaltStack 内置模块汇总1acl, aliases, alternatives, apache, archive, artifactory, blockdev, btrfs, buildout, cloud, cmd, composer, config, container_resource, cp, cron, data, defaults, devmap, dig, disk, django, dnsmasq, dnsutil, drbd, elasticsearch, environ, etcd, event, extfs, file, gem, genesis, git, grains, group, grub, hashutil, hg, hipchat, hosts, http, img, incron, ini, introspect, ip, iptables, jboss7, jboss7_cli, key, kmod, locale, locate, logrotate, lowpkg, match, mine, modjk, mount, network, openstack_config, pagerduty, pillar, pip, pkg, pkg_resource, postfix, publish, puppet, pyenv, raid, random, random_org, rbenv, ret, rsync, runit, rvm, s3, saltutil, schedule, scsi, sdb, seed, selinux, serverdensity_device, service, shadow, slack, smtp, sqlite3, ssh, state, status, supervisord, sys, sysctl, syslog_ng, system, test, timezone, user, vbox_guest, virtualenv, webutil, xfs SaltStack 常用模块介绍这里重点是要将经常用到的模块记录的用法记录下来，直接在 master 端用 salt 命令可以做一些简单的操作，也为做 .sls文件 打基础。 cmd 模块常用方法12salt 'agent1.salt' sys.doc cmd# 可以看 cmd 模块都有哪些使用方法，这里只列举常用的 cmd.has_exec 用法 如果可执行文件在 minion 上可用，则返回true，否则返回false 12# 这里只能是单个命令，如果你用 'ip addr' 这种形式的话，肯定返回的是 Falsesalt '*' cmd.has_exec ifconfig cmd.retcode 用法 在 minion 端执行一个 shell 命令并返回命令的返回码。0 表示成功，0 以外表示失败有问题。123salt '*' cmd.retcode 'ls -l /etc/hostname'# 如我们可以查看一个文件是否存在根据返回码来判断，或者执行一个脚本等，''里面就是你要执行的命令# 正好跟 cmd.has_exec 相反 cmd.run 用法 这个执行 shell 命令跟 cmd.retcode 类似，但是不同的是，cmd.run 就像在本地执行一样。cmd.run_stderr 意思只会在出问题的时候返回信息。 1234567891011121314151617[root@master ~]# salt '*' cmd.retcode 'cat /root/1'zwidc_kvm_192.168.1.104: 0agent1.salt: 0[root@master ~]# salt '*' cmd.run 'cat /root/1'agent1.salt: 123zwidc_kvm_192.168.1.104:[root@master ~]# salt '*' cmd.run_stderr 'cat /root/1'agentl.salt:zwidc_kvm_192.168.1.104:[root@master ~]# salt '*' cmd.run_stderr 'cat /root/6'agent1.salt: cat: /root/6: No such file or directoryzwidc_kvm_192.168.1.104: cat: /root/6: No such file or directory cmd.script 和 cmd.script_retcode 从远程 salt 服务器 或 ftp 服务器 或 http 服务器 下载脚本到本地执行 12salt '*' cmd.script salt://scripts/runme.shsalt '*' cmd.script salt://scripts/runme.sh 'arg1 arg2 "arg 3"' cmd.shell 和 cmd.shells cmd.shell 跟 cmd.run 一样一般用 cmd.run, cmd.shells 是通过 /etc/shells 文件列出此系统上的有效 shell 1234567891011121314[root@master ~]# salt '*' cmd.shellszwidc_kvm_192.168.1.104: - /bin/sh - /bin/bash - /sbin/nologin - /user/bin/sh - /usr/bin/bash - /usr/sbin/nologinagent1.salt: - /bin/sh - /bin/bash - /sbin/nologin - /bin/dash cmd.which 和 cmd.which_bin 用法 就是查找执行文件所在的位置，which 命令嘛都不陌生1234567891011121314151617181920# 查看节点所有 ifconfig 命令的位置，在写脚本或者定时任务的时候很有用salt '*' cmd.which ifconfig# 因为系统不同执行文件的绝对路径也不同 和 salt '*' cmd.run "which ifconfig" 一个效果# 这是定义了一个列表，返回在命令列表中找到的第一个命令salt '*' cmd.which_bin '[cat, ifconfig, touch]'# 存在就返回第一个命令的路径[root@master ~]# salt '*' cmd.which_bin '[cat, ifconfig, touch]'agent1.salt: /bin/catzwidc_kvm_192.168.1.104: /usr/bin/cat# 如果第一个命令不存在就往后寻找[root@master ~]# salt '*' cmd.which_bin '[cat, ifconfig, touch]'zwidc_kvm_192.168.1.104: /usr/bin/ifconfigagent1.salt: /bin/ifconfig cp模块常用方法 只列举一些常用的，详细的可以自行执行此命令查看 1salt 'agent1.salt' sys.doc cp cp.get_dir 和 cp.get_file 用法 就是从 master 端 cp 目录 或 文件 到 minion 端的目录，get_dir 支持与 get_file 相同的模板和 gzip 参数。对应的是 cp.push，cp.push_dir，就是把客户端的文件 或 目录推送到 master 端的 cachedir，默认为 /var/cache/salt/master/minions/minion-id/files，但是这种用法是禁用状态，一般不让 minion 端的文件或目录发送到 master 端，这里只是记录一下有这种用法。 12345678# 从 salt master 递归复制目录到 minion 客户端的 /minion/dest 目录下面salt '*' cp.get_dir salt://path/to/dir/ /minion/dest# 从服务端拷贝单个文件到 minion 端的 /minion/dest 目录下面salt '*' cp.get_file salt://path/to/file /minion/dest# 所有 Salt minions 从与其 os 粒度相同名称的目录下载 vimrc，并将其复制到 /etc/vimrcsalt '*' cp.get_file "salt://&#123;&#123;grains.os&#125;&#125;/vimrc" /etc/vimrc template=jinja cp.get_url 用法 用于从 URL 获取单个文件 1234567891011121314151617181920212223242526272829# 将 salt://cptest1/cptest1file 文件里面的内容写入到 /tmp/test 文件里面，每次都会覆盖里面的内容# 这种就跟 cp.get_file 一样salt '*' cp.get_url salt://cptest1/cptest1file /tmp/test# 如这种就把一个页面的 html 信息写入到了客户端的 /tmp/test 文件，切记只能是这种文本形式的文件，不要是压缩包啥的salt '*' cp.get_url http://blog.51niux.com/?id=116 /tmp/test# 最主要的用法还是这种，我们可以以 httpd 的形式去下载一个 sh 脚本，config 文件等salt '*' cp.get_url http://blog.51niux.com/zb_users/upload/2017/03/201703091489030442220789.txt /tmp/load_one_check.shsalt '*' cmd.run " cat /tmp/load_one_check.sh"# 下面是部分内容，这样我们很多文本类的文件就不用从 salt 服务端发布了，直接做个 ftp 服务 或 http 服务来发布文本类的东西什么的就可以了。当然 cmd.run 命令也可以了...agent1.salt: #!/bin/bash # ======================================================================================== # System loadavg plugin for Nagios # # Written by : chaishao # From : 51niux.com # Release : 1.1.0 # Creation date : 2017-03-08 # Revision date : 2017-03-08 # Description : Nagios plugin (script) to check system load_one . # This script has been designed and written on Linux System. # # USAGE : ./$PROGNAME [-w -c] # # Exemple: : ./$PROGNAME -w n1 -c n2 # ======================================================================================== cp.list_master 和 cp.list_master_dirs 用法 这个就是查看 salt master 本地的 file 服务器又哪些文件 或 目录 12345# 这种就不要指定所有机器了，匹配一台机器就可以了，列出存储在主机上的所有文件salt 'agent1.salt' cp.list_master# 列出存储在 master 主机上面的所有目录salt 'agent1.salt' cp.list_master_dirs 123456789101112# 查看目录下的文件[root@master cptest2]# salt 'agent1.salt' cp.list_masteragent1.salt: - cptest1/cptest1file# 只会将目录列出来以及子目录[root@master cptest2]# salt 'agent1.salt' cp.list_master_dirsagent1.salt: - . - cptest1 - cptest2 - cptest2/cptest2dir file 模块常用方法file.access 用法 f 代表存在rwx 分别代表读、写、执行权限file.file_exists、file.get_mode 和 file.stats 的用法1234567891011121314151617181920212223# 查看 /opt/check.sh 文件是否存在，这个挺有用的salt '*' file.access /opt/check.sh f# 我们查看某个脚本或者某个文件是否存在# 上面的例子也可以写成这种salt '*' file.file_exists /opt/check.sh# 文件存在就返回True，否则返回False# 如果有此脚本之后，我们还可以查看此脚本是否具有执行权限salt '*' file.access /opt/check.sh x# f、r、w、x 只能写一种，真就返回true，否则falsesalt '*' file.get_mode /etc/passwd# file.get_mode 后面指定目录或者文件，可以查看其授权情况，如文件一般是0644，如果文件或目录不存在无信息# 还有# file.is_blkdev 检查文件是否存在并且是块设备# file.is_chrdev 检查文件是否存在并且是字符设备# file.is_fifo 检查文件是否存在并且是FIFO# file.is_link 检查路径是否是符号链接）# file.stats 返回一个文件 或 目录的统计信息salt '*' file.stats /etc/passwd# 这里是返回 /etc/passwd 文件的统计信息（类型，时间，属组，权限等） file.append 和 file.write 用法 前者将内容追加到文件的末尾，后者是直接覆盖类似于 echo &gt;，但是格式跟前者一样 12345678910111213# 第一组：单引号 和 双引号 的区别，还有 ! 需要注意的地方salt '*' file.append /tmp/1 "`hostname` This is a good day\!"# 用双引号，就是里面可以接变量，但是这个 ! 需要注意，不用 \ 转义的话会报错# salt '*' file.append /tmp/1 '`hostname` This is a good day!'# 所以如果出现 ! 最好放到单引号里面来引用，因为上面就算转义了也显示的不对# 第二组：换行符的使用salt '*' file.append /tmp/1 "Two""Two Two"# 这表示两组字符串在一行，中间默认加个空格隔开# 这表示两组字符串是换行的salt '*' file.append /tmp/1 "Two" "Two Two" 1234567[root@activemq ~]# cat /tmp/1master.hadoop This is a good day\!'hostname' This is a good day!TwoTwo TwoTwoTwo Two[root@activemq ~]# 上面两组测试结果，可以明显的比较出差别 1234567891011121314151617# 第三组：! 是不知道怎么解决了，要么就放单引号# 还有个 = 是需要注意的，有个 args 用法，以及 [] 外面加不加双引号的区别# 如果字符串里面有等号要用这种 args 的用法salt '*' file.append /tmp/1 args='Hostname=`hostname`'# args 用 单引号 和 双引号 的区别就在于里面的变量是否解析为变量的值还是字符串salt '*' file.append /tmp/1 args="Hostname=`hostname`"# 这里就是定义一个并排的两个字符串salt '*' file.append /tmp/1 args=['Hostname=`hostname`''rel=`cat /etc/redhat-release`']# 可见 args 默认是单引号的形式，两组字符串中间加逗号salt '*' file.append /tmp/1 args=['Hostname=`hostname`','rel=`cat /etc/redhat-release`']# 双引号 不是默认的，所以要单独的加上salt '*' file.append /tmp/1 args="['Hostname=`hostname`','rel=`cat /etc/redhat-release`']" 12345678[root@activemq !]# cat /tmp/1Hostname= hostnameHostname=master.hadoopHostname='hostname'rel='cat /etc/redhat-release'Hostname='hostname'rel='cat /etc/redhat-release'Hostname=master.hadooprel=CentOS release 6.4 (Final) 从结果我们可以看出，两个字符串之间如果没有逗号的话，不换行，但是中间也没有分隔，可以学习 awk，在两个字符串中间加 “ “ 来进行添加空格的操作。其实主要还是字符串里面有=就用 args 的形式，如果是多组字符串可以用[]的形式，如果要是用变量就用双引号的形式，默认是单引号的形式。 file.chgrp、file.chown 和 file.set_mode 用法 前者是更改文件的属组，中者是更改文件数的属主属组，后者是更改文件或目录的权限 1234567891011# 将 minion 端的 /tmp/1 文件更改用户组为 test9salt '*' file.chgrp /tmp/1 test9# 如果客户端有此用户组则返回 None，没有此用户组则返回用户组不存在# 第一个是用户，第二个是用户组，固定格式必须存在salt '*' file.chown /tmp/1 test7 test9# 将 /tmp/1 的用户组设置为 test7，用户组设置为 test9# 设置 /opt/cs 目录权限为 0550salt '*' file.set_mode /opt/cs 0550# 如果授权成功会显示授权后的权限，如果没有此文件或目录会提示 file.comment 和 file.comment_line 用法 注释指定内容的行，每次操作前都会更新文件名命令的 .bak 备份文件12345678910# 这就是将以 /tmp/passwd 文件以 ftp 开头的行注释掉salt '*' file.comment /tmp/passwd ftp# 如果注释会显示注释行的信息，如果没注释则返回False# 另外还支持正则表达式，这里就表示以 ftp 开头以 nologin 结尾的行，多行注释salt '*' file.comment /tmp/passwd ftp.*nologin$# 后面可以指定在行开头加什么字符，当然默认是 #salt '*' file.comment /tmp/passwd ftp.*nologin$ '-'# 前面也可以这样后面指定要行头添加的字符 file.copy 用法 复制文件 或 目录到指定的目录下面，成功返回True，失败会有提示的另外还有 file.move，移动文件的用法 12345678910111213141516# 这里是文件拷贝，将文件 /path/to/src 拷贝到 /path/to/ 目录下面，其名称为 dstsalt '*' file.copy /path/to/src /path/to/dst# 切记这里一定要是文件名# 目录复制的区别看下面的例子# 复制目录的话，要加 recurse=True 递归标记salt '*' file.copy /opt/file2 /tmp/haha/ recurse=True# 这种不管是 /tmp/haha/ 还是 /tmp/haha，如果这个 haha 存在的话，就是将 /opt/file2 下面的内容 cp -r 拷贝到 /tmp/haha 目录下面，如果 haha 目录不存在的话，就是将 /opt/file2 目录变为 /tmp/haha 目录# 这种才是正确的将 /opt/file2 目录复制到 /tmp/haha/ 目录下方salt '*' file.copy /opt/file2 /tmp/haha/file2 recurse=True# 如 haha 目录不存在会创建# remove_existing=True 这种就是完全覆盖的形式salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True remove_existing=True file.directory_exists 和 file.dirname 用法 前者检查一个目录是否存在，后者取文件的路径 12345678# /tmp/haha/file 目录存在就会返回True，不存在就会返回Falsesalt '*' file.directory_exists /tmp/haha/file2# 取出来的结果是 /opt/file2，这就是末尾加 /，认为这两个都是目录，当然不管是否有这个目录salt '*' file.dirname '/opt/file2/'# 取出来的结果是 /opt/file2salt '*' file.dirname '/opt/file2/test1' file.find 用法 类似于 Linux下面的 find 命令 123456789101112131415161718192021222324252627282930313233343536salt '*' file.find / type=f name=\*.bak size=+10m# 查找/目录下，文件类型为文件的# a：所有文件类型# b：块设备# c：字符设备# d：目录# p：FIFO（命名管道）# f：普通文件# l：符号链接# s：套接字，名称为 .bak 结尾的（这里支持正则表达式），大小大于 10MB 的文件# b：字节# k：千字节# m：兆字节# g：GB# t：太字节也是TBsalt '*' file.find /var mtime=+30d size=+10m print=path,size,mtime# 这里是查找 /var 目录下，最后一次更改时间是 30 天以前# w：周# d：天# h：小时# m：分钟# s：秒，大小大于 10MB 的文件，并打印文件的路径，大小，更改时间# 可打印的内容有# group：组名# md5：文件内容的 MD5 摘要# mode：文件权限（以整数形式）# mtime：最后修改时间# name：文件基础名称# path：文件绝对路径# size：文件大小（以字节为单位）# type：文件类型# user：用户名salt '*' file.find /var/log name=\*.[0-9] mtime=+30d size=+10m delete# find 的匹配条件有（name区分大小写，iname不区分大小写，type类型，user用户，group用户组，size[+-]大小，mtime修改时间，grep搜索文件内容），最后执行的动作除了 delete 和 print，还有 exec command file.get_gid、file.get_uid 和 file.get_group、file.get_user 用法 前一组返回文件或目录的 gid号 和 uid号，后一组返回文件或目录 group 和 user 1234567# 查看 /etc 目录的属组salt '*' file.get_user /etc# 如果文件或目录不存在返回 false# 查看 /etc 目录的属组的 uid 号salt '*' file.get_uid /etc# 如果目录或者文件不存在返回 -1 file.grep 用法 类似于 Linux上面的 grep 命令 12345678910111213salt '*' file.grep /etc/passwd nobody# 过滤 /ect/passwd 文件中包含 nobody 的行# 输出：pid: 是 grep 运行的 pid 号# retcode: 为状态码# 0 是成功过滤 1 为非成功过滤# stderr: 错误输出# stdout: 正常输出也就是我们要过滤的内容# "-i" 的目的是不区分大小写，注意 -i 前面有空格，额外的参数之间都有空格salt '*' file.grep /etc/sysconfig/network-scripts/ifcfg-eth0 ipaddr " -i" # -B2 就是连上面两行也过滤出来，-A2 就是连下两行也过滤出来salt '*' file.grep /etc/sysconfig/network-scripts/ifcfg-eth0 ipaddr " -i -B2 -A2" file.link 和 file.symlink 用法 前者是创建文件的硬链接，后者是创建符号链接也就是软链接 12345# 为 /tmp/1 创建一个硬链接是 /tmp/2，只能是文件salt '*' file.link /tmp/1 /tmp/2# 为 /tmp/haha 目录创建一个软链接 /tmp/buhaha，成功返回 Ture，失败有提示信息salt '*' file.symlink /tmp/haha /tmp/buhaha file.mkdir 和 file.makedirs 用法 两种都是创建目录，前者对结尾的/不敏感，后者对/敏感 1234567# 这就是在 /opt/ 目录下面创建 cs 目录，并在 cs 目录下面创建 ds 目录salt '*' file.mkdir /opt/cs/ds# 如果 cs 目录不存在就创建。目录存不存在也不会有提示# 这里只会创建 /opt/cs 目录，首先如果 /opt 要创建的目录是存在的会有提示salt '*' file.makedirs /opt/cs/ds# /opt/cs/ds/ 才会在 cs 目录下面创建 ds 目录 file.remove、file.rmdir 和 file.rename 用法 前者是删除文件或者目录，中间是删除目录但是目录一定要为空、后者是重命名文件或目录 123456789# 删除 /opt 目录下面的 cs 目录salt '*' file.remove /opt/cs/# 删除 /opt/cs 目录salt '*' file.rmdir /opt/cs# 如果 cs 目录下面有内容会提示目录不会空删除失败，如果为空则会执行并返回 True# 更改 /opt/cs 目录下的 ds 目录为 dss 目录salt '*' file.rename /opt/cs/ds /opt/cs/dss file.touch 和 file.truncate 的用法12345# 文件不存在则创建此文件，如果文件存在里面的内容不会发生变化，但是它的 time 信息会更新，上级目录必须存在salt '*' file.touch /tmp/test1# 将 /tmp/passwd 第三个字段以后的内容全删除掉了，就剩下了 roo 三个字段salt '*' file.truncate /tmp/passwd 3 hosts模块常用方法12# 通过这个命令可以查看详细用法，如果没有用 内建DNS服务，使用 hosts 模块修改 /etc/hosts 还是经常会用到的salt '*' sys.doc hosts hosts.add_host、hosts.rm_host 和 hosts.set_host 用法 前者是追加，中着是删除、后者是覆盖 123456789101112131415# hosts.add 会先判断 /etc/hosts 里面有没有这个 IP 192.168.1.113，如果有 foreman.puppet 会将 alias 名追加到这个 IP 后面，跟之前的解析别名一起使用这个 IPsalt '*' hosts.add_host 192.168.1.113 foreman.puppet# 如果没有这个IP，则会新创建一行 hosts 记录，但是 192.168.1.113 那条还是存在的，两条记录salt '*' hosts.add_host 192.168.1.114 foreman.puppet# hosts.set_host 这个的不同之处就是# 如果这个 IP 不存在则创建新的一条 hosts 记录# 如果 hosts 存在这个 IP 的解析记录，会完全覆盖掉，也就是旧的 IP 解析记录完全变成现在的结果salt '*' hosts.set_host 192.168.1.114 test.hahahah# 删除 192.168.1.114 test.haha 这条解析记录salt '*' hosts.rm_host 192.168.1.114 test.haha# 如果 192.168.1.114 这行有多条解析记录，而只会删除 test.haha 这条记录# 其他的 192.168.1.114 xxx.xxx，还会存在不会删除，可以说是有选择性的删除 其他查看 hosts 解析的用法12345678910111213# 192.168.1.114 这个 IP 对应的别名解析，如果有则返回对应的 hosts 别名解析记录，没有则什么都不返回salt '*' hosts.get_alias 192.168.1.114# 这个就是返回 wo.haha 在 /etc/hosts 里面对应的IP# 但是有个问题，如果有多条只会返回文件最上方的那一条对应的 IP 地址salt '*' hosts.get_ip wo.haha# 如果有这条别名解析记录，则返回True，如果没有则返回Falsesalt '*' hosts.has_pair 192.168.1.113 foreman.puppet# 类似于 cat /etc/hosts 的操作salt '*' hosts.list_hosts# 但是不同的是，这相当于一个汇总，会以第一行是IP：下一行是其对应的别名解析的方式来呈现，比如一个 IP 有好几行的解析，这所有的解析记录都会汇总到这个 IP 下面，注释过的别名解析的行不会出现在这个汇总信息里面 cron模块常用方法cron.raw_cron 用法 cron.list_tab 和 cron.ls 和跟其效果一样，格式也一样必须要指定某一个用户，都是显示指定用户 crontab 文件里面的定时任务 1salt '*' cron.raw_cron root #必须指定用户，这里是显示root的crontab文件里面的内容，注释的行也会显示 cron.set_job 用法 为指定用户设置一个定时任务 123salt '*' cron.set_job root '0' '0' '*' '*' '*' '/bin/bash /opt/scripts/scp.sh &gt; /dev/null 2&gt;&amp;1'# 如果 '/bin/bash /opt/scripts/scp.sh &gt; /dev/null 2&gt;&amp;1'# 这一部分存在了，那么这一步操作就是 update，也就是更新前面执行 crontab 的时间，如果不存在，这就相当于一条添加定时任务的操作返回内容为 new cron.rm_job 用法 删除指定用户指定的的定时任务 12# 注意格式是用户 后面跟要删除的任务，不要加前面的时间，成功会返回 removed，如果没有这条记录会返回 absentsalt '*' cron.rm_job root '/bin/bash /opt/scripts/scp.sh &gt; /dev/null 2&gt;&amp;1' network 模块常用方法1234567891011121314151617181920212223242526272829# 返回minion的主机名salt '*' network.get_hostname# 返回指定网络接口的mac地址salt '*' network.hw_addr eth0# 查看主机在某个子网内就返回True，如果不在的话就返回False，多子网用空格隔开salt '*' network.in_subnet 192.168.1.0/24# 查看 minion 端绑定的 IP 地址，多 IP 也会显示出来，127.0.0.1除外salt '*' network.ip_addrs# 会显示所有接口的详细信息，但是别名的网卡类似于 eth0:1 这种不会显示salt '*' network.interfaces# 显示指定网卡接口上面的 IP，只会显示 IP 不会显示其他内容# network.interface 会连网关子网掩码也显示salt '*' network.interface_ip eth0# 修改某一个minion的主机名，显然这一步操作只适合在初始化的时候而且不适合执行所有主机salt 'agent1.salt' network.mod_hostname test1.saltsalt '*' network.ping www.baidu.com return_boolean=True timeout=3# 如果不加 return_boolean=True 显示的是 ping 的结果信息，加了就是如果 ping 通了就返回True，ping 不通就返回 False# timeout=3 就是 ping 的时间，3秒超时这样能快速返回结果# 这个其实挺好用的，比如我们可以测试哪些主机的 DNS 设置有问题不能正常解析啊，或是我们内网 DNS 指向了一个非公网的域名解析，可以通过这个看哪些主机设置了内网 DNS 而哪些没设置内网 DNS# 返回主机所属的子网salt '*' network.subnets sys模块常用方法sys.argspec 用法 返回 Salt 执行模块中函数的参数说明。对于我们后期写 .sls文件 很有帮助 12345# 查看 pkg.install 函数的参数说明salt '*' sys.argspec pkg.install# 查看sys模块里面所有函数的规则说明，或者#salt '*' sys.argspec 'sys.*'salt '*' sys.argspec sys sys.doc 用法 显示模块下函数的使用文档信息类似于man帮助，前面已介绍过，多模块或者多函数之间用空格隔开 sys.list_functions 和 sys.list_modules 用法 前者就是列出所有模块下面的函数，多模块也是用空格隔开。后者是将所有模块列出来 12345678# 可以用这种方法将所有 sys.list 开头的函数列出来salt '*' sys.list_functions 'sys.list_*'# 列出所有的模块salt '*' sys.list_modules# 列出所有以 s 开头的模块salt '*' sys.list_modules 's*' service 模块常用方法1234567891011121314151617181920212223242526272829303132333435# 查看某个命令的服务是否可用，这里是查看sshd服务是否可用，可用返回True，不可用返回Falsesalt '*' service.available sshd# 禁止某个服务开机启动，这里是禁止 postfix 服务开机启动salt '*' service.disable postfix# 查看某个服务是否已经开机不启动，这里是以postfix服务为例，是返回True，否则返回Falsesalt '*' service.disabled postfix# 设置某个服务开机启动，这里以 postfix 为例salt '*' service.enable postfix# 查看某个服务是否开机启动，这里以 postfix 服务为例salt '*' service.enabled postfix# 查看所有的服务项salt '*' service.get_all# 查看所有开机启动的服务salt '*' service.get_enabled# 重新加载指定名称的服务salt '*' service.reload &lt;service name&gt;# 重新启动指定名称的服务salt '*' service.restart &lt;service name&gt;# 启动指定名称的服务salt '*' service.start &lt;service name&gt;# 查看指定服务的状态，启动状态是True，关闭状态是Falsesalt '*' service.status &lt;service name&gt;# 关闭指定名称的服务salt '*' service.stop &lt;service name&gt; pkg 模块常用方法pkg.install 用法 安装传递的包，在安装包之前，添加 refresh=True 来清理 yum 数据库 1234567891011121314151617181920# 参数介绍name # 要安装的软件包的名称。如果传递了 "pkgs" 或 "sources" 此参数则会被忽略# 如这就相当于在 minion 端执行 yum -y install httpd 操作salt '*' pkg.install httpd# 如果是第一个 yum 的话，还是可以 refresh 参数，相当于 yum clean all 操作salt '*' pkg.install httpd refresh=Trueskip_verify # 跳过 GPG 验证检查version # 安装包的特定版本fromrepo # 指定从哪个 repo 库来安装软件pkgs # 指定多个软件包，一定是要以列表传递salt '*' pkg.install pkgs='["foo", "bar"]'salt '*' pkg.install pkgs='["foo", &#123;"bar": "1.2.3-4.el5"&#125;]'sources # 要安装的RPM软件包列表，其中的键是包名称，值作为包的源URI或本地路径salt '*' pkg.install sources='[&#123;"foo": "salt://foo.rpm"&#125;, &#123;"bar": "salt://bar.rpm"&#125;]' pkg.latest_version 用法 更新软件包至最新版本 12345678# 更新指定的软件包salt '*' pkg.latest_version &lt;package name&gt;# 指定 repo 源来更新软件包salt '*' pkg.latest_version &lt;package name&gt; fromrepo=epel-testing# 多个要更新的软件之间用空格隔开salt '*' pkg.latest_version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ... pkg.remove 用法 删除软件的操作 12345678# 卸载指定的软件salt '*' pkg.remove &lt;package name&gt;# 多软件可以用空格隔开salt '*' pkg.remove &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt;# 也可以用 pkgs 使用 python 列表的形式salt '*' pkg.remove pkgs='["foo", "bar"]' salt ‘*’ pkg.version 用法 查看软件的版本 12345# 查看指定软件的版本号salt '*' pkg.version &lt;package name&gt;# 查看多软件版本号salt '*' pkg.version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ... 参考文档http://blog.51niux.com/?id=116]]></content>
      <categories>
        <category>SaltStack笔记</category>
      </categories>
      <tags>
        <tag>SaltStack常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成CI持续交付CD]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98CD%2F</url>
    <content type="text"><![CDATA[持续集成CI/持续交付CD CI 很容易理解，就是持续集成。但是 CD 既可以指代码持续交付，也可理解为代码持续部署。CI 和 CD 之间有很多相似的部分，但是也有很大的区别。 持续集成 (Continuous Integration)在持续集成环境中，开发人员将会频繁的提交代码到主干。这些新提交在最终合并到主线之前，都需要通过编译和自动化测试流进行验证。这样做是基于之前持续集成过程中很重视自动化测试验证结果，以保障所有的提交在合并主线之后的质量问题，对可能出现的一些问题进行预警。 持续交付 (Continuous Delivery)持续交付就是讲我们的应用发布出去的过程。这个过程可以确保我们尽可能快的实现交付。这就意味着除了自动化测试，我们还需要有自动化的发布流，以及通过一个按键就可以随时随地实现应用的部署上线。通过持续交付，可以决定每天，每周，每两周发布一次，这完全可以根据自己的业务进行设置。但是，如果您真的希望体验持续交付的优势，就需要先进行小批量发布，尽快部署到生产线，以便在出现问题时方便进行故障排除。 持续部署 (Continuous Deployment)如果我们想更加深入一步的话，就是持续部署了。通过这个方式，任何修改通过了所有已有的工作流就会直接和客户见面。没有人为干预（没有一键部署按钮），只有当一个修改在工作流中构建失败才能阻止它部署到产品线。持续部署是一个很优秀的方式，可以加速与客户的反馈循环，但是会给团队带来压力，因为不再有“发布日”了。开发人员可以专注于构建软件，他们看到他们的修改在他们完成工作后几分钟就上线了。基本上，当开发人员在主分支中合并一个提交时，这个分支将被构建、测试，如果一切顺利，则部署到生产环境中。 合并 CI CD and CD？当然，正如我所说，他们每部分都更加接近生产环境。你可以构建自己的持续集成环境，然后，一旦团队适应，你可以添加持续交付流，最后，可以添加持续部署流到整个工作流中。 举例 CI，CD 和 CD 流水线 到底值不值这样做？ 持续集成 需要具备哪些条件？ 你的团队需要为每个新功能，代码改进，或者问题修复创建自动化测试用例。你需要一个持续集成服务器，它可以监控代码提交情况，对每个新的提交进行自动化测试。研发团队需要尽可能快的提交代码，至少每天一次提交。 可以获得什么？ 通过自动化测试可以提早拿到回归测试的结果，避免将一些问题提交到交付生产中发布编译将会更加容易，因为合并之初已经将所有问题都规避了减少工作问题切换，研发可以很快获得构建失败的消息，在开始下一个任务之前就可以很快解决。测试成本大幅降低-你的 CI 服务器可以在几秒钟之内运行上百条测试。你的 QA 团队花费在测试上面的时间会大幅缩短，将会更加侧重于质量文化的提升上面。 持续交付 需要具备的条件 你需要有强大的持续集成组件和足够多的测试项可以满足你代码的需求部署需要自动化。触发是手动的，但是部署一旦开始，就不能人为干预。你的团队可能需要接受特性开关，没有完成的功能模块不会影响到线上产品。 可以获得什么？ 繁琐的部署工作没有了。你的团队不在需要花费几天的时间去准备一个发布。你可以更快的进行交付，这样就加快了与客户之间的反馈环。轻松应对小变更，加速迭代 持续部署 需要具备的条件 研发团队测试理念比较完善。测试单元的健壮性直接决定你的交付质量。你的文档和部署频率要保持一致。特征标志成为发布重大变化过程的固有部分，以确保您可以与其他部门（支持，市场营销，公关…）协调。 可以获得什么？ 发布频率更快，因为你不需要停下来等待发布。每一处提交都会自动触发发布流。在小批量发布的时候，风险降低了，发现问题也可以很轻松的修复。客户每天都可以看到我们的持续改进和提升，而不是每个月或者每季度，或者每年。如前所述，您可以采用持续集成，持续交付和持续部署。你怎么做取决于你的需求和你的业务情况。如果你刚刚开始一个项目，并且还没有客户，那么你就可以去创建这些工作流，最好是将这三个方面都实现，并且在你的项目迭代和需求增长中同时迭代它们。如果您已经有一个生产项目，那么您可以一步一步地分阶段去实现他们。 参考文档https://www.sohu.com/a/204652724_640923]]></content>
      <categories>
        <category>CI/CD笔记</category>
      </categories>
      <tags>
        <tag>持续集成CI持续交付CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数基础]]></title>
    <url>%2F2018%2F08%2F03%2FPython%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Python函数基础 什么是函数？ 函数就是具备某一功能的工具 函数的使用必须遵循先定义，后调用的原则 实现准备工具的过程即函数的定义 拿来就用即函数的调用 函数氛围两大类 内置函数 自定义函数 为什么要用函数？ 不用函数的问题 代码的组织结构不清晰，可读性差 遇到重复的功能只能重复编写实现代码，代码冗余过多 程序的扩展性差，功能需要扩展时，需要找出所有实现该功能的地方修改之，无法统一管理且维护难度极大 怎么用函数？ 定义函数语法12345678910def 函数名(参数1,参数2,参数3,...): """ 文档注释 """ 函数体 code1 code2 code3 ...... return 返回值 自定义函数的三种形式无参函数1234567891011def func1(): print('hello1') print('hello2') print('hello3')func1()# 输出结果hello1hello2hello3 有参函数1234567891011121314def func2(x, y): if x &gt; y: print(x) else: print(y)func2(1, 3)func2(2, 3)func2(2, 4)# 输出结果334 空函数 用于预设程序的框架 12345678910def get(): # 下载功能 passdef put(): # 上传功能 passdef auth(): # 认证功能 passdef ls(): # 浏览功能 passdef cd(): # 切换目录的功能 pass 定义函数阶段 相当于定义了一个名字，名字指向了一个值，值是内存地址，该地址包含了函数体代码定义函数阶段，只检测语法，不执行函数体代码 123456789101112131415def foo(): # foo = 函数的内存地址 print('first') print('second') print('third')print(foo) # 打印输出函数值内存地址# 输出结果&lt;function for at 0x000001E71A588950&gt;foo() # 函数调用阶段# 输出结果firstsecondthird 测试一123456789101112def bar(): print('from bar')def foo(): print('from foo') bar()foo()# 输出结果from foofrom bar 测试二123456789101112def foo(): print('from foo') bar()def bar(): print('from bar')foo() # 调用阶段# 输出结果from foofrom bar 调用函数语法1函数名() 调用函数过程 根据函数名找到函数的内存地址函数的内存地址加括号可以触发函数体代码的运行 调用函数的三种形式无参函数1234567def f1(): print('from f1')f1()# 输出结果from f1 有参函数1234567891011def max(x, y): if x &gt; y: return x else: return yres = max(1, 2)print(res)# 输出结果2 1234567891011def max(x, y): if x &gt; y: return x else: return yres = max(1, 2)*10print(res)# 输出结果20 当作参数传给其他函数 1234567891011def max(x, y): if x &gt; y: return x else: return yres = max(max(1, 2), 3)print(res)# 输出结果3 函数的返回值什么是返回值？函数的返回值是函数体代码运行的一个结果 什么时候使用返回值？如何使用？ return 返回值： 返回值没有类型限制 返回值没有个数限制逗号分隔多个值，返回一个元组一个值，返回值本身没有return，默认返回None 12345678def f1(): return [1, 2,]res = f1()print(res)# 输出结果[1, 2] 逗号分隔多个值，返回一个元组12345678def f1(): return 1, 2, [1, 2, 3]res = f1()print(res)# 输出结果(1, 2, [1, 2, 3]) 没有return，默认返回None12345678def f1(): passres = f1()print(res)# 输出结果None return 是函数结束的标志函数内可以有多个return，但只要执行一次，整个函数就立即结束，并且将return后的值当作本次调用的结果返回123456789101112def f1(): print(1) return 'first' print(2) return 'second' print(3) return 'third'f1()# 输出结果1 总结 函数使用的原则：先定义，再调用 函数名即“变量名”，“变量名”必须先定义后引用。未定义而直接引用函数，就相当于在引用一个不存在的变量名 我们在使用函数时，一定要明确地区分定义阶段和调用阶段 函数在定义阶段都做了哪些事？ 只检测语法，不执行代码 也就说，语法错误在函数定义阶段就会检测出来，而代码的逻辑错误只有在执行时才会知道 函数名：是用来访问到函数的内存地址，拿到函数的内存地址加括号就可以触发函数体代码函数参数：是外部调用者为函数体传值的媒介函数体代码：是函数功能的具体实现 return 函数返回值：函数的返回值是函数体执行的成果 返回值没有类型限制 返回值没有个数限制 没有return，默认返回None return 值1：返回值1 return 值1, 值2, 值3：返回(值1, 值2, 值3) return 注意点： return 是函数结束运行的标志，函数体内可以都有多个 return 但是只有执行一次，整个函数就终止运行]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python函数基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python修改文件内容]]></title>
    <url>%2F2018%2F08%2F01%2FPython%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Python修改文件内容 想要修改文件中的内容，没有办法直接实现。硬盘上的数据都是一圈一圈写的，没有修改一说，都是新数据覆盖老数据 12vim db.txt你好哈哈哈 预期 在 你好 后面插入 上上上 1234567with open('db.txt' mode='r+t', encoding='utf-8') as f: f.seek(6, 0) # 移动了6个bytes f.write('上上上')# 执行结果cat db.txt你好上上上 使用 seek() 文件指针偏移 会覆盖其他内容，不好掌控 方法一 先将文件内容全部读入内存 在内存中修改完毕 将修改的结果覆盖写回硬盘中 12vim db.txtHello World! 优点：在修改期间硬盘上同一时刻只有一份数据缺点：占用内存过高 1234567891011with open('db.txt', mode='rt', encoding='utf-8') as f: data = f.read() new_data = data.replace('World', 'Python') print(new_data)with open('db.txt', mode='wt', encoding='utf-8') as f: f.write(new_data)# 执行结果cat db.txtHello Python! 方法二（推荐使用） 一行一行的读，一行一行的改 以读的模式打开源文件，以写的模式打开一个临时文件（解决占用内存的问题） 然后用 for 循环读取原文件一行行内容，每读一行则修改一行，将修改的内容写入临时文件，直到把源文件都遍历完， 删除原文件，将临时文件重命名为原文件名 1234567891011import oswith open('db.txt', mode='rt', encoding='utf-8') as src_f, \ open('.db.txt.swap', mode='wt', encoding='utf-8') as temp_f: for line in src_f: if 'World' in line: line = line.replace('World', 'Python') temp_f.write(line)os.remove('db.txt')os.rename('.db.txt.swap', 'db.txt') 优点：同一时刻在内存中只存在文件的一行内容缺点：在修改期间，硬盘上同一份数据会保存两份]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python修改文件内容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典操作]]></title>
    <url>%2F2018%2F07%2F30%2FPython%E5%AD%97%E5%85%B8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Python字典操作字典（dict），是一系列放在 {} 的键值对（key-value）。可以使用键来访问对应的值，与键对应的值可以是 数字、字符串、列表、字典字典具有极快的查找速度。 下边是一个与手机信息相关的 dict1&#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125; 使用 dict()方法 创建字典1d = dict(os= 'Android', soc='Qualcomm', screen='Samsung') 使用可迭代对象（列表、元组等）也可以创建字典123456&gt;&gt;&gt; d = dict((['x', 1], ['y', 2], ['z', 3]))&gt;&gt;&gt; d&#123;'x': 1, 'y': 2, 'z': 3&#125;&gt;&gt;&gt; d = dict(zip(('x', 'y', 'z'), (1, 2, 3)))&gt;&gt;&gt; d&#123;'x': 1, 'y': 2, 'z': 3&#125; 使用 fromkeys()内建方法 创建默认字典12&gt;&gt;&gt; &#123;&#125;.fromkeys(('x', 'y', 'z'), -1)&#123;'x': -1, 'y': -1, 'z': -1&#125; 访问字典中的值123456789101112131415&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;# 通过 key 访问 value，如果 key 不存在则报错&gt;&gt;&gt; m['os']'Android'# 为了避免 key 不存在报错问题，可以使用 get 方法，如果 key 不存在则返回 None，或指定返回值&gt;&gt;&gt; m.get('soc')'Qualcomm'# key 不存在时，指定返回值&gt;&gt;&gt; m.get('xxx'，-1)-1# 除了 get 方法外，还可以先通过 in 判断 key 是否存在&gt;&gt;&gt;'xxx' in mFalse&gt;&gt;&gt;'os' in m True 添加 key-value 为字典增加一项 1234&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; m['camera'] = 'Sony'&gt;&gt;&gt; m&#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung', 'camera': 'Sony'&#125; 删除 key-value123456789101112&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; del m['os']&gt;&gt;&gt; m&#123;'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; m.pop('soc')'Qualcomm'&gt;&gt;&gt; m&#123;'screen': 'Samsung'&#125;# 删除所有键值对&gt;&gt;&gt; m.clear()&gt;&gt;&gt; m&#123;&#125; 修改字典中的值1234&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; m['screen'] = 'BOE'&gt;&gt;&gt; m&#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'BOE'&#125; 字典的长度（键值对数量）123&gt;&gt;&gt; d = &#123;'x': 1, 'y': 2, 'z': 3&#125;&gt;&gt;&gt; len(d)3 update() 字典合并 将一个字典的内容添加到另一个字典12345&gt;&gt;&gt; d = &#123;'x': 1, 'y': 2, 'z': 3&#125;&gt;&gt;&gt; d1 = &#123;'m': 4, 'n': 5&#125;&gt;&gt;&gt; d.update(d1)&gt;&gt;&gt; d&#123;'x': 1, 'y': 2, 'z': 3, 'm': 4, 'n': 5&#125; 遍历字典遍历字典的键 key12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for key in d.keys():··· print(key)1list111tuple 遍历字典的值value12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for value in d.values():··· print (value)[1, 2, 3]123python3(4, 5, 6) 遍历获取 key 和 value1234567&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;&gt;&gt;&gt; for key in m:··· print(key + ' -&gt; ' + m[key])os -&gt; Androidsoc -&gt; Qualcommscreen -&gt; Samsung 12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1:123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for key in d:··· print(str(key) + ':' + str(d[key]))list:[1, 2, 3]1:123111:python3tuple:(4, 5, 6) 遍历字典的项 items，获取 key 和 value items() 返回一个列表，列表的每一个元素是一个包含 key、value 的 tuple 12345678&gt;&gt;&gt; m = &#123;'os': 'Android', 'soc': 'Qualcomm', 'screen': 'Samsung'&#125;# m.items() 返回一个列表，列表的每一个元素是一个包含 key、value 的 tuple&gt;&gt;&gt; for key, value in m.items():··· print(key + ' -&gt; ' + value)os -&gt; Androidsoc -&gt; Qualcommscreen -&gt; Samsung 12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for item in d.items():··· print(item)('list', [1, 2, 3])(1, 123)('111', 'python3')('tuple', (4, 5, 6)) 12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for key, value in d.items():··· print(key, value)list [1, 2, 3]1 123111 python3tuple (4, 5, 6) 12345678&gt;&gt;&gt; d = &#123;'list': [1, 2, 3], 1: 123, '111': 'python3', 'tuple': (4, 5, 6)&#125;&gt;&gt;&gt; for (key, value) in d.items():··· print(key, value)list [1, 2, 3]1 123111 python3tuple (4, 5, 6)]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python字典操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件内指针移动]]></title>
    <url>%2F2018%2F07%2F28%2FPython%E6%96%87%E4%BB%B6%E5%86%85%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Python文件内指针移动 read(3) 文件打开方式为文本模式时，代表读取 3 个字符 文件打开方式为 b模式 时，代表读取 3 个字节 其余的文件内光标移动都是以字节为单位如 seek，tell，truncate seek() 文件内光标操作 seek 有三种移动方式 0，1，2其中 1 和 2 必须在 b模式 下进行，但无论哪种模式，都是以 bytes 为单位移动的 单位统一为字节第一个参数：控制移动的字节数第二个参数：控制移动的参照物，值可以为：0、1、20：参照文件开头，默认为01：参照当前位置2：参照文件末尾 0：参照文件开头（在 b 和 t 模式下都能使用） 默认为 0强调：除了 0 模式以外的模式都只能在 b 模式下使用1 和 2 只能用在 b 模式下 12cat e.txt你好hello 123456with open('e.txt', mode='rt', encoding='utf-8') as f: f.seek(3) print(f.read())# 输出结果好hello 如果一个 字节 没有读完，会报以下错误 1234567with open('e.txt', mode='rt', encoding='utf-8') as f: f.seek(2) print(f.read())# 输出结果(result, consumed) = self._buffer_decode(data, self.errors, final)UnicodeDecodeError: 'utf-8' codec can't decode byte 0xa0 in position 0: invalid start byte 123456with open('e.txt', mode='rt', encoding='utf-8') as f: f.seek(6, 0) print(f.read())# 输出结果hello 1234567with open('e.txt', mode='rt', encoding='utf-8') as f: f.read() f.seek(0, 0) print('第二次', f.read())# 输出结果第二次 你好hello 1：参照当前位置（只能在 b模式下使用） 储备：read(n)read 的 n 在 t模式下 读的是字符个数123456with open('e.txt', mode='rt', encoding='utf-8') as f: data = f.read(2) print(data)# 输出结果你好 read 的 n 在 b模式下 读的是字节个数123456with open('e.txt', mode='rb') as f: data = f.read(3) print(data)# 输出结果b'\xe4\xbd\xa0' 123456with open('e.txt', mode='rb') as f: data = f.read(3) print(data.decode('utf-8'))# 输出结果你 其余所有文件内指针的移动都是以字节为单位 123456with open('e.txt', mode='rt', encoding='utf-8') as f: s = f.read(1) print(s)# 输出结果你 12345678with open('e.txt', mode='rt', encoding='utf-8') as f: s = f.read(1) print(s) print(f.tell()) # 查看当前指针位置# 输出结果你3 # 表示当前指针在第 3 个字节 1234567with open('e.txt', mode='rt', encoding='utf-8') as f: s = f.read(1) # 读取一个字符 f.seek(6, 0) # 0 将指针放到文件开头，移动到第 6 个字节位 print(f.read()) # 打印输出# 输出结果hello 12345678with open('e.txt', mode='rb') as f: s = f.read(3) # f.seek(6, 0) f.seek(3, 1) print(f.read())# 输出结果b'hello' 12345678with open('e.txt', mode='rb') as f: s = f.read(3) # f.seek(6, 0) f.seek(3, 1) print(f.read().decode('utf-8'))# 输出结果hello 2：参照文件末尾（只能在 b模式下使用）1234cat e.txt你好hello1你好hello2你好hello3 123456with open('e.txt', mode='rb') as f: f.seek(-6,2) # 读取 'hello3' print(f.read())# 输出结果b'hello3' truncate 截断文件 文件的打开方式必须可写，但是不能用 w 或 w+ 等方式打开，因为那样直接清空文件了所以 truncate 要在 r+ 或 a 或 a+ 等模式下测试效果a：追加写r+：可读可写 1234cat e.txt你aaa好hello1你好hello2你好hello3 123456with open('e.txt', mode='at', encoding='utf-8') as f: f.truncate(9) # 从文件开头截取到 3个bytes 的位置，其余的删除# 执行结果cat e.txt你aaa好 123456with open('e.txt', mode='r+t', encoding='utf-8') as f: f.truncate(9) # 从文件开头截取到 3个bytes 的位置，其余的删除# 执行结果cat e.txt你aaa好 练习：基于 seek 实现 tail -f 功能12345678910import timewith open('test.txt', 'rb') as f: f.seek(0,2) while True: line = f.readline() if line: print(line.decode('utf-8')) else: time.sleep(0.2)]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python文件内指针移动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ集群配置]]></title>
    <url>%2F2018%2F07%2F25%2FRabbitMQ%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[RabbitMQ 集群配置这里展示的是多机集群的部署，如果机器受限，可以选择单机集群部署 RabbitMQ 可以通过三种方法来部署分布式集群系统分别是：cluster，federation，shovel cluster 不支持跨网段，用于同一个网段内的局域网 可以随意的动态增加或者减少 节点之间需要运行相同版本的 RabbitMQ 和 Erlang federation 应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器上交换机或队列的消息，可以是单独机器或集群。federation 队列类似于单向点对点连接，消息会在联盟队列之间转发任意次，直到被消费者接受。通常使用 federation 来连接 internet 上的中间服务器，用作订阅分发消息或工作队列。 shovel 连接方式与 federation 的连接方式类似，但它工作在更低层次。可以应用于广域网。 节点类型 Ram node：内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速。 Disk node：将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启 RabbitMQ 的时候，丢失系统的配置信息。 选用三台主机，主机名分别是 pro-rabbitmq01pro-rabbitmq02pro-rabbitmq03 集群配置RabbitMQ 是用 Erlang 开发的，集群非常方便，因为 Erlang 天生就是一门分布式语言，但其本身并不支持负载均衡。RabbitMQ 利用 Erlang 的分布式特性组建集群，erlang 集群通过 magic cookie 实现，此 cookie 保存在 $HOME/.erlang.cookierpm安装即 /var/lib/rabbitmq/.erlang.cookie二进制安装在 /data/erlang/.erlang.cookie需要保证集群各节点的此 cookie 一致，可以选取一个节点的 cookie，用 rsync，scp 同步到其余节点。 同步 Cookie读取其中一个节点的 cookie，并复制到其他节点节点之间通过 cookie 确定相互是否可通信。cookie 存放在 /var/lib/rabbitmq/.erlang.cookie或$HOME/.erlang.cookie 中 设置 Erlang CookieRabbitMQ 的集群是依赖于 Erlang 的集群来工作的，所以必须先构建起 Erlang 的集群环境。Erlang 的集群中各节点是通过一个 magic cookie 来实现的，这个 Cookie 存放在 /data/erlang/.erlang.cookie 中，文件是 400 的权限。所以必须保证各节点 Cookie 保持一致，否则节点之间就无法通信。我们是删除其中两台的 /data/erlang/.erlang.cookie，然后将另一台的 /data/erlang/.erlang.cookie 拷贝到这两台上。文件权限是 400 注意：.erlang.cookie 文件的权限，RabbitMQ账号，权限 400 或 600 即可，为组或 other 账号赋权会报错 123rsync -avzP /data/erlang/.erlang.cookie root@10.21.20.94:/data/erlang/# scp /var/lib/rabbitmq/.erlang.cookie root@1.1.1.2:/var/lib/rabbitmq/# scp /var/lib/rabbitmq/.erlang.cookie root@1.1.1.3:/var/lib/rabbitmq/ 逐个启动节点1rabbitmq-server -detached 查看各节点的状态12rabbitmqctl statusrabbitmqctl cluster_status 配置各节点的 hosts 文件1234vim /etc/hostsx.x.x.x pro-rabbitmq01x.x.x.x pro-rabbitmq02x.x.x.x pro-rabbitmq03 组建集群pro-rabbitmq02 和 pro-rabbitmq03以 pro-rabbitmq01 为主节点在 pro-rabbitmq02 上 rabbitmqctl join_cluster rabbit@pro-rabbitmq01 中的 rabbit@pro-rabbitmq01，rabbit 代表集群名pro-rabbitmq01 代表集群节点节点名同 hostname，hostname 与 /etc/hosts 中设置必须保持一致pro-rabbitmq02 与 pro-rabbitmq03 均连接到 pro-rabbitmq01，它们之间也会自动建立连接。如果需要使用内存节点，增加一个 --ram 的参数即可如：rabbitmqctl join_cluster --ram rabbit@pro-rabbitmq01rabbitmqctl join_cluster rabbit@pro-rabbitmq01 --ram一个集群中至少需要一个 disk 节点默认是磁盘节点，如果是内存节点的话，需要加 --ram 参数 1234[root@pro-rabbitmq02 ~]# rabbitmqctl stop_app[root@pro-rabbitmq02 ~]# rabbitmqctl reset[root@pro-rabbitmq02 ~]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01[root@pro-rabbitmq02 ~]# rabbitmqctl start_app pro-rabbitmq03 上的操作与 pro-rabbitmq02 的相同 1234[root@pro-rabbitmq03 ~]# rabbitmqctl stop_app[root@pro-rabbitmq03 ~]# rabbitmqctl reset[root@pro-rabbitmq03 ~]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01[root@pro-rabbitmq03 ~]# rabbitmqctl start_app 12345678910111213141516171819202122232425262728[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl stop_appStopping rabbit application on node rabbit@pro-rabbitmq02 ...[root@pro-rabbitmq02 rabbitmq]# netstat -ntlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:4369 0.0.0.0:* LISTEN 2556/epmd tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 2717/sshd tcp 0 0 0.0.0.0:25672 0.0.0.0:* LISTEN 2467/beam.smp tcp6 0 0 :::4369 :::* LISTEN 2556/epmd [root@pro-rabbitmq02 rabbitmq]# rabbitmqctl resetResetting node rabbit@pro-rabbitmq02 ...[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl join_cluster rabbit@pro-rabbitmq01Clustering node rabbit@pro-rabbitmq02 with rabbit@pro-rabbitmq01[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl start_appStarting node rabbit@pro-rabbitmq02 ... completed with 0 plugins.[root@pro-rabbitmq02 rabbitmq]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq02 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq01',[]&#125;,&#123;'rabbit@pro-rabbitmq02',[]&#125;]&#125;] 修改集群类型 修改 disk 节点到 内存 节点 1234567891011121314[root@pro-rabbitmq02 ~]# rabbitmqctl change_cluster_node_type ramTurning rabbit@pro-rabbitmq02 into a ram node[root@pro-rabbitmq02 ~]# rabbitmqctl start_appStarting node rabbit@pro-rabbitmq02 ... completed with 3 plugins.[root@pro-rabbitmq02 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq02 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01']&#125;,&#123;ram,['rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq01','rabbit@pro-rabbitmq02']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq01',[]&#125;,&#123;'rabbit@pro-rabbitmq02',[]&#125;]&#125;] 1234567891011121314[root@pro-rabbitmq03 rabbitmq]# rabbitmqctl cluster_statusCluster status of node rabbit@pro-rabbitmq03 ...[&#123;nodes,[&#123;disc,['rabbit@pro-rabbitmq01']&#125;, &#123;ram,['rabbit@pro-rabbitmq03','rabbit@pro-rabbitmq02']&#125;]&#125;, &#123;running_nodes,['rabbit@pro-rabbitmq02','rabbit@pro-rabbitmq01', 'rabbit@pro-rabbitmq03']&#125;, &#123;cluster_name,&lt;&lt;"rabbit@pro-rabbitmq01"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;'rabbit@pro-rabbitmq02',[]&#125;, &#123;'rabbit@pro-rabbitmq01',[]&#125;, &#123;'rabbit@pro-rabbitmq03',[]&#125;]&#125;]# 可以看到三个节点都加入了集群中，两个 ram 节点、一个 disc 节点。# 其中三个节点都在运行中，以及集群名称显示。 默认是磁盘节点，如果是内存节点的话，需要加 --ram 参数RabbitMQ 集群节点有 disc 和 ram 两种类型，一个集群中至少要有一个 disc 类型的节点，不指定默认加入为 disc 12# 将集群类型修改成 disk 节点rabbitmqctl change_cluster_node_type disc]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ集群配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础学习]]></title>
    <url>%2F2018%2F07%2F25%2FHTML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[HTML基础学习Web运行本质 对于所有的 Web 应用，本质上其实就是一个 socket 服务端，用户的浏览器其实就是一个 socket 客户端 12345678910111213141516171819import socketdef handle_request(client): buf = client.recv(1024) client.send(bytes("HTTP/1.1 200 OK\r\n\r\n", encoding='utf-8')) client.send(bytes("Hello, World", encoding='utf-8')) def main(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.bind(('localhost', 8000)) sock.listen(5) while True: connection, address = sock.accept() handle_request(connection) connection.close()if __name__ == '__main__': main() HTML 相关概念html是什么 超文本标记语言（Hypertext Markup Language，HTML）通过标记符号来标记要显示的网页中的内容。 其实就是一套规则，浏览器认识的规则。 浏览器按顺序渲染网页文件，然后根据标记符解释和显示内容。 对于不同的浏览器，对同一标签可能会有不完全相同的解释（兼容性）。 w3c（了解） w3c是什么？ 万维网联盟（World Wide Web Consortium，简称W3C）创建于1994年，是Web技术领域具权威和影响力的国际标准化组织 w3c的主要工作？ W3C主要工作，是制作Web规范。到目前为止，W3C已发布了200多项影响深远的Web技术标准。比如：XHTML、HTML5、XML、CSS、DOM、XSTL等 HTML 文件结构以及标签格式html 的文件格式12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 文件体 &lt;/body&gt;&lt;/html&gt; 上述代码说明 &lt;html&gt;&lt;/html&gt;是文档的开始标记和结束标记。此元素告诉浏览器其自身是一个 HTML 文档，在它们之间是文档的头部和主体 &lt;head&gt;&lt;/head&gt;元素出现在文档的开头部分。&lt;head&gt;与&lt;/head&gt;之间的内容不会在浏览器的文档窗口显示，但是其中的元素有特殊重要的意义 &lt;title&gt;&lt;/title&gt;定义网页标题，在浏览器标题栏显示 &lt;body&gt;&lt;/body&gt;之间的文本是可见的网页主体内容 html 标签格式 HTML标签是由尖括号包围的关键词，比如 &lt;html&gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 HTML标签通常是成对出现的（双边标记），比如 &lt;div&gt; 和 &lt;/div&gt; 但也有单独呈现的标签（单边标记），如：&lt;br /&gt;、&lt;hr /&gt;和&lt;img src=“images/1.jpg” /&gt;等 标签可以有若干个属性，也可以不带属性。如&lt;head&gt;元素就不带任何属性 123标答的语法：&lt;标签名 属性1=“属性值1” 属性2=“属性值2”...&gt;内容部分&lt;/标签名&gt;&lt;标签名 属性1=“属性值1” 属性2=“属性值2”.../&gt; HTML 常用标签之MetaMeta介绍 &lt;meta&gt;元素可提供有关页面的元信息（meta-information），针对搜索引擎和更新频度的描述和关键词 &lt;meta&gt;标签位于文档的头部，不包含任何内容 &lt;meta&gt;提供的信息是用户不可见的 关于meta常见的用法 author（作者） 说明：标注网页的作者用法：&lt;meta name=&quot;author&quot; content=&quot;张三&quot;&gt; Copyright(版权信息) 功能：说明网站版权信息用法：&lt;meta name=&quot;copyright&quot; content=&quot;信息参数&quot;&gt; 简单示例 HTML 常用标签之字体以及排版标签排版元素（常用） 标签 作用 &lt;p&gt;&lt;/p&gt; 用来创建一个段落，该元素自动在其前后创建一些空白 &lt;br/&gt; 换行 &lt;hr/&gt; 华丽的分割线 &lt;h1&gt;&lt;/h1&gt;...&lt;h6&gt;&lt;/h6&gt; 6种标题效果标签。分别为h1~h6。&lt;h1&gt;字体最大，&lt;h6&gt;字体最小 marquee标签（跑马灯的实现）HTML常用标签之列表无序列表1234&lt;ul&gt; &lt;li&gt;内容&lt;/li&gt; &lt;li&gt;内容&lt;/li&gt;&lt;/ul&gt; 常用属性解释 type属性：disc（实心圆点）（默认）、circle（空心圆圈）、square（实心方块） 有序列表1234&lt;ol&gt; &lt;li&gt;内容&lt;/li&gt; &lt;li&gt;内容&lt;/li&gt;&lt;/ol&gt; 常用属性解释 属性：type编号类型，默认为整数。可选（1、A、a、Ⅰ、i）属性：start起始编号，默认为1，即由最小编号开始 HTML常用标签之a标签语法 &lt;a 属性=&quot;属性值&quot;&gt;标签内容&lt;/a&gt; 常见的属性 href – 指定目标网页的地址，该地址可以有如下类型： 链接远程目标：通过URL地址链接到远程目标。 链接本地页面：可以通过相对路径或者绝对路径链接本地页面。 相对路径：指相对于当前页面位置的路径./：表示当前页面所在的目录../：表示当前页面所在的上一级目录 绝对路径：绝对路径指当前站点中确切的路径，一般以”/”开始 例如：&lt;a href=&quot;/admin/index.py&quot;&gt;后台首页&lt;/a&gt; target _blank 表示在 新窗口 中打开目标网页_self 表示在 当前窗口 中打开目标网页 常见例子 链接到远程地址 12&lt;a href="http://www.sina.com.cn"&gt;新浪网&lt;/a&gt;&lt;a href="http://www.qq.com"&gt;腾讯网&lt;/a&gt; 链接到本地文件 12相对路径：&lt;a href="include/login.html"&gt;登录页面&lt;/a&gt;绝对路径：&lt;a href="/html/123.html"&gt;国内新闻&lt;/a&gt; 链接到邮箱 1&lt;a href="mailto:976296751@qq.com"&gt;给我发邮件&lt;/a&gt; 下载文件 12&lt;a href="/download/winRAR.rar"&gt;下载WinRAR&lt;/a&gt;&lt;a href="download/office2007.rar"&gt;下载office2007&lt;/a&gt; HTML常用标签之div和span元素块级元素 &lt;div&gt;&lt;/div&gt;&lt;div&gt;只是一个块级元素，并无实际的意义. 主要通过CSS为其赋予不同的表现 行内元素 &lt;span&gt;&lt;/span&gt;&lt;span&gt;内联行(行内元素),并无实际的意义. 主要通过CSS为其赋予不同的表现 块级元素与行内元素的区别 所谓块元素，是以另起一行开始渲染的元素，行内元素则不需另起一行如果单独在网页中插入这两个元素，不会对页面产生任何的影响这两个元素是专门为定义CSS样式而生的 HTML常用标签之img标签常见的用法1&lt;img src="URL" alt="图片说明"/&gt; 常见的属性用法说明 属性 值 含义 src 图像URL 规定图像的URL alt 字符串 规定图像的替代文本 width px / % 规定图像的宽 height px / % 规定图像的高 border px 图像的边框粗细 HTML常用标签之table标签html表格的基本结构12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容&lt;/td&gt; &lt;td&gt;内容&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 解释说明 &lt;table&gt;&lt;/table&gt;表示的表格的开始和结束 &lt;tr&gt;&lt;/tr&gt;表示的是表格的一行 &lt;td&gt;&lt;/td&gt;表示的是一个单元数据格 &lt;th&gt;&lt;/th&gt;表示表格标题单元格，且加粗居中显示 table的常用属性 属性 值 含义 width px或% 表格的宽度 height px或% 表格的高度 border px 表格的边框的粗细 align Left/center/right 元素的对齐方式 简单的案例实现 HTML常用标签之form表单元素标签FORM表单的基本概念 基本概念 HTML表单是HTML元素中较为复杂的部分，表单往往和脚本、动态页面、数据处理等功能相结合，因此它是制作动态网站很重要的内容。表单一般用来收集用户的输入信息 表单的工作原理 访问者在浏览有表单的网页时，可填写必需的信息，然后按某个按钮提交这些信息通过Internet传送到服务器上服务器上专门的程序对这些数据进行处理，如果有错误会返回错误信息，并要求纠正错误 12345678910111213141516import tornado.ioloopimport tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write("Hello, world") def post(self): self.write('this is a test') application = tornado.web.Application([ (r"/index", MainHandler),]) if __name__ == "__main__": application.listen(8888) tornado.ioloop.IOLoop.instance().start() 表单的常见结构 123456&lt;form id="form1" method="post" action=""&gt; 账号：&lt;input type="text" name="account" /&gt;&lt;br /&gt; 密码：&lt;input type="password" name="password" /&gt;&lt;br /&gt; &lt;input type="submit" name="submit" value="提交" /&gt; &lt;input type="reset" name="reset" value="重置" /&gt;&lt;/form&gt; 表单标记属性 属性 值 含义 action url 指定一个表单处理目标URL，表单数据将被提交到该URL地址的处理程序。如果该属性值为空，则提交到文档自身。该属性值可以为绝对地址、相对地址、文档片段，甚至是脚本代码 method get或post 将表单数据提交到http服务器的方法，可能值有两个：get和post enctype application/x-www-form-urlencoded 指定表单数据的编码类型，此属性只有在method属性设置为post时才有效。默认值为application/x-www-form-urlencoded对所有字符进行编码。如果表单包含用于文件上传的控件（input type=“file”），那么这个属性值必须设为multipart/form-data ，不对字符进行编码。 补充：Get和Post提交的区别 Get方式提交 如果为get，那么所提交的数据集将被作为一个由表单的所有名/值对组成的查询字符串（query string）添加到表单处理器的URL（action属性）的末尾比如：http://www.oldboyedu.com/index.py?variable1=content1&amp;variable1=content2这种方法提交的信息在长度上有一定限制，而且不安全，适合简单的数据查询 Post方式提交 如果为post，那么数据集将直接发给表单处理程序，而不是以可见的URL查询字符串的形式。post方法可以提交更长的数据，并且相对安全一些，传送的数据类型更多一些（不限于ASCII字符），因而适用于数据更复杂的表单 常见的 INPUT 标签 type属性值 空间名称 对应代码 text 单行文本输入框 &lt;input type=&quot;text&quot;/&gt; password 密码输入框 &lt;input type=&quot;password&quot;/&gt; checkbox 复选框 &lt;input type=&quot;checkbox&quot; checked=&#39;checked&#39;/&gt; radio 单选框 &lt;input type=&quot;radio&quot;/&gt; submit 提交按钮 &lt;input type=&quot;submit&quot; value=&#39;提交&#39;/&gt; reset 重置按钮 &lt;input type=&quot;reset&quot; value=&#39;重置&#39;/&gt; button 普通按钮 &lt;input type=&quot;button&quot; value=“普通按钮”/&gt; hidden 隐藏按钮 &lt;input type=&quot;hidden&quot; value=“隐藏按钮”/&gt; file 文本选择框 &lt;input type=&quot;file&quot;/&gt; 需要注意的问题 上传文件控件 当一个中有“上传文件域”，必须指定MIME类型 enctype=”multipart/form-data”&gt;，否则无法上传文件上传文件域，只在 method=”post” 下才有效 隐藏控件 &lt;input type=&quot;hidden&quot; name=&quot;nid&quot; value=&quot;234&quot; /&gt;隐藏字段对于用户是不可见的隐藏字段通常会存储一个默认值一般用在，修改某条数据时，用来记录数据的id号 普通按钮 &lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;普通按钮&quot; /&gt;定义可点击的按钮，但没有任何行为，一般配合JS使用 各种按钮显示效果 SELECT下拉列表常见的基本结构 123456789&lt;form id="form1" name="form1" method="post" action=""&gt; &lt;select name="city" id="city"&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海" selected="selected"&gt;上海&lt;/option&gt; &lt;option value="南京"&gt;南京&lt;/option&gt; &lt;option value="杭州"&gt;杭州&lt;/option&gt; &lt;option value="深圳"&gt;深圳&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 属性说明 multiple：布尔属性，设置后允许多选，否则只能选择一个disabled：禁用该下拉列表selected：首次显示时,为选中状态value：定义发往服务器的选项值 TEXTAREA多行文本框12345&lt;form id="form1" name="form1" method="post" action=""&gt; &lt;textarea cols="宽度" rows="高度" name="名称"&gt; 默认内容 &lt;/textarea&gt;&lt;/form&gt; 属性说明 属性 属性值 说明 name name 控件名称 rows number 设置多行文本框的显示行数（高度） cols number 设置多行文本框的显示列数（宽度） disabled disabled 布尔属性，设置当前文本框为禁用状态 LABEL表单修饰1234&lt;form id="form1" name="form1" method="post" action=""&gt; &lt;label for="username"&gt;用户名&lt;/label&gt; &lt;input type="text" name="username" id="username" /&gt;&lt;/form&gt; 说明 label 元素不会向用户呈现任何特殊效果&lt;label&gt; 标签的 for 属性应当与相关元素的 id 属性相同结合CSS可以控制表单文本或控件对齐，美化表单 案例 参考文档http://www.shangzekai.xyz/2017/05/07/html基础目录/]]></content>
      <categories>
        <category>HTML笔记</category>
      </categories>
      <tags>
        <tag>HTML基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ常用命令]]></title>
    <url>%2F2018%2F07%2F24%2FRabbitMQ%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[RabbitMQ常用命令 服务启动关闭12345# 启动rabbitmq-server -detached # 关闭rabbitmqctl stop 集群配置相关命令12345678910111213rabbitmqctl stop_app rabbitmqctl reset # 在当前集群中加入某节点rabbitmqctl join_cluster &#123;rabbit_node_name&#125;# 某些低版本可以采用 rabbitmqctl cluster &#123;rabbit_node_name&#125;rabbitmqctl start_app # 集群状态rabbitmqctl cluster_status# 将某节点剔除出当前集群rabbitmqctl forget_cluster_node &#123;rabbit_node_name&#125; 插件管理123456789101112# 开启某个插件rabbitmq-plugins enable &#123;插件名&#125;# 关闭某个插件rabbitmq-plugins disable &#123;插件名&#125;# 有关插件名可以在 rabbitmq 的安装目录下的 plugins 目录中查看$RABBITMQ_HOME/plugins# 举例rabbitmq-plugins enable rabbitmq_management rabbitmq-plugins list 用户管理1234567891011121314151617# 添加用户rabbitmqctl add_user &#123;username&#125; &#123;password&#125;# 删除用户rabbitmqctl delete_user &#123;username&#125;# 修改密码rabbitmqctl change_password &#123;username&#125; &#123;newpassword&#125;# 设置用户角色rabbitmqctl set_user_tags &#123;username&#125; &#123;tag&#125;tag 可以为 administrator, monitoring, management# 举例rabbitmqctl add_user root rootrabbitmqctl set_user_tags root administratorrabbitmqctl list_users 权限管理123456789101112131415161718# 权限设置rabbitmqctl set_permissions [-p vhostpath] &#123;user&#125; &#123;conf&#125; &#123;write&#125; &#123;read&#125;conf # 一个正则表达式match哪些配置资源能够被该用户访问write # 一个正则表达式match哪些配置资源能够被该用户读read # 一个正则表达式match哪些配置资源能够被该用户访问# 查看（指定vhost）所有用户的权限信息rabbitmqctl list_permissions [-p vhostPath]# 查看指定用户的权限信息rabbitmqctl list_user_permissions &#123;username&#125;# 清除用户的权限信息rabbitmqctl clear_permissions [-p vhostPath] &#123;username&#125;# 举例rabbitmqctl set_permissions -p / root "." "." ".*" 获取服务器状态信息1234567891011121314151617181920212223242526272829303132333435# 服务器状态rabbitmqctl status# 队列信息rabbitmqctl list_queues -p vhostpath# queueinfoitem可以为name, durable, auto_delete, arguments, messages_ready, messages_unacknowled, messages, consumers, memory.# Exchange信息rabbitmqctl list_exchanges -p vhostpath# exchangeinfoitem有name, type, durable, auto_delete, internal, arguments.# Binding信息rabbitmqctl list_bindings -p vhostpath# bindinginfoitem有source_name, source_kind, destination_name, destination_kind, routing_key, arguments.等# connection信息rabbitmqctl list_connections [connectioninfoitem ...]# connectioninfoitem有recv_oct，recv_cnt，send_oct，send_cnt，send_pend 等。# channel信息rabbitmqctl list_channels [channelinfoitem ...]# channelinfoitem有consumer_count，messages_unacknowledged，messages_uncommitted，acks_uncommitted，messages_unconfirmed，prefetch_count，client_flow_blocked# 举例rabbitmqctl list_queues name messages_ready pid slave_pids 更改节点类型12345rabbitmqctl stop_apprabbitmqctl change_cluster_node_type disc或rabbitmqctl change_cluster_node_type ramrabbitmqctl start_app vhost管理12345# 添加vhostrabbitmqctl add vhost &#123;name&#125;# 删除vhostrabbitmqctl delete vhost &#123;name&#125; 镜像队列的设置12345678910111213141516镜像队列的配置通过添加 policy 完成，policy 添加的命令为rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority] -p Vhost: # 可选参数，针对指定 vhost 下的 queue 进行设置Name: # policy 的名称Pattern: # queue 的匹配模式（正则表达式）Definition: # 镜像定义，包括三个部分 ha-mode，ha-params，ha-sync-mode ha-mode: # 指明镜像队列的模式，有效值为 all/exactly/nodes all # 表示在集群所有的节点上进行镜像 exactly # 表示在指定个数的节点上进行镜像，节点的个数由 ha-params 指定 nodes # 表示在指定的节点上进行镜像，节点名称通过 ha-params 指定 ha-params: # ha-mode模式需要用到的参数 ha-sync-mode: # 镜像队列中消息的同步方式，有效值为 automatic，manually # 有效值为 automatic（自动同步），manually（手动同步），默认是 manually # 请注意一定要记得设置为 automatic（自动同步），否则消息在镜像队列中是不会自动同步的（即普通集群模式），只能通过命令手动去同步Priority: # 可选参数，policy 的优先级 示例1234567# 对队列名称以 hello 开头的所有队列进行镜像，并在集群的两个节点上完成镜像# policy 的设置命令为rabbitmqctl set_policy hello-ha "^hello" '&#123;"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"&#125;'# 对队列名称以 “queue_” 开头的所有队列进行镜像，并在集群的两个节点上完成进行# policy 的设置命令为rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue "^queue_" '&#123;"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"&#125;' policy 相关解释12345Name： # policy 策略的唯一名称Pattern： # 用于匹配 exchange 和 queue 等名称的正则表达式Apply to： # 指定将此 policy 应用到哪些项上（例如：exchange，queue等）Priority： # 可选参数，policy 的优先级，exchange 和 queue 名称可以匹配到多个 policy，优先级则定义了 policy 被执行的顺序Definition：# 参数定义 消息的同步 将新节点加入已存在的镜像队列是，默认情况下 ha-sync-mode=manual，镜像队列中的消息不会主动同步到新节点，除非显式调用同步命令。当调用同步命令后，队列开始阻塞，无法对其进行操作，直到同步完毕。当 ha-sync-mode=automatic 时，新加入节点时会默认同步已知的镜像队列。由于同步过程的限制，所以不建议在生产的 active 队列（有生产消费消息）中操作。 12345678910# 可以使用下面的命令来查看那些 slaves 已经完成同步rabbitmqctl list_queues name slave_pids synchronised_slave_pids# 可以通过手动的方式同步一个 queuerabbitmqctl sync_queue name# 同样也可以取消某个 queue 的同步功能rabbitmqctl cancel_sync_queue name# 当然这些都可以通过 management 插件来设置 参考文档https://blog.csdn.net/u013256816/article/details/53524814]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ用户管理]]></title>
    <url>%2F2018%2F07%2F24%2FRabbitMQ%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 用户管理 创建用户 在 RabbitMQ 中，用户是访问控制（Access Control）的基本单元，且单个用户可以跨越多个vhost 进行授权。针对一至多个 vhost，用户可以被赋予不同级别的访问权限，并使用标准的用户名和密码来认证用户。创建用户的命令为：rabbitmqctl add_user {username} {password}。其中username 表示要创建的用户名称。password 表示创建用户登录的密码。具体创建一个用户名为 root、密码为 root123 的用户 12[root@node1 ~]# rabbitmqctl add_user root root@123Creating user "root" 修改密码可以通过rabbitmqctl change_password {username} {newpassword}命令来更改指定用户的密码其中username 表示要变更密码的用户名称newpassword 表示要变更的新的密码 举例：将 root用户的密码变更为 root32112[root@node1 ~]# rabbitmqctl change_password root root@321Changing password for user "root" 清除密码同样可以清除密码，这样用户就不能使用密码登录了对于的操作命令为：rabbitmqctl clear_password {username}其中username 表示要清楚密码的用户名称 验证用户使用rabbitmqctl authenticate_user {username} {password}可以通过密码来验证用户其中username 表示需要被验证的用户名称password 表示密码 下面示例中分别采用 root321 和 root322 来验证 root 用户1234567[root@node1 ~]# rabbitmqctl authenticate_user root root@321Authenticating user "root"Success[root@node1 ~]# rabbitmqctl authenticate_user root root@322Authenticating user "root"Error: failed to authenticate user "root" 删除用户删除用户的命令是rabbitmqctl delete_user {username}其中username 表示要删除的用户名称 删除用户 root 的示例如下12[root@node1 ~]# rabbitmqctl delete_user rootDeleting user "root" 查询用户列表rabbitmqctl list_users 命令可以用来罗列当前的所有用户每个结果行都包含用户名称，其后紧跟用户的角色（tags） 示例代码如下：1234[root@node1 ~]# rabbitmqctl list_usersListing usersguest [administrator]root [] 用户的角色分为 5 种类型none：无任何角色。新创建的用户的角色默认为 none。management：可以访问 Web 管理页面。policymaker：包含 management 的所有权限，并且可以管理策略（policy）和参数（parameter）。monitoring：包含 management 的所有权限，并且可以看到所有连接（connections）、信道（channels）以及节点相关的信息。administartor：包含 monitoring 的所有权限，并且可以管理用户、虚拟主机、权限、策略、参数等等。administator 代表了最高的权限。 设置用户角色用户的角色可以通过rabbitmqctl set_user_tags {username} {tag...}命令设置。其中username 参数表示需要设置角色的用户名称。tag 参数用于设置 0 个、1 个 或者 多 个的角色，设置之后任何之前现有的身份都会被删除。 使用示例如下：12345678910111213141516171819202122[root@node1 ~]# rabbitmqctl set_user_tags root monitoringSetting tags for user "root" to [monitoring][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [monitoring][root@node1 ~]# rabbitmqctl set_user_tags root policymaker -q[root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [policymaker][root@node1 ~]# rabbitmqctl set_user_tags rootSetting tags for user "root" to [][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [][root@node1 ~]# rabbitmqctl set_user_tags root policymaker,managementSetting tags for user "root" to ['policymaker,management'][root@node1 ~]# rabbitmqctl list_users -qguest [administrator]root [policymaker,management] 参考文档https://blog.csdn.net/u013256816/article/details/78181306]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ用户管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ集群管理]]></title>
    <url>%2F2018%2F07%2F24%2FRabbitMQ%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 集群管理 rabbitmqctl join_cluster {cluster_node} [–ram] 将节点加入指定集群中。在这个命令执行前需要停止 RabbitMQ 应用并重置节点。 rabbitmqctl cluster_status 显示集群的状态 rabbitmqctl change_cluster_node_type {disc|ram} 修改集群节点的类型。在这个命令执行前需要停止 RabbitMQ 应用 rabbitmqctl forget_cluster_node [–offline] 将节点从集群中删除，允许离线执行 rabbitmqctl update_cluster_nodes {clusternode} 在集群中的节点应用启动前咨询 clusternode 节点的最新信息，并更新相应的集群信息。这个和 join_cluster 不同，它不加入集群。考虑这样一种情况，节点A 和 节点B 都在集群中，当节点A离线了，节点C 又和 节点B 组成了一个集群，然后 节点B 又离开了集群，当 A 醒来的时候，它会尝试联系 节点B，但是这样会失败，因为节点B已经不在集群中了。rabbitmqctl update_cluster_nodes -n A C 可以解决这种场景。 示例如下：12345678910111213141516171819202122232425262728293031323334353637383940# 假设已有 node1 和 node2 组成的集群# 1. 初始状态[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;]# 2. 关闭 node1 节点的应用[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1# 3. 之后将 node3 加入到集群中（rabbitmqctl join_cluster rabbit@node2）# 4. 再将 node2 节点的应用关闭# 5. 最后启动 node1 节点的应用，此时会报错[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1BOOT FAILED===========Timeout contacting cluster nodes: [rabbit@node2].....(省略)# 6. 如果在启动 node1 节点的应用之前咨询 node3 并更新相关集群信息则可以解决这个问题[root@node1 ~]# rabbitmqctl update_cluster_nodes rabbit@node3Updating cluster nodes for rabbit@node1 from rabbit@node3[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1# 7. 最终集群状态[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node3]&#125;]&#125;, &#123;running_nodes,[rabbit@node3,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node3,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;] rabbitmqctl force_boot确保节点可以启动，即使它不是最后一个关闭的节点。通常情况下，当关闭整个 RabbitMQ 集群时，重启的第一个节点应该是最后关闭的节点，因为它可以看到其它节点所看不到的事情。但是有时会有一些异常情况出现，比如整个集群都掉电而所有节点都认为它不是最后一个关闭的。在这种情况下，可以调用 rabbitmqctl force_boot 命令，这就告诉节点可以无条件的启动节点。在此节点关闭后，集群的任何变化，它都会丢失。如果最后一个关闭的节点永久丢失了，那么你需要优先使用 rabbitmqctl forget_cluster_node –offline 命令，因为它可以确保镜像队列的正常运转。 示例如下：123[root@node2 ~]# rabbitmqctl force_bootForcing boot for Mnesia dir /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit@node2[root@node2 ~]# rabbitmq-server –detached rabbitmqctl sync_queue [-p vhost] {queue} 指示未同步队列 queue 的 slave 镜像可以同步 master 镜像行的内容。同步期间此队列会被阻塞（所有此队列的生产消费者都会被阻塞），直到同步完成。此条命令执行成功的前提是队列queue 配置了镜像。注意，未同步队列中的消息被耗尽后，最终也会变成同步，此命令主要用于未耗尽的队列。 示例如下：12[root@node1 ~]# rabbitmqctl sync_queue queueSynchronising queue 'queue' in vhost '/' rabbitmqctl cancel_sync_queue [-p vhost] {queue} 取消队列 queue 同步镜像的操作。 示例如下：12[root@node1 ~]# rabbitmqctl cancel_sync_queue queueStopping synchronising queue 'queue' in vhost '/' rabbitmqctl set_cluster_name {name} 设置集群名称。集群名称在客户端连接时会通报给客户端。Federation 和 Shovel 插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。 示例如下：12345678910111213141516[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"rabbit@node1"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;][root@node1 ~]# rabbitmqctl set_cluster_name cluster_hiddenSetting cluster name to cluster_hidden[root@node1 ~]# rabbitmqctl cluster_statusCluster status of node rabbit@node1[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;, &#123;running_nodes,[rabbit@node2,rabbit@node1]&#125;, &#123;cluster_name,&lt;&lt;"cluster_hidden"&gt;&gt;&#125;, &#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;,&#123;rabbit@node1,[]&#125;]&#125;] 参考文档https://blog.csdn.net/u013256816/article/details/78348761]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ集群管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ应用管理]]></title>
    <url>%2F2018%2F07%2F24%2FRabbitMQ%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[RabbitMQ 应用管理本文主要阐述应用与集群相关的一些操作管理命令，包括关闭、重置、开启服务，还有建立集群的一些信息。 rabbitmqctl stop [pid_file] 用于停止运行 RabbitMQ 的 Erlang 虚拟机和 RabbitMQ 服务应用。如果指定了 pid_file，还需要等待指定进程的结束。其中 pid_file 是通过调用 rabbitmq-server 启动 RabbitMQ 服务时创建的，默认情况下存放于 Mnesia 目录中，可以通过 RABBITMQ_PID_FILE 这个环境变量来改变存放路径。注意，如果是 rabbitmq-server –detach 启动的 RabbitMQ 服务则不会生成 pid_file 这个文件。 示例如下：123456[root@node1 ~]# rabbitmqctl stop/data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidStopping and halting node rabbit@node1[root@node1 ~]# rabbitmqctl stopStopping and halting node rabbit@node1 rabbitmqctl shutdown 用于停止运行 RabbitMQ 的 Erlang 虚拟机 和 RabbitMQ 服务应用。执行这个命令会阻塞直到 Erlang 虚拟机进程的退出。如果 RabbitMQ 没有成功关闭，则会返回一个非零值。这个命令和 rabbitmqctl stop 的不同的是，它不需要指定 pid_file 而可以阻塞等待指定进程的关闭。 示例如下：1234[root@node1 ~]# rabbitmqctl shutdownShutting down RabbitMQ node rabbit@node1 running at PID 1706Waiting for PID 1706 to terminateRabbitMQ node rabbit@node1 running at PID 1706 successfully shut down rabbitmqctl stop_app 停止 RabbitMQ 服务应用，但是 Erlang 虚拟机还是处于运行状态。此命令优先执行其他管理操作（这些管理操作需要先停止 RabbitMQ 应用），比如 rabbitmqctl reset。 示例如下：12[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1 rabbitmqctl start_app 启动 RabbitMQ 应用。此命令典型的用途是在执行了其他管理操作之后，重新启动之前停止的 RabbitMQ 应用，譬如rabbitmqctl reset。 示例如下：12[root@node1 ~]# rabbitmqctl start_appStarting node rabbit@node1 rabbitmqctl wait [pid_file] 等待 RabbitMQ 应用的启动。它会等到 pid_file 的创建，然后等待 pid_file 中的所代表的进程启动。当指定的进程没有启动 RabbitMQ 应用而关闭时将会返回失败。 示例如下：12345678[root@node1 ~]# rabbitmqctl wait /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidWaiting for rabbit@node1pid is 3468[root@node1 ~]# rabbitmqctl wait /data/app/rabbitmq/var/lib/rabbitmq/mnesia/rabbit\@node1.pidWaiting for rabbit@node1pid is 3468Error: process_not_running rabbitmqctl reset 将 RabbitMQ 节点重置还原到最初状态，包括从原所在的集群中删除此节点，从管理数据库中删除所有的配置数据，如已配置的用户、vhost等，以及删除所有的持久化消息。执行 rabbitmqctl reset 命令前必须停止 RabbitMQ 应用（比如先执行 rabbitmqctl stop_app）。 示例如下：12345[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1[root@node1 ~]# rabbitmqctl resetResetting node rabbit@node1 rabbitmqctl force_reset 强制将 RabbitMQ 节点重置还原到最初状态。不同于 rabbitmqctl reset，rabbitmqctl force_reset 命令不论当前管理数据库的状态和集群配置是什么，会无条件地重置节点。它只能在数据库或集群配置已损坏的情况下才可使用。与 rabbitmqctl reset 命令一下，执行 rabbitmqctl force_reset 命令前必须先停止RabbitMQ 应用。 示例如下：12345[root@node1 ~]# rabbitmqctl stop_appStopping rabbit application on node rabbit@node1[root@node1 ~]# rabbitmqctl force_resetForcefully resetting node rabbit@node1 rabbitmqctl rotate_logs {suffix} 指示 RabbitMQ 节点轮换日志文件。RabbitMQ 节点会将原来的日志文件中的内容追加到 “原始名称+后缀”的日志文件中，然后再将新的日志内容记录到新创建的日志中（与原日志文件同名）。当目标文件不存在时，将会重新创建。如果不指定 suffix，那么则日志文件只是重新打开而不会进行轮换。 示例如下所示原日志文件为 `rabbit@node1.log和rabbit@node1-sasl.log，轮换日志之后，原日志文件中的内容就被追加到rabbit@node1.log.1和rabbit@node1-sasl.log.1日志中，之后重新建立rabbit@node1.log和rabbit@node1-sasl.log` 文件用来接收新的日志。1234567891011121314[root@node1 rabbitmq]# pwd/data/app/rabbitmq/var/log/rabbitmq[root@node1 rabbitmq]# ll-rw-r--r-- 1 root root 1024127 Aug 18 11:56 rabbit@node1.log-rw-r--r-- 1 root root 720553 Aug 17 19:16 rabbit@node1-sasl.log[root@node1 rabbitmq]# rabbitmqctl rotate_logs .1Rotating logs to files with suffix ".1"[root@node1 rabbitmq]# ll-rw-r--r-- 1 root root 0 Aug 18 12:05 rabbit@node1.log-rw-r--r-- 1 root root 1024202 Aug 18 12:05 rabbit@node1.log.1-rw-r--r-- 1 root root 0 Aug 18 12:05 rabbit@node1-sasl.log-rw-r--r-- 1 root root 720553 Aug 18 12:05 rabbit@node1-sasl.log.1 rabbitmqctl hipe_compile {directory} 将部分 RabbitMQ 代码用 HiPE（HiPE是指High Performance Erlang ，是Erlang版的JIT）编译，并且将编译后的 .beam 文件（beam 文件是 Erlang 编译器生成的文件格式，可以直接加载到 Erlang 虚拟机中运行的文件格式）保存到指定的文件目录中。如果这个目录不存在则会自行创建。如果这个目录中原本有任何 .beam 文件，则会在执行编译前被删除。如果要使用预编译的这些文件，需要设置 RABBITMQ_SERVER_CODE_PATH 这个环境变量来指定hipe_compile 调用的路径。 示例如下：123456789101112131415161718192021222324[root@node1 rabbitmq]# rabbitmqctl hipe_compile /data/app/rabbitmq/tmp/rabbit-hipe/ebinHiPE compiling: |---------------------------------------------------------| |#########################################################|Compiled 57 modules in 55s[root@node1 rabbitmq]# ls /opt/rabbitmq/tmp/rabbit-hipe/ebinarray.beam proplists.beam rabbit_misc.beamcredit_flow.beam qlc.beam rabbit_msg_file.beamdelegate.beam queue.beam rabbit_msg_store.beamdict.beam rabbit_amqqueue.beam rabbit_msg_store_ets_index.beamfile_handle_cache.beam rabbit_amqqueue_process.beam rabbit_net.beamgb_sets.beam rabbit_basic.beam rabbit_queue_index.beamgb_trees.beam rabbit_binary_generator.beam rabbit_reader.beamgen.beam rabbit_binary_parser.beam rabbit_router.beamgen_fsm.beam rabbit_channel.beam rabbit_trace.beamgen_server2.beam rabbit_command_assembler.beam rabbit_variable_queue.beamlists.beam rabbit_event.beam rabbit_writer.beamlqueue.beam rabbit_exchange.beam rpc.beammnesia.beam rabbit_exchange_decorator.beam sets.beammnesia_lib.beam rabbit_exchange_type_direct.beam sofs.beammnesia_tm.beam rabbit_exchange_type_fanout.beam ssl.beamorddict.beam rabbit_exchange_type_topic.beam ssl_connection.beamordsets.beam rabbit_framing_amqp_0_9_1.beam ssl_record.beampmon.beam rabbit_guid.beam tls_connection.beampriority_queue.beam rabbit_limiter.beam tls_record.beam 参考文档https://blog.csdn.net/u013256816/article/details/78221439]]></content>
      <categories>
        <category>RabbitMQ笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ应用管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx修改隐藏版本号]]></title>
    <url>%2F2018%2F07%2F17%2FNginx%E4%BF%AE%E6%94%B9%E9%9A%90%E8%97%8F%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Nginx修改隐藏版本号Nginx 配置文件 配置文件里增加 server_tokens off;server_tokens 作用域是 http server location 语句块server_tokens 默认值是 on，表示显示版本信息，设置 server_tokens 值是 off，就可以在所有地方隐藏 nginx 的版本信息 隐藏 Nginx 版本号 在 /data/app/nginx/conf/nginx.conf 里 123456vim /data/app/nginx/conf/nginx.confhost &#123;...省略... server_tokens off;...省略...&#125; 这样修改之后能隐藏掉 nginx 的版本号，但是还是可以显示 Web 软件为 nginx 修改 Nginx 源码版本信息1curl -I "http://127.0.0.1 | grep Server" Nginx 编译前修改版本及版本号1234567891011121314151617181920212223cd /data/tools/cd nginx-1.15.1/vim ./src/core/nginx.h... 省略 ...#define nginx_version 1008001#define NGINX_VERSION "" # 修改想要显示的版本#define NGINX_VER "FastDFS" NGINX_VERSION # 将 nginx 修改成想要显示的软件名称... 省略 ...#define NGINX_VAR "FastDFS" # 将 nginx 修改成想要显示的软件名称(Evan Web Server)#define NGX_OLDPID_EXT ".oldbin"vim ./src/http/ngx_http_header_filter_module.c// static u_char ngx_http_server_string[] = "Server: nginx" CRLF;static u_char ngx_http_server_string[] = "Server: FastDFS" CRLF; # 将 nginx 修改为想要的版本static u_char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;static u_char ngx_http_server_build_string[] = "Server: " NGINX_VER_BUILD CRLF;vim ./src/http/ngx_http_special_response.cstatic u_char ngx_http_error_tail[] =// "&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;" CRLF"&lt;hr&gt;&lt;center&gt;FastDFS&lt;/center&gt;" CRLF # 将 nginx 修改为想要的版本信息"&lt;/body&gt;" CRLF"&lt;/html&gt;" CRLF 修改 fastcgi123456789101112cd /data/tools/nginx-1.15.1/vim ./conf/fastcgi_params找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;修改为fastcgi_param SERVER_SOFTWARE FastDFS/$nginx_version;vim ./conf/fastcgi.conf找到fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;修改为fastcgi_param SERVER_SOFTWARE FastDFS/$nginx_version; 修改探针中显示的 Web 服务软件信息，在编译前，fastcgi 编译后修改都可以 注意： 当添加 server_tokens off; 参数的时候，调用的是 src/http/ngx_http_header_filter_module.c 里的值不添加的时候，显示版本号调用的是 src/core/nginx.h 里的值所以我们修改的时候需要两个地方都修改。]]></content>
      <categories>
        <category>Nginx笔记</category>
      </categories>
      <tags>
        <tag>Nginx修改隐藏版本号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件处理]]></title>
    <url>%2F2018%2F07%2F11%2FPython%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件处理 应用程序中需要经常将内存的数据永久保存下来，而应用程序又无法直接操作硬件只能通过操作系统提供的虚拟单位去间接地操作硬盘 打开文件 open(&#39;文件的路径&#39;, mode=&#39;打开文件的模式&#39;, encoding=&#39;操作文件的字符编码&#39;)r 表示 原始字符串，不转义任何特殊字符 向操作系统发送打开文件的请求 向操作系统发送打开文件的请求 1open(r'/tmp/a.txt') open 有返回值12345f = open(r'/tmp/a.txt', mode='r')print(f)# 输出结果&lt;_io.TextIOWrapper name='/tmp/a.txt' mode='r' encoding='UTF-8'&gt; f =&gt; 应用程序中的一个值 =&gt; 操作系统打开的文件 a.txt =&gt; 硬盘中的一块空间 读/写123456789101112# 应用程序向操作系统发送请求，打开文件f.read() # 把文件内容全都读到内存里去f = open(r'a.txt', mode='r')data = f.read()print(data)# 输出结果UnicodeDecodeError: 'gbk' codec can't decode byte 0x8a in position 8: illegal multibyte sequenc# 注意 不同 操作系统平台 字符编码问题# Windows gbk# Linux utf-8 12345678f = open(r'a.txt', mode='r', encoding='utf-8') # 指定打开文件的字符编码为 utf-8data = f.read() # 在读取的时候就会以 utf-8 的编码读取print(data)# 输出结果你好啊aaawoca 嘞 关闭文件，释放资源1234567f.close() # 回收操作系统的资源，操作系统会定期回收资源print(f) # f 的资源会自动被 Python 回收掉f.read()# 输出结果ValueError: I/O operation on closed file.# del f # 手动回收 f 资源，不要在 f.close() 之前用这个 总结 文件处理的步骤 打开文件 读/写文件 关闭文件 打开多个文件12f1 = open(r'a1.txt', mode='r')f2 = open(r'a2.txt', mode='r') 操作系统资源 =&gt; 文件描述符应用程序资源 with 上下文管理 帮你打开文件先将操作系统把文件打开然后把打开结果赋值给 f（占用两个资源）123with open(r'a.txt', mode='r', encoding='utf-8') as f: print('==&gt;') # 运行 with 的子代码块 print(f.read()) # 在这里基于 with 打开的文件，做读写操作 with 会帮我们自动 close with 打开多个文件12345with open(r'a.txt', mode='r', encoding='utf-8') as f1,\ open(r'b.txt', mode='r', encoding='utf-8') as f2: print('==&gt;') print(f1.read()) print(f2.read()) 文件的打开模式三种纯净模式 r 只读模式（默认模式，文件必须存在，不存在则抛出异常）w 只写模式（不可读，不存在则创建；存在则清空内容）a 只追加写模式（不可读，不存在则创建；存在则追加内容） 控制操作文件内容的模式两种模式 不能单独使用，必须与 r，w，a 连用t（默认）：text文本模式，该模式操作文件内容的单位都是字符串，该模式只适用于文本文件注意： 该模式下必须指定 encoding=&quot;字符编码&quot;b：bytes 二进制模式，该模式下操作文件的内容单位都是bytes，该模式适用于所有类型文件 r 模式，只读模式 默认单位：t，可以不指定默认文件的打开模式是 rt 模式文件必须存在，不存在则报错文件存在则打开文件，并且将文件指针跳到文件的开头 read() 方法 读取所有内容，光标移动到文件末尾把文件内容一次性全都读出，读成 str字符串 数据类型 123456with open('a.txt', mode='rt', encoding='utf-8') as f: data = f.read() print(type(data))# 输出结果&lt;class 'str'&gt; 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: data = f.read() print(data)# 输出结果你好啊aaawoca 了 1234567891011with open('a.txt', mode='rt', encoding='utf-8') as f: data1 = f.read() print('第一次', data1) data2 = f.read() print('第二次', data2)# 输出结果第一次 你好啊aaawoca 了第二次 readable() 判断文件是否可读12345with open('a.txt', mode='rt', encoding='utf-8') as f: print(f.readable())# 输出结果True writable() 判断文件是否可写 r 读模式，不能写，只能读 12345678910with open('a.txt', mode='rt', encoding='utf-8') as f: print(f.writable())# 输出结果Falsewith open('a.txt', mode='rt', encoding='utf-8') as f: f.write('hello')# 输出结果io.UnsupportedOperation: not writable 1234f.closed # 文件是否关闭f.encoding # 如果文件打开模式为b，则没有该属性f.flush() # 立刻将文件内容从内存刷到硬盘f.name readline() 方法 一次读一行读取一行内容，光标移动到第二行首部 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: line = f.readline() print(line, end='') # end='' 取消 print() 自带的换行 print('====&gt;')# 输出结果你好啊====&gt; 1234567891011with open('a.txt', mode='rt', encoding='utf-8') as f: line1 = f.readline() print(line1, end='') # end='' 取消 print() 自带的换行 print('====&gt;') line2 = f.readline() print(line2, end='')# 输出结果你好啊====&gt;aaa readlines() 方法 读取每一行内容，存放于列表中把文件内容一次性全都读出，读成 list列表 数据类型，和 read() 类似 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: l = f.readlines() print(type(l)) print(l)# 输出结果&lt;class 'list'&gt;['你好啊\n', 'aaa\n', 'woca 了'] w 模式，只写模式 只写模式文件存在，会将文件内容情空，并且将文件指针跳到文件的开头文件不存在，则创建一个空文件，并且将文件指针跳到文件的开头 12with open('b.txt', mode='wt', encoding='utf-8') as f: pass 1234567891011with open('b.txt', mode='wt', encoding='utf-8') as f: print(f.readable()) print(f.writable())# 输出结果FalseTruewith open('a.txt', mode='wt', encoding='utf-8') as f: f.readline()# 输出结果io.UnsupportedOperation: not readable write() 方法 针对文本模式的写，需要自己写换行符 12f.write('1111\n2222\n')f.write('1111\n2222\n'.encode('utf-8')) 12345with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊')# 打开文件 b.txt你好啊 123456with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊') f.write('我的天')# 打开文件 b.txt你好啊我的天 1234567with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('你好啊\n') f.write('我的天')# 打开文件 b.txt你好啊我的天 注意：如果每次都是重新打开文件，那么文件内容总会清空，指针永远跳到开头如果在打开文件不关闭的情况下，连续的写入，本次写入会基于上一次指针所在的位置往后继续写 writelines() 方法 文件模式12f.writelines(['333\n','444\n'])f.writelines([bytes('333\n', encoding='utf-8'), '444\n'.encode('utf-8')]) 1234567891011121314151617with open('b.txt', mode='wt', encoding='utf-8') as f: l = ['1111\n', '2222\n', '3333\n'] f.writelines(l)# 打开文件 b.txt111122223333# 相当于with open('b.txt', mode='wt', encoding='utf-8') as f: l = ['1111\n', '2222\n', '3333\n'] for line in l: f.write(line)# 打开文件 b.txt111122223333 1234567with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('1111\n\2222\n3333\n')# 打开文件 b.txt111122223333 换行符 \n Unix/Linux平台\r 老 Mac OS\n 新 Mac OS X\r\n Windows平台 查看换行符12345with open('b.txt', mode='rb') as f: print(f.read())# 输出结果b'1111\r\n2222\r\n3333\r\n' 12345678with open('a.txt', mode='rt', encoding='utf-8') as f: l = f.readlines() print(l) print(type(l))# 输出结果['1111\n', '2222\n', '3333']&lt;class 'list'&gt; write() 将内容一次性写入文件中 12345with open('b.txt', mode='wt', encoding='utf-8') as f: f.write('hello')# 打开文件 b.txthello writelines() 将内容循环写入文件中 12345678910with open('b.txt', mode='wt', encoding='utf-8') as f: f.writelines('hello')# 相当于with open('b.txt', mode='wt', encoding='utf-8') as f: for i in 'hello': f.write(i)# 打开文件 b.txthello a 模式，只追加写模式 文件不存在，则创建一个空文件，并且将文件指针跳到文件的末尾文件存在，则会将文件指针跳到文件的末尾 12with open('a.txt', mode='at', encoding='utf-8') as f: pass 12345with open('a.txt', mode='at', encoding='utf-8') as f: print(f.writable())# 输出结果True 1234567with open('a.txt', mode='at', encoding='utf-8') as f: print(f.readable()) f.read()# 输出结果Falseio.UnsupportedOperation: not readable 123456789with open('a.txt', mode='at', encoding='utf-8') as f: f.write('你好\n')# 打开文件 a.txt111122223333你好你好你好 1234567891011with open('a.txt', mode='at', encoding='utf-8') as f: f.writelines(['aaaa\n', 'bbbb\n'])# 打开文件 a.txt111122223333你好你好你好aaaabbbb b 模式 操作文件内容 操作文件内容 t模式 有局限性优点：读写文件以 字符串 为单位，不用自己去进行编码解码的转换缺点：仅仅只适用于文本文件我们不仅仅要操作文本文件，还要操作 图片，视频，等，再用 t模式 就无法处理了文本文件 里存的是 字符，而 图片，视频文件中存的是 二进制 12345with open('1.mp4', mode='rt', encoding='utf-8') as f: f.read()# 输出结果UnicodeDecodeError: 'utf-8' codec can't decode byte 0x86 in position 37: invalid start byte b模式 字节，二进制模式，一种原始的模式，在硬盘上存的都是二进制模式，如果打开的文件时 b模式，意味告诉操作系统，不用做转换，文件存的是什么，读出来就是什么bytes` 二进制模式，该模式下操作文件的内容单位都是bytes，该模式适用于所有类型文件 注意： b模式 不需要指定 encoding 参数12345with open('1.mp4', mode='rb', encoding='utf-8') as f: f.read()# 输出结果ValueError: binary mode doesn't take an encoding argument 获取 音频文件 二进制内容 12345678with open('1.mp4', mode='rb') as f: data = f.readline() # 文件大，文件内容多，用 readline() print(type(data)) print(data)# 输出结果&lt;class 'bytes'&gt;b'\x00\x00\x00\xlcftypisom\x00\x00\x02\x00isomiso2mp41\x00\x00\x08free\t...' 获取 文本文件 二进制内容 12345678with open('d.txt', mode='rb') as f: data = f.read() # 文件小，文件内容少，用 read() print(type(data)) print(data)# 输出结果&lt;class 'bytes'&gt;b'\xe4\xbd\xa0\xe5\xa5\xbd\xe5\x95\x8a\r\naaaa\r\nbbbbccc\r\n1111' 12345678910with open('d.txt', mode='rb') as f: data = f.read() res = data.decode('utf-8') # 将读出的二进制内容解码，转换成人类可识别的内容 print(res)# 输出结果你好啊aaaabbbbccc1111 12with open('d.txt', 'wb') as f: f.write('你好，Python'.encode('utf-8')) 遍历文件内容的方式12345678with open(r'd.txt', mode='rt', encoding='utf-8') as f: for line in f: # 如果文件过大，使用 for循环 读文件内容 print(line, end='')# 输出结果你好，Python你好，Python你好，Python 123456with open(r'd.txt', mode='rb') as f: print(f.readline()) print(f.readline()) print(f.readline())# 输出结果 二进制文件内容，换行符不会被识别 12print(b'11111111\n')print('====================') 输出 二进制文件 内容时，print() 内不要加 end=&#39;&#39;遍历 音频文件 内容 123with open('1.mp4', mode='rb') as f: for line in f: print(line) 练习：利用 b模式，编写一个 cp工具示例一1234with open(r'D:\test.jpg', 'rb') as read_f,\ open(r'E:\test.jpg', mode='wb') as write_f: for line in read_f: write_f.write(line) 1234567src_file_path = input('源文件路径：').strip()dst_file_path = input('目标文件路径').strip()with open(r'%s' % src_file_path, 'rb') as read_f,\ open(r'%s' % dst_file_path, mode='wb') as write_f: for line in read_f: write_f.write(line) 123456789101112import syssrc_file_path = sys.argv[1]dst_file_path = sys.argv[2]with open(r'%s' % src_file_path, 'rb') as read_f,\ open(r'%s' % dst_file_path, mode='wb') as write_f: for line in read_f: write_f.write(line)# 执行结果python3 copy.py test.jpg test2.jpg 示例二 既可以拷贝文本又可以拷贝视频，图片等文件 用户一旦参数错误，打印命令的正确使用方法，如 usage: cp source_file target_file提示：可以用 import sys，然后用 sys.argv 获取脚本后面跟的参数 1234567import sysprint(sys.argv)# 执行结果python3 cp.py src.txt dst.txt['cp.py', 'src.txt', 'dst.txt'] 123456789import sysprint(sys.argv[1])print(sys.argv[2])# 执行结果python3 cp.py src.txt dst.txtsrc.txtdst.txt 1234567891011import sysif len(sys.argv) != 3: print('usage: cp source_file target_file') sys.exit()source_file, target_file=sys.argv[1], sys.argv[2]with open(source_file,'rb') as read_f, \ open(target_file,'wb') as write_f: for line in read_f: write_f.write(line) 可读可写模式 + r+t，r+bw+t，w+ba+t，a+b 12345678910with open('a.txt', mode='r+t', encoding='utf-8') as f: print(f.readable()) print(f.writable())# r+t 模式，在没有文件的情况下，会报找不到文件的提示FileNotFoundError: [Errno 2] No such file or directory: 'a.txt'# 执行结果TrueTrue 1234567with open('a.txt', mode='r+t', encoding='utf-8') as f: print(f.read())# 执行结果111222333 12345678with open('a.txt', mode='r+t', encoding='utf-8') as f: print(f.read()) f.write('444\n')# 执行后，查看 a.txt 文件111222333444]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python文件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python列表类型]]></title>
    <url>%2F2018%2F07%2F10%2FPython%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[list 列表类型 用途 存放多个值，记录人多个爱好，多个人名 定义方式 在 [] 内用逗号分隔 多个元素 每个元素可以是任意数据类型1234567lst = [1, 'aa', 3.1, [1, 2]] # lst = list([1, 'a', 3.1, [1, 2]])res = list('hello') # 将 字符串 转换成 列表print(res, type(res))# 输出结果['h', 'e', 'l', 'l', 'o'] &lt;class 'list'&gt; list 类型转换的工作原理：list(items) 先造一个空列表 类似调用了一个 for 循环，从 items 里取出一个值放入空列表中，循环往复直到取干净为止但凡可以被 for循环 循环的，都可以被 list() 转换1234print(list(range(1, 5)))# 输出结果[0, 1, 2, 3, 4] 调用 list() 方法123456&gt;&gt;&gt; list('hello')['h', 'e', 'l', 'l', 'o']&gt;&gt;&gt; list((1, 2, 3))[1, 2, 3]&gt;&gt;&gt; list(&#123;'x': 1, 'y': 2&#125;)['x', 'y'] 常用操作+内置方法 按索引存取值（正向存取+反向存取）：即可以取值，也可以改值 123456789101112131415161718l = ['a', 'b', 'c', 'd']print(l[3]) # 正向取值# 输出结果dprint(l[-1]) # 反向取值# 输出结果dl[3] = 'D' # 修改元素值print(l)# 输出结果['a', 'b', 'c', 'D']l[4] = '5555' # 不能根据索引往列表里追加元素值print(l)# 输出结果IndexError: list assignment index out of range 123456789101112131415161718192021222324252627282930313233343536names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[4]) # 正向取值# 输出结果yxxprint(names[-1]) # 反向取值# 输出结果yxxprint(names[-2])# 输出结果xxx# 即可以取值，也可以改值names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names[0] = 'EGON'print(names)# 输出结果['EGON', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(id(names))print(names)names[0] = 'EGON'print(id(names))print(names)# 输出结果3155914092616['egon', 'alex', 'wxx', 'xxx', 'yxx']3155914092616['EGON', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names[5] = 3 # 超出索引限制会报错# 输出结果IndexError: list assignment index out of range 切片（顾头不顾尾，步长） 从一个大列表中切出一个字列表[起始位置:结束位置:步长] 123456l = ['a', 'b', 'c', 'd']l1 = l[1:3]print(l1)# 输出结果['b', 'c'] 1234567891011121314151617181920212223names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[起始位置:结束位置:步长])print(names[0:3]) # 正向取# 输出结果['egon', 'alex', 'wxx']print(names[0:3:2]) # 正向步长# 输出结果['egon', 'wxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[::1])# []内 起始没写，默认从索引0开始# 结束没写，默认到最后结束# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[:]) # [] 冒号左边没有值，默认索引是0，冒号右边没有写值，默认到最后结束 # 如果要获取列表内所有的值，可以省略掉 冒号 左右两边的值# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx'] 反向取值，反向步长（顾头不顾尾）1234567891011121314print(names[起始位置:结束位置:反向步长])names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(names[3:0:-1]) # 遵循切片顾头不顾尾的规则，agon 获取不到# 输出结果['xxx', 'wxx', 'alex']print(names[3::-1]) # 在结束位置不写值，就能获取到最后一个元素值# 输出结果['xxx', 'wxx', 'alex', 'egon']print(names[-1::-1])# 输出结果['yxx', 'xxx', 'wxx', 'alex', 'egon'] 长度 len()12345l = ['a', 'b', 'c', 'd']print(len(l)# 输出结果4 12345names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']print(len(names))# 输出结果5 成员运算 in 和 not in123456789101112names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]print('alex' in names)# 输出结果Trueprint(4 in names)# 输出结果Trueprint(5 not in names)# 输出结果True 追加 append()123456l = ['a', 'b', 'c', 'd']l.append('aaa')print(l)# 输出结果['a', 'b', 'c', 'd', 'aaa'] 12345678910111213names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.append('oldboy')print(names)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx', 'oldboy']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.append('oldboy1')names.append('oldboy2')names.append('oldboy3')print(names)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'yxx', 'oldboy1', 'oldboy2', 'oldboy3'] 插入 insert()1234567891011121314151617l = ['a', 'b', 'c', 'd']l.insert(1, 'B')print(l)# 输出结果['a', 'B', 'b', 'c', 'd']l.insert(0, 'B')print(l)# 输出结果['B', 'a', 'b', 'c', 'd']l.insert(0, 'B')l.insert(0, 'egon')print(l)# 输出结果['egon', 'B', 'a', 'b', 'c', 'd'] 12345678910names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.insert(0, oldboy) # 两个参数：索引下标，插入的值print(names)# 输出结果['oldboy', 'egon', 'alex', 'wxx', 'xxx', 'yxx']names.insert(2, 'oldboy')print(names)# 输出结果['egon', 'alex', 'oldboy', 'wxx', 'xxx', 'yxx'] 删除 del, remove(), pop()del 删除1234567891011l = ['a', 'b', 'alex', 'd']del l[2]print(l)# 输出结果['a', 'b', 'd']res = del l[2]print(res)# 输出结果SyntaxError: invalid syntax 123456names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']del names[2] # 删除列表中某一个元素print(names)# 输出结果['egon', 'alex', 'xxx', 'yxx'] 非列表独有的删除，是一种通用的删除方法 remove() 删除 只是单纯的删除操作，没有返回值 1234567891011l = ['a', 'b', 'alex', 'd']l.remove('alex')print(l)# 输出结果['a', 'b', 'd']res = l.remove('alex') # 只是单纯的删除操作，没有返回值print(res)# 输出结果None 12345678910111213141516names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.remove(0) # 单纯的删除，没有返回值print(names)# 输出结果ValueError: list.remove(x): x not in listnames = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.remove('wxx') # remove() 是指定元素值删除print(names)# 输出结果['egon', 'alex', 'xxx', 'yxx']res = names.remove('wxx') # remove() 没有返回值print(res)# 输出结果None pop() 从列表中取走一个元素值 删除一个元素 将该元素当做返回值返回默认从最后一个删除 12345678910111213l = ['a', 'b', 'alex', 'd']res = l.pop() # 默认从最后一个删除print(l)print(res)# 输出结果['a', 'b', 'alex']dl = ['a', 'b', 'alex', 'd']res = l.pop(2)print(res)# 输出结果alex 1234567891011121314151617181920212223names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']names.pop(0) # pop() 是按照索引下标删除元素值print(names)# 输出结果['alex', 'wxx', 'xxx', 'yxx']names = ['egon', 'alex', 'wxx', 'xxx', 'yxx']res = names.pop(0)print(names)print(res) # pop() 会获取返回删除的元素值# 输出结果['alex', 'wxx', 'xxx', 'yxx']egonres = names.pop(100) # 超过索引限制会报错# 输出结果IndexError: pop index out of rangenames = ['egon', 'alex', 'wxx', 'xxx', 'yxx']if 100 &lt; len(names): # 可以加一个判断 来让它不报错 res = names.pop(100) print(names) print(res) 循环（循环取值）12345678l = ['a', 'b', 'c']for item in l: print(item)# 输出结果abc 1234567891011121314names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]for item in names: print(item)# 输出结果egonalexwxxxxxyxx1234 列表可变类型可变类型：值变，id不变，可变 == 不可hash 12345678l1 = ['a', 'b', 'c']print(id(l1))l1[0] = 'A'print(id(l1))# 输出结果14608203903441460820390344 reverse() 反转（单纯的反转）123456l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.reverse()print(l1)# 输出结果['a', 'b', 'a', 'a', 2.3, 1] 123456names = ['alex', 'wxx', 'lxx']names.reverse()print(names)# 输出结果['lxx', 'wxx', 'alex'] 123456names = ['egon', 'alex', 'wxx', 'xxx', 'yxx', 1, 2, 3, 4]names.reverse() # reverse() 反转，改的是原值print(names)# 输出结果[4, 3, 2, 1, 'yxx', 'xxx', 'wxx', 'alex', 'egon'] count() 统计列表元素值的个数12345l1 = [1, 2.3, 'a', 'b', 'a']print(l1.count('a'))# 输出结果3 12345names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]print(names.count('xxx')) # count()方法 统计列表元素值的个数# 输出结果2 clear() 清空列表所有元素值123456l1 = [1, 2.3, 'a']l1.clear()print(l1)# 输出结果[] 123456names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]names.clear() # clear() 清空列表所有元素值print(names)# 输出结果[] copy() 列表复制123456l1 = [1, 2.3, 'a']l2 = l1.copy()print(l2)# 输出结果[1, 2.3, 'a'] 12345678names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]print(names)lst = names.copy() # copy() 复制一份列表元素值print(lst)# 输出结果['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4] extend() 向列表末尾追加多个元素值123456789101112131415l1 = [1, 2.3, 'a', 'a', 'b', 'a']l2 = [4, 5, 6]l1.append(l2[0])l1.append(l2[1])l1.append(l2[2])# 输出结果[1, 2.3, 'a', 'a', 'b', 'a', 4, 5, 6]# 一个一个追加，比较麻烦l1 = [1, 2.3, 'a', 'a', 'b', 'a']l2 = [4, 5, 6]l1.extend(l2)print(l1)# 输出结果[1, 2.3, 'a', 'a', 'b', 'a', 4, 5, 6] index()获取列表元素值的索引下标1234567891011121314l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.index('egon')# 输出结果ValueError: 'egon' is not in listl1 = [1, 2.3, 'a', 'a', 'b', 'a']print(l1.index('a'))# 输出结果2l1 = [1, 2.3, 'a', 'a', 'b', 'a']print(l1.index('a', 0, 3)) # 指定 起始位置,结束位置（顾头不顾尾）# 输出结果2 12345678910names = ['egon', 'alex', 'wxx', 'xxx', 'xxx', 'yxx', 1, 2, 3, 4]# names.index(元素值, 起始位置，结束位置)print(names.index('alex'))# 输出结果1# 没有的元素值，会报错print(names.index('alexabcd'))# 输出结果ValueError: 'alexabcd' is not in list sort 排序 默认从小到大排序 123456names = [1, 10, 3, -1]names.sort() # 默认从小到大排序print(names)# 输出结果[-1, 1, 3, 10] 1234567891011nums = [9, 3, 4, -1, 5, 100, 98]nums.sort(reverse=True) # 从大到小排序print(nums)# 输出结果[-1, 3, 4, 5, 9, 98, 100]nums = [9, 3, 4, -1, 5, 100, 98]nums.sort(reverse=True) # 从大到小排序print(nums)# 输出结果[100, 98, 9, 5, 4, 3, -1] 123456l1 = [1, 2.3, 'a', 'a', 'b', 'a']l1.sort()# 输出结果TypeError: '&lt;' not supported between instances of 'str' and 'float'# 字符串 和 浮点类型 之间不支持排序 1234567names = [1, 10, 3, -1, 'a']names.sort()print(names)# 输出结果TypeError: '&lt;' not supported between instances of 'str' and 'int'# 字符串 和 整型 之间不支持排序 列表中的元素值，必须是 同一 类型，才能做比较排序 1234567891011121314151617181920212223names = ['b', 'a', 'c']names.sort()print(names)# 输出结果['a', 'b', 'c']names = ['b', 'a', '+']names.sort()print(names)# 输出结果['+', 'a', 'b']s1 = 'hello's2 = 'z'print(s1 &gt; s2)# 输出结果Falsex = 'hello'y = 'hez'print(y &gt; x)# 输出结果True 字符串 是 根据位置 比较的，先比较两个字符串的第一个位置的字符如果 第一个字符比出大小，后面的字符将不再做比较字符串之间根据 ASCII码 来做比较小写字母 比 大写字母 大 列表比较大小123456789101112131415161718lst1 = [1, 2, 'a', 'b']lst2 = [3, 4]print(lst2 &gt; lst1)# 输出结果Truelst1 = [1, 2, 'a', 'b']lst2 = [1, 2, 3]print(lst2 &gt; lst1)# 输出结果TypeError: '&gt;' not supported between instances of 'int' and 'str'# 第三个位置不是同一种类型，所以报错lst1 = [1, 2, 'a', 'b']lst2 = [1, 2, 'b']print(lst2 &gt; lst1)# 输出结果True 队列：先进先出1234567891011121314151617l = []# 入队l.append('first')l.append('second')l.append('third')print(l)# 输出结果['first', 'second', 'third']# 出队print(l.pop(0))print(l.pop(0))print(l.pop(0))# 输出结果firstsecondthird 堆栈：先进后出1234567891011121314151617l = []# 入栈l.append('first')l.append('second')l.append('third')print(l)# 输出结果['first', 'second', 'third']# 出栈print(l.pop(-1)) # 默认是 -1，不写就是 -1print(l.pop(-1))print(l.pop(-1))# 输出结果thirdsecondfirst 总结 能存多个值，没有类型限制 有序（能够按索引取值的属于有序的） 可变类型 可变：值变，id不变，可变 == 不可hash list（任何能被 for循环的对象）转换成 列表]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python列表类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python集合类型]]></title>
    <url>%2F2018%2F07%2F10%2FPython%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[set 集合类型 用途 主要用于关系运算去重 定义方式 在 {} 内用逗号分隔开多个元素每一个元素必须为不可变类型(int，float，str，tuple)集合内的元素不能重复集合内元素无序 12pythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']linuxers = ['wxx', '吴三江', '张大炮', '王全蛋'] 获取即报名Linux，又报名Python 课程 的 学生姓名 12345678pl = []for name in pythoners: if name in linuxers: pl.append(name)print(pl)# 输出结果['wxx', '吴三江'] 123456789s = &#123;&#125; # 定义空字典print(s, type(s))# 输出结果&#123;&#125; &lt;class 'dict'&gt;s = set() # 定义空集合print(s, type(s))# 输出结果set() &lt;class 'set'&gt; 123456789s = &#123;1, 2&#125; # s = set(&#123;1, 2&#125;)print(type(s))# 输出结果&lt;class 'set'&gt;s = &#123;1, 'a', 3&#125; # s = set(&#123;1, 'a', 3&#125;)print(s, type(s))# 输出结果&#123;1, 3, 'a'&#125; &lt;class 'set'&gt; 12345s = &#123;1, 'a', 3.1, [1,2]&#125;# 输出结果TypeError: unhashable type: 'list'# 列表类型 是 不可hash类型，不能用于 集合 可变类型 不可 hash不可变类型 可 hash集合无法一个值一个值取值 集合类型 元素不能重复12345s = &#123;1,2,2,2,2,22,2,2,2,2&#125;print(s)# 输出结果&#123;1, 2, 22&#125; 集合去重有局限性 不能保证原来的顺序不能针对可变类型去重 1234s = set('hello')print(s)# 输出结果&#123;'o', 'h', 'l', 'e'&#125; 12345678910111213141516171819202122l = [1, 1, 1, 1, 'egon', 'alex', 'egon']s = set(l) # 将 l 列表 转换成 集合print(s)# 输出结果&#123;1, 'egon', 'alex'&#125;s = &#123;'egon', 'alex', 'wxx', 'lxx'&#125;for item in s: # 遍历 集合 print(item)# 输出结果egonlxxwxxalexl = [1, 1, 1, 1, 'egon', 'alex', 'egon']s = set(l) # 将 列表 转换成 集合# print(s)l = list(s) # 再将 集合 转换成 列表print(l)# 输出结果[1, 'egon', 'alex'] 需求：即想针对可变类型去重，又想保证原来的顺序 列表内的元素有可变类型 去重之后要保证原来顺序 1234567891011121314151617181920info = [ &#123;'name':'egon', 'age':18&#125;, &#123;'name':'alex', 'age':73&#125;, &#123;'name':'egon', 'age':18&#125;, &#123;'name':'lxx', 'age':19&#125;, &#123;'name':'egon', 'age':18&#125;, &#123;'name':'lxx', 'age':19&#125;,]l = []for dic in info: if dic not in l: l.append(dic)# print(l)info = lprint(info)# 输出结果[&#123;'name':'egon', 'age':18&#125;, &#123;'name':'alex', 'age':73&#125;, &#123;'name':'lxx', 'age':19&#125;] 12345678910s = &#123;'a', 'asdfsa', (1, 2), 1, 3.1&#125;for item in s: print(item)# 输出结果(1, 2)13.1asdfsaa 长度len()12345678print(len(&#123;1, 2, 3&#125;))# 输出结果3pythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']print(len(pythoners))# 输出结果5 成员运算 in 和 not in12345678print(1 in &#123;1, 2, 3&#125;)# 输出结果Truepythoners = ['艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy']print('egon' in pythoners)# 输出结果True 集合的关系运算交集 &amp; ，intersection() 内置方法 获取两个集合的共同部分 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners &amp; linuxers)# 输出结果['wxx', '吴三江'] 123print(pythoners.intersection(linuxers))# 输出结果['wxx', '吴三江'] 差集 -，difference() 内置方法 获取只报名Python，没有报名Linux 的人即集合pythoners 减去 linuxers ，称之为 差集 12345pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners - linuxers)# 输出结果&#123;'艾利克斯', 'oldboy', 'egon'&#125; 123print(pythoners.difference(linuxers))# 输出结果&#123;'艾利克斯', 'oldboy', 'egon'&#125; 获取只报名 linux，没有报名 python 的人 12345pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(linuxers - pythoners)# 输出结果&#123;'王全蛋', '张大炮'&#125; 123print(linuxers.difference(pythoners))# 输出结果&#123;'王全蛋', '张大炮'&#125; 合集，并集 |，union() 内置方法 获取两个集合的总和，把两个集合合到一起，把重复的部分去除获取所有的学生的姓名 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners | linuxers)# 输出结果&#123;'吴三江', 'oldboy', '王全蛋', 'egon', 'wxx', '张大炮', '艾利克斯'&#125; 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners.union(linuxers))# 输出结果&#123;'吴三江', 'oldboy', '王全蛋', 'egon', 'wxx', '张大炮', '艾利克斯'&#125; 对称差集 ^，symmetric_difference()` 内置方法 获取没有同时报名两门课程的学生姓名 123456789pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners ^ linuxers)# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125;print(linuxers ^ pythoners)# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125; 123456pythoners = &#123;'艾利克斯', 'wxx', 'egon', '吴三江', 'oldboy'&#125;linuxers = &#123;'wxx', '吴三江', '张大炮', '王全蛋'&#125;print(pythoners.symmetric_difference(linuxers))# 输出结果&#123;'张大炮', '艾利克斯', 'egon', 'oldboy', '王全蛋'&#125; == 比较两个值是否相等1234567891011s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2, 3&#125;print(s1 == s2)# 输出结果Trues1 = &#123;1, 2, 3&#125;s2 = &#123;3, 2, 1&#125;print(s1 == s2)# 输出结果True 集合之间做比较，指的是包含 与 被包含的关系 父集 &gt; &gt;=，issuperset() 内置方法12345678910s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1 &gt; s2)print(s1 &gt;= s2)# 判断 s1 是否是 s2 的父集# 判断 s1 是否包含 s2# 输出结果TrueTrue 123456s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2, 4&#125;print(s1 &gt;= s2) # 判断 s1 是否是 s2 的父集# 输出结果False 123456s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1.issuperset(s2)) # 判断 s1 是否是 s2 的父集# 输出结果True 子集 &lt; &lt;=，issubset()内置方法1234567s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s2 &lt;= s1) # 判断 s2 是否是 s1 的子集 # 判断 s2 是否被 s1 包含# 输出结果True 1234567s1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s2.issubset(s1)) # 判断 s2 是否是 s1 的子集 # 判断 s2 是否被 s1 包含# 输出结果True 添加集合元素 集合属于可变类型，值变，id不变，不可 hash 123456789s1 = &#123;1, 2, 3, 4, 5&#125;print(id(s1))s1.add(6)print(id(s1))# 输出结果3014527602472&#123;1, 2, 3, 4, 5, 6&#125;3014527602472 12345678910s1 = &#123;'a', 'b', 'c'&#125;print(id(s1))s1.add('d')print(s1)print(id(s1))# 输出结果1981688305928&#123;'b', 'd', 'a', 'c'&#125;1981688305928 删除集合元素remove() 按元素名删除元素12345678910111213141516s1 = &#123;'a', 'b', 'c'&#125;s1.remove('b')print(s1)# 输出结果&#123;'a', 'c'&#125;# 查看是否有返回值s1 = &#123;'a', 'b', 'c'&#125;res = s1.remove('b') # 只是单纯的删除，没有返回值print(res)# 输出结果Nones1.remove('dddd') # 指定元素删除，如果元素不存在，则报错# 输出结果KeyError: 'dddd' discard() 按元素名删除元素1234567891011s1 = &#123;1, 2, 3, 4, 5&#125;s1.discard(3)print(s1)# 输出结果&#123;1, 2, 4, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s1.discard(333333) # 指定元素删除，如果元素不存在，不会报错print(s1)# 输出结果&#123;1, 2, 3, 4, 5&#125; 123456789101112131415161718s1 = &#123;'a', 'b', 'c'&#125;s1.discard('b')print(s1)# 输出结果&#123;'a', 'c'&#125;# 查看是否有返回值s1 = &#123;'a', 'b', 'c'&#125;res = s1.discard('b') # 没有返回值print(res)# 输出结果Nones1 = &#123;'a', 'b', 'c'&#125;s1.discard('dddd') # 指定元素删除，如果元素不存在，不会报错print(s1)# 输出结果&#123;'a', 'b', 'c'&#125; pop() 随即删除，有返回值，将删除的元素值返回出来123456s1 = &#123;'a', 'b', 'c'&#125;res = s1.pop() # 随即删除，有返回值，将删除的元素值返回出来print(res)# 输出结果c 更新集合元素update() 更新集合中的元素值，并且去除重复值12345678910s1 = &#123;1, 2, 3, 4, 5&#125;s1.update(&#123;3, 4, 5, 6, 7&#125;)print(s1)# 输出结果&#123;1, 2, 3, 4, 5, 6, 7&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s1.update('hello') # 先将字符串 hello 转成集合，再更新到 s1 里去# 输出结果&#123;1, 2, 3, 4, 5, 'l', 'e', 'h', 'o'&#125; 清空集合元素12s1 = &#123;1, 2, 3, 4, 5&#125;s1.clear 查看两个集合是否有交集（共同部分）isdisjoint() 判断两个集合没有交集（共同部分），返回 True1234# 查看注释，Ctrl + 点击左键def isdisjoint(self, *args, **kwargs): # real signature unknown """ Return True if two sets have a null intersection. """ pass 1234567891011s1 = &#123;1, 2, 3&#125;s2 = &#123;4, 5, 6&#125;print(s1.isdisjoint(s2))# 输出结果Trues1 = &#123;1, 2, 3&#125;s2 = &#123;1, 2&#125;print(s1.isdisjoint(s2))# 输出结果False 把找出来的差集，重新覆盖原集合12345678910111213141516171819202122232425262728s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;res = s1.difference(s2) # s1 - s2print(res)# 输出结果&#123;1, 2, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1.difference(s2) # s1 - s2print(s1)# 输出结果&#123;1, 2, 3, 4, 5&#125;# 原 s1 的值其实并没有改变s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1 = s1.difference(s2) # s1 = s1 - s2，将改变后的值重新赋值给 s1 将其改变print(s1)# 输出结果&#123;1, 2, 5&#125;s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 4&#125;s1.difference_update(s2) # s1=s1.difference # s1=s1-s2，将改变后的值重新赋值给 s1 将其改变print(s1)# 输出结果&#123;1, 2, 5&#125; 1234567891011121314s1 = &#123;'a', 'b', 'c'&#125;s2 = &#123;'b', 'd', 'f'&#125;print(s1.difference(s2))print(s1)# 输出结果&#123;'a', 'c'&#125; # 这是一个新的元素值&#123;'a', 'c', 'b'&#125; # 原 s1 的内容没有改变s1 = &#123;'a', 'b', 'c'&#125;s2 = &#123;'b', 'd', 'f'&#125;s1.difference_update(s2) # 等于 s1 = s1.difference(s2)print(s1)# 输出结果&#123;'a', 'c'&#125; # 将差集的结果直接赋值给s1 将对称差集的结果，重新覆盖原集合1s1.symmetric_difference_update() 将交集的结果，重新覆盖原集合1s1.intersection_update() 用集合去重，不保证顺序1234567l = ['a', 'b', 1, 'a', 'a']print(list(set(l)))names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']print(set(names))# 输出结果&#123;'wxx', 'alex', 'egon'&#125; 将 集合 转回 原来 的类型，不保证顺序12345names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']print(list(set(names)))# 输出结果['egon', 'wxx', 'alex'] 用集合去重，局限性很强不能保证元数据类型的顺序元数据类型中包含的元素必须全都为不可变类型 即想去重，又想保证顺序 遍历集合123s = &#123;'egon', 'alex', 'wxx', 'lxx'&#125;for item in s: print(item) 123456789names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx']new_names = []for name in names: if name not in new_names: new_names.append(name)print(new_names)# 输出结果['alex', 'egon', 'wxx'] 使用 keys() 方法1names = ['alex', 'egon', 'alex', 'wxx', 'wxx', 'wxx'] list() 方法是把 str字符串 或 tuple元组 转成 list列表12345new_names = list(&#123;&#125;.fromkeys(names).keys())print(new_names)# 输出结果['alex', 'egon', 'wxx'] 列表类型，字典类型，集合类型方式 去除重复的部分，保证原来的顺序12345678910111213141516171819202122232425262728l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = set() # 创建一个空集合new_l = []for d in l: # n, a, s = d['name'], d['age'], d['sex'] # 获取到 字典的值 # print(n, a, s) # s.add((n, a, s)) values = (d['name'], d['age'], d['sex']) print(values) if values not in s: s.add(values) new_l.append(d)print(new_l)# 输出结果('egon', 18, 'male')('alex', 73, 'male')('egon', 20, 'female')('egon', 18, 'male')('egon', 18, 'male')[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 列表类型，字典类型 方式 去除重复的部分，保证原来的顺序123456789101112131415161718l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = []new_l = []for d in l: if d not in s: s.append(d) new_l.append(d)print(new_l)# 输出结果[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 列表类型，字典类型 方式 去除重复的部分，保证原来的顺序12345678910111213141516l = [ &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;]s = []for d in l: if d not in s: s.append(d)print(s)# 输出结果[&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125;, &#123;'name': 'alex', 'age': 73, 'sex': 'male'&#125;, &#123;'name': 'egon', 'age': 20, 'sex': 'female'&#125;] 去重，保证原来的顺序1234567l = ['a', 'b', 1, 'a', 'a']l_new = []s = set()for item in l: if item not in s: s.add(item) l_new.append(item) 集合总结定义1s = &#123;1, 2, 3&#125; 注意 集合能存多个值集合无序集合内元素不能重复集合内的元素必须为不可变类型，但set集合是可变的 用途 集合是用来进行关系运算，单独取集合的某一个元素是没有意义的，也没有相应的方法1234交集：s1 &amp; s2 取两个集合的共同部分差集：s1 - s2 结果存于 s1 而不存于 s2 的元素集合补集：s1 ^ s2 扣掉 s1 与 s2 共同部分，剩下的部分合到一起并集：s1 | s2 把两个合到一起，去掉重复]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python集合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串类型]]></title>
    <url>%2F2018%2F07%2F05%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[str 字符串类型str 基本使用用途 用于 描述型的数据，姓名，性别，地址，国籍 等 定义方式 在单引号，双引号，三引号内包含一串的字符 1234567891011121314151617msg="hello world" # msg=str("hello world") res1=str(1)res2=str(1.2)res3=str([1,2,3])print(type(res1),type(res2),type(res3))info = 'my name is agon'name = 'egon' # name = str('egon')print(name)print(type(name))print(id(name))# 输出结果egon&lt;class 'str'&gt;3172826579048 常用操作+内置的方法12345678910111213141516171819# 按索引取值（正向取+反向取），只能取msg = 'he lo'print(msg[0])print(msg[3])# 输出结果hlmsg = 'he lo'msg[2] = 'A'TypeError: 'str' object does not support item assignment# 字符串不支持更改内容msg = 'hello'print(msg[0:]) # 正向取值print(msg[::-1]) # 反向取值# 输出结果helloolleh 切片（顾头不顾尾，步长）123456789101112131415161718192021msg = 'hello world'print(msg[0:4]) # 从索引 0 开始 到 4 结束# 输出结果hell # 遵循 顾头不顾尾 的规则，输出到 o 前面的字符 l 结束print(msg[0:4:2]) # 步长，隔2步，取一个字符# 输出结果hl# 从一个大字符串中切除一个子字符串（骨头不顾尾，步长）msg = 'hello world'print(msg[1:3])print(msg[6:11])print(msg[6:11:2])# 倒着取值，注意方向要一致msg = 'hello world'print(msg[6:])print(msg[-1:-6:-1])print(msg[-1::-1])print(msg[::-1]) 123456789inp = 'get a.txt'cmd = inp[0:3]filepath = inp[4:]print(cmd)print(filepath)# 输出结果 获取 命令 和 文件名geta.txt 123456inp = 'get a.txt'# inp.split() # 不指定 分割符 默认以空格为分割符res = inp.split(' ')print(res)# 输出结果['get', 'a.txt'] 12345678910111213s = "1234567890"s = "abcdefghij"print(s[-1:]) # 截取最后一个元素print(s[0:3]) # 截取第一位到第三位的字符print(s[:]) # 截取字符串的全部字符print(s[6:]) # 截取第七个字符到结尾print(s[:-3]) # 截取从头开始到倒数第三个字符之前print(s[2]) # 截取第三个字符print(s[::-1]) # 创建一个与原字符串顺序相反的字符串print(s[-3:-1]) # 截取 倒数第三位 和 倒数第一位 之前的字符print(s[-3:]) # 截取 倒数第三位 到结尾print(s[:-12:-2]) # 逆序截取后个数，每 3 个取一个，而且取是逆向取值print(s[:10:2]) # 前 10 个数，每两个取一个 长度len12345msg = 'hello world'print(len(msg)) # 长度是11，索引最大到10# 输出结果5 成员运算 in 和 not in12345678910111213141516171819202122232425msg = 'hello world alex is SB'print('alex' in msg) # 判断 子字符串 'alex' 是否在 msg 变量字符串里print('SB' in msg)print('egon' not in msg)print(not 'egon' in msg)# 输出结果Truemsg = 'alex say my name is alex'if 'alex' in msg: print('存在')# 输出结果存在msg = 'alex say my name is alex'print('alex' in msg)print('alex' not in msg) # 推荐使用这种形式print(not 'alex' in msg)# 输出结果TrueFalseFalse strip 移除字符串左右两边的字符 strip 只能 移除 字符串 左右两边的 字符1234567name = '***egon*****'print(name.strip('*'))print(name)# 输出结果egon # strip 是生成了一个新的值，并不是改变原值***egon***** 12345678name = ' egon '# strip() 不写指定符号，默认去除字符串左右两边的空格name = name.strip()# 将 strip() 生成的新值，重新赋值给 变量name，可以看作是 字符串的变更print(name)# 输出结果egon 12345msg = '* / , alex is sb -*=*******'print(msg.strip('*, /-='))# 输出结果alex is sb 123name = input('&gt;&gt;&gt;: ')name = input('&gt;&gt;&gt;: ').strip()print(name) 1234567while True: # cmd = input('cmd&gt;&gt;: ') # cmd = cmd.strip() # 主要用于用户输入时，去除左右两边的空格字符 cmd = input('cmd&gt;&gt;: ').strip() if len(cmd) == 0:continue if cmd == 'q':break print('%s is running' % cmd) 切分（分割）split1234567891011info = 'root:x:0:0:root:/root:/bin/bash'print(info)res = info.split(':') # 不指定分割符，默认从头切到尾# res = info.split(':', maxsplit=-1)print(res, type(res))print(res[0]) # 经过 split 分割后，获取下标为 0 的元素# 输出结果root:x:0:0:root:/root:/bin/bash['root', 'x', '0', '0', 'root', '/root', '/bin/bash']root 123456789101112cmd = 'get a.txt'res = cmd.split() # split() 不写参数，默认以空格分割print(res[0])print(res[1])# 输出结果 获取 命令 和 文件名geta.txtcmd = 'get a.txt 33333'res = cmd.split(' ', maxsplit=1)print(res) 循环（循环取值） while 循环取值12345678msg = 'hello world'n = 0while True: print(msg[n]) n += 1# 输出信息IndexError: string index out of range 123456789101112131415161718msg = 'hello world'n = 0 # 指定一个计数器while n &lt; len(msg): print(msg[n]) n += 1 # 自加计数器# 输出结果helloworld for循环迭代取值12345678910111213141516msg = 'hello world'for item in msg: print(item)# 输出结果helloworld strip, lstrip, rstrip123456789name='*****hello*****'print(name.strip('*')) # 去除左右两边的字符print(name.lstrip('*')) # 去除左边的字符print(name.rstrip('*')) # 去除右边的字符# 输出结果hellohello**********hello lower, upper12345678910name='hello'print(name.lower()) # 转换小写字母print(name) # lower 方法不改变原值print(name.upper()) # 转换大写字母print(name) # upper 方法不改变原值# 输出结果helloHELLOHello startswith, endswith1234567name='Hello is run'print(name.startswith('Hello')) # 以 Hello 开头print(name.endswith('run')) # 以 run 结尾# 输出结果TrueTrue format 字符串格式化输出 的 三种方法 %s 的方式传值需要记住传值位置1print('name is %s age is %s' % ('egon', 18)) 缺点严格依赖 %s 的位置 123456789101112131415161718192021# format() 里的参数可以不用对应（推荐使用这种方式）print('name is &#123;name&#125; age is &#123;age&#125;'.format(age=18, name='egon'))# 输出方式name is egon age is 18# 此方法类似 %s 的格式化输出print('name is &#123;&#125; age is &#123;&#125;'.format('egon', 18))# 输出结果name is egon age is 18print('name is &#123;0&#125;&#123;0&#125;&#123;0&#125; age is &#123;1&#125;'.format(18, 'egon'))# 输出结果name is 181818 age is egonprint('&#123;1&#125; &#123;0&#125; &#123;1&#125;'.format('egon', 18, 'male'))# 输出结果18 egon 18print('&#123;0&#125; &#123;1&#125; &#123;2&#125;'.format('egon', 18, 'male'))# 输出结果egon 18 male split, rsplit split 可以把 字符串 切割成 列表 1234cmd = 'get|a.txt|3333'print(cmd.split('|', 1))print(cmd.rsplit('|', 1)) 123456789info = 'root:x:0:0:root:/root:/bin/bash'print(info.split(':')) # 这里的分割符指定为(:)冒号，默认分隔符为空格print(info.split(':', -1)) # 默认值为 -1，-1 表示从头切到尾info = 'root:x:0:0:root:/root:/bin/bash' # 获取第一个 rootprint(info.split(':', 1)) # 1 表示切一次，从左往右切割一次# 输出结果['root', 'x:0:0:root:/root:/bin/bash'] 12345info = 'root:x:0:0:root:/root:/bin/bash'print(info.rsplit(':', 1)) # 从右开始切割一次# 输出结果['root:x:0:0:root:/root', '/bin/bash'] join 拼接 join 把 列表 转成 字符串，前提是列表中的所有数据为字符串123456info = 'root:x:0:0:root:/root:/bin/bash'str_to_list = info.split(':')print(str_to_list)# 输出结果['root', 'x', '0', '0', 'root', '/root', '/bin/bash'] 12345678lst = ['root', 'x', '0', '0', 'root', '/root', '/bin/bash']list_to_str = ':'.join(lst)print(list_to_str)print(type(list_to_str))# 输出结果root:x:0:0:root:/root:/bin/bash&lt;class 'str'&gt; iterable 参数 可被 for 循环的 全都是 iterable1234567for i in lst: print(i)# 注意：join 只能连接 所包含的元素 全都为 字符串类型 的列表lst = [1, 2, 3]':'.join(lst)TypeError: sequence item 0: expected str instance, int found replace 替换字符串 replace 不会改变原值123456789msg = 'my name is alex, alex say hello'print(msg.replace('alex', 'egon')) # 不指定，表示全部替换print(msg.replace('alex', 'egon', 1)) # 1 表示 替换第一个print(msg.replace('alex', 'egon', -1)) # -1 表示全部替换# 输出结果my name is egon, egon say hellomy name is egon, alex say hellomy name is egon, egon say hello isdigit 判断 字符串 是否是 纯数字1234567print('10101'.isdigit())# 输出结果Trueprint('abc123'.isdigit())# 输出结果False 判断 bytes 和 unicode 类型，是最常用的用于于判断 字符 是否为 “数字” 的方法 猜年龄演示错误结果 1234567891011121314151617age='abcdefg'int(age)# 不是整型的报错信息ValueError: invalid literal for int() with base 10: 'abcdefg'age = 50while True: age = input('&gt;&gt;: ').strip() if not age.isdigit():continue age = int(age) if age &gt; 50: print('too big') elif age &lt; 50: print('too small') else: print('you got it') break find, rfind, index, rindex, coun1234567891011121314151617181920212223msg = 'my name is egon, egon is nb'print(msg.find('egon')) # 查找 子字符串 在 大字符串中的起始位置 # 找的是 'egon' 在大字符串 msg 中的起始索引# 输出结果11print(msg.find('egon', 1, 5) # 从 1 开始 到 5 结束 # 顾头不顾尾，找不到则返回 -1 不会报错，找到了则显示索引# 输出结果-1print(msg.index('egon', 1, 3)) # 同上，但是找不到会报错# 报错信息ValueError: substring not foundprint(msg.index('egon')) # 不写位置参数，和 find() 效果一样# 输出结果6print(msg.rfind('egon'))print(msg.rindex('egon'))print(msg.count('egon')) # 统计 子字符串 有多少个print(msg.count('egon', 1, 3)) # 顾头不顾尾，如果不指定范围则查找所有 center, ljust, rjust, zfill123456789101112131415print('info'.center(30,'#')) # 居中显示，两个参数，宽度，填充字符# 输出结果#############info##############print('info'.ljust(30,'*')) # 左对齐，两个参数，宽度，填充字符# 输出结果info**************************print('info'.rjust(30,'=')) # 右对齐，两个参数，宽度，填充字符# 输出结果==========================infoprint('info'.zfill(30)) # 用 0 填充 和 rjust 效果一样# 输出结果00000000000000000000000000info expandtabs 控制 tab键 的 空格个数123456789101112131415161718192021print('aaabbbb', end='')print('cccc', end='')# 输出结果aaabbbbccccprint(aaaa\nbbbb)# 输出结果aaaabbbbprint(r'a\tb') # \t 表示制表符 tab，如想取消掉这个制表符效果，在字符串前加 r # r开头的字符串内都是原始字符串，右斜杠没有特殊意义print('a\tb') # r 表示原始字符串(raw string)# 输出结果a\tba bprint('aaa\tbbb'.expandtabs(3)) # expandtabs 控制空格数print('aaa\tbbb'.expandtabs(tabsize=3))# 输出结果aaa bbb captalize, swapcase, title1234567891011print('abc'.capitalize()) # 首字母大写# 输出结果Abcprint('Ab'.swapcase()) # 大小写翻转# 输出结果aBprint('my name is egon'.title()) # 每个单词的首字母大写# 输出结果My Name Is Egon is数字系列 在 Python3 中12345678910111213141516171819202122num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isdigt 判断字符串是否是 bytes，unicodeprint(num1.isdigit()) # 常用（推荐）# 输出结果Trueprint(num2.isdigit())# 输出结果Trueprint(num3.isdigit()) # 不能判断中文数字# 输出结果Falseprint(num4.isdigit()) # 不能判断罗马数字# 输出结果False isnumeric 判断字符串是否是 unicode，中文/繁体数字，罗马数字 bytes 类型没有 isnumeric 方法123456789101112131415161718num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isnumeric: unicode, 中文，罗马print(num2.isnumeric())# 输出结果Trueprint(num3.isnumeric())# 输出结果Trueprint(num4.isnumeric())# 输出结果True isdecimal 判断字符串是否是 uncicode bytes 类型没有 isdecimal 方法123456789101112131415161718num1=b'4' # bytesnum2=u'4' # unicode, Python3 中无需加 u 就是 unicodenum3='四' # 中文/繁体数字 肆num4='Ⅳ' # 罗马数字# isdecimal:unicodeprint(num2.isdecimal())# 输出结果Trueprint(num3.isdecimal())# 输出结果Falseprint(num4.isdecimal())# 输出结果False 三者 都不能 判断 浮点数 1234num5 = '4.3'print(num5.isdigit())print(num5.isdecimal())print(num5.isnumeric()) 总结：最常用的是 isdigit，可以判断 bytes 和 unicode 类型，这也是最常见的数字应用场景如果要判断 中文数字 或 罗马数字，则需要用到 isnumeric is其他 判断字符串内是否是空格1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071print(''.isspace())# 输出结果Falseprint(' '.isspace()) # 判断字符串内是否是空格# 输出结果True# 判断字符串是否全部由字母组成print(''.isalpha())# 输出结果Falseprint('abcdefg'.isalpha()) # 判断字符串是否全部由字母组成# 输出结果Trueprint('abc123'.isalpha())# 输出结果False# 判断字符串中是否由字母或数字组成print(''.isalnum())# 输出结果Falseprint('abc123'.isalnum())# 输出结果Trueprint('abcdefg'.isalnum())# 输出结果Trueprint('123456'.isalnum())# 输出结果True# 判断字符串是否全都是小写字母print('Garfield'.islower())# 输出结果Falseprint('garfield'.islower())# 输出结果True# 判断字符串是否全都是大写字母print('Garfield'.isupper())# 输出结果Falseprint('garfield'.isupper())# 输出结果Falseprint('GARFIELD'.isupper())# 输出结果True# 判断字符串是否是标题，也就是单词首字母是否大写print('Garfield'.istitle())# 输出结果Trueprint('garfield'.istitle())# 输出结果Falseprint(''.isprintable())print(''.isidentifier()) str 字符串类型总结 只能存一个值 有序（能够按索引取值的属于有序的） 不可变类型不可变：值变，id也变。不可变==可hash12345678x = 'abc'print(id(x))x = 'bcd'print(id(x))# 输出结果16958601986241695860293792 参考文档http://www.cnblogs.com/linhaifeng/articles/7133357.html#_label3]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python字符串类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典类型]]></title>
    <url>%2F2018%2F07%2F05%2FPython%E5%AD%97%E5%85%B8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[dict 字典类型用途 可变类型，存放多个值，key:value，key 对 value 有描述性的作用 定义方式 在 {} 内用逗号分隔 多个元素 每个元素都是 key:value 的形式key 必须是不可变类型且唯一，key 通常都是用字符串类型，需要可描述的value 可以是任意数据类型即字典的 key 可以是 int, float, tuple, str, 通常是字符串类型 12345d = &#123;3.1:1, (1,2,3):2222&#125; # d = dict(&#123;3.1:1, (1,2,3):2222&#125;)print(d[(1,2,3)])# 输出结果2222 12345d1 = dict(x=1, y=2, z=3)print(d1)# 输出结果&#123;'x': 1, 'y': 2, 'z': 3&#125; 12345d2 = dict([('name', 'egon'), ['age', 18], ('sex', 'male')])print(d2)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; 1234567891011121314151617info = &#123;'name': 'egon', 'age': 18&#125; # info = dict(&#123;'name': 'egon', 'age': 18&#125;)print(info['name']) # 根据 key 取值# 输出结果egoninfo = &#123;'name': 'egon', 'age': 18&#125;print(id(info)) # 修改前，查看 idinfo['name'] = 'EGON' # 根据 key 取值，然后修改 valueprint(id(info)) # 修改前，查看 idprint(info)# 输出结果15523023659361552302365936&#123;'name': 'EGON', 'age': 18&#125; 添加一个 key 123456d = &#123;'name': 'egon', 'age': 18&#125;d['sex'] = 'male'print(d)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; key 必须是独一无二的 12345d = &#123;'name': 'egon', 'age': 18, 'age': 19, 'age': 20&#125;print(d)# 输出结果&#123;'name': 'EGON', 'age': 20&#125; # 只认最后一个key key 必须是不可变类型123456info = &#123;'name': 'egon', [1, 2]: 18&#125;print(info[[1, 2]])# 输出结果TypeError: unhashable type: 'list'# 列表是 可变类型，不可hash，不支持key 元组是不可变类型，可 hash，支持 key12345info = &#123;'name': 'egon', (1, 2): 18&#125;print(info[(1, 2)])# 输出结果18 常用操作+内置方法 按 key 存取值：可存值，也可取值123456d = &#123;'x': 1&#125;d['x'] = 2print(d)# 输出结果&#123;'x': 2&#125; 123456789101112d = &#123;'x': 1&#125;print(id(d))print(d)d['x'] = 2print(id(d))print(d)# 输出结果2536822683256&#123;'x': 1&#125;2536822683256&#123;'x': 2&#125; 123456d = &#123;'x': 1&#125;d['y'] = 3print(d)# 输出结果&#123;'x': 1, 'y': 3&#125; 长度len123456789101112info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(len(info))# 输出结果3d = &#123;'name': 'egon', 'age': 18&#125;print(len(d))# 输出结果2 成员运算 in 和 not in 判断的是字典的 key1234567891011121314info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print('x' in info)# 输出结果Trued = &#123;'name': 'egon', 'age': 18&#125;print(18 in d)# 输出结果Falsed = &#123;'name': 'egon', 'age': 18&#125;print('name' in d)# 输出结果True 删除123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;del info['x']print(info)# 输出结果&#123;'y': 2, 'z': 3&#125; 1234567info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.popitem()) # 随机删，将删除的内容以元组格式返回print(info)# 输出结果('z', 3)&#123;'x': 1, 'y': 2&#125; 1234567891011121314151617181920212223242526d = &#123;'name': 'egon', 'age': 18&#125;d.pop('xx') # 如果指定了一个不存在的 key# 输出结果KeyError: 'xx'd.pop('sex', None) # 指定了 None 就不会报错了res = d.pop('sex', None)print(res)# 输出结果None# pop() 删除 key 对应的元素，并返回 value 值res = d.pop('name', None) # 删除存在的 key 时，可以不用写 Noneprint(res)# 输出结果egonprint(d)# 输出结果&#123;'age': 18&#125;info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('x')) # 根据 key 删除，把删除的 value 返回出来print(info)# 输出结果1&#123;'y': 2, 'z': 3&#125; 12345info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx')) # 如果没有这个 key，在没有指定 default 值的情况下，会报错# 输出结果KeyError: 'xxxxx' 123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx', '没有找到key')) # 指定default值的情况下，会输出 default 的值# 输出结果没有找到key&#123;'x': 1, 'y': 2, 'z': 3&#125; 123456info = &#123;'x': 1, 'y': 2, 'z': 3&#125;print(info.pop('xxxxx', None)) # 通常 default值 写None# 输出结果None&#123;'x': 1, 'y': 2, 'z': 3&#125; 键keys()，值values()，键值对items()1234d = &#123;'name': 'egon', 'age': 18&#125;d.keys() # 取 keyd.values() # 取 valued.items() # 取 key value Python2 中字典的格式Python 2.7.15 12345678&gt;&gt;&gt; d = &#123;'name': 'egon', 'age': 18&#125;&gt;&gt;&gt; d.keys()['age', 'name'] # 5个鸡蛋&gt;&gt;&gt; d.values()[18, 'egon']&gt;&gt;&gt; d.items()[('age', 18), ('name', 'egon')]&gt;&gt;&gt; 1234567891011121314&gt;&gt;&gt; msg_dic = &#123;... 'apple': 10,... 'tesla': 100000,... 'mac': 3000,... 'lenovo': 30000,... 'chicken': 10,... &#125;&gt;&gt;&gt; print(msg_dic.keys())['tesla', 'mac', 'lenovo', 'apple', 'chicken'] # 5个鸡蛋&gt;&gt;&gt; print(msg_dic.values())[100000, 3000, 30000, 10, 10]&gt;&gt;&gt; msg_dic.items()[('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('apple', 10), ('chicken', 10)]&gt;&gt;&gt; Python3 做了优化，节省内存Python 3.6.5 123456789101112131415161718192021222324252627d = &#123;'name': 'egon', 'age': 18&#125;for k in d.keys(): print(k)# 输出结果nameaged = &#123;'name': 'egon', 'age': 18&#125;for v in d.values(): print(v)# 输出结果egon18d = &#123;'name': 'egon', 'age': 18&#125;for item in d.items(): # k, v = ('name', 'egon') print(item)# 输出结果('name', 'egon')('age', 18)d = &#123;'name': 'egon', 'age': 18&#125;for k,v in d.items(): # k, v = ('name', 'egon') print(k,v)# 输出结果name egonage 18 python3 做出 python2 中的结果123456789d = &#123;'name': 'egon', 'age': 18&#125;print(list(d.keys()))print(list(d.values()))print(list(d.items()))# 输出结果['name', 'age']['egon', 18][('name', 'egon'), ('age', 18)] 123456789101112131415&gt;&gt;&gt; msg_dic = &#123;... 'apple': 10,... 'tesla': 100000,... 'mac': 3000,... 'lenovo': 30000,... 'chicken': 10,... &#125;&gt;&gt;&gt; msg_dic.keys()dict_keys(['apple', 'tesla', 'mac', 'lenovo', 'chicken']) # 一只有5个鸡蛋的老母鸡&gt;&gt;&gt; res = msg_dic.keys()&gt;&gt;&gt; type(res)&lt;class 'dict_keys'&gt;&gt;&gt;&gt; type(res) is listFalse&gt;&gt;&gt; 123456789101112for k in msg_dic.keys(): # 这种方式比较鸡肋，不加 .keys() 默认是循环 key print(k)等于for k in msg_dic: print(k)# 输出结果appleteslamaclenovochicken 1234567891011121314151617msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;for v in msg_dic.values(): # 只获取value print(v)# 输出结果1010000030003000010 12345678910for x in msg_dic.items(): # 获取 key 和 value print(x)# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]# 输出结果('apple', 10)('tesla', 100000)('mac', 3000)('lenovo', 30000)('chicken', 10) 12345678910# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]for x in msg_dic.items(): print(x[0], x[1])# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 12345678910# [('apple', 10), ('tesla', 100000), ('mac', 3000), ('lenovo', 30000), ('chicken', 10)]# k, v = ('apple', 10)for k, v in msg_dic.items(): print(k, v)# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 循环（循环取值）12345678910111213d = &#123;'name': 'egon', 'age': 18&#125;for k in d: # d 不加 .keys() 默认也是取 key print(k)# 输出结果nameaged = &#123;'name': 'egon', 'age': 18&#125;for k in d: print(k, d[k])# 输出结果name egonage 18 1234567891011121314151617msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;for k in msg_dic: print(k, msg_dic[k])# 输出结果apple 10tesla 100000mac 3000lenovo 30000chicken 10 内置方法1234567891011121314151617181920212223242526msg_dic = &#123; 'apple': 10, 'tesla': 100000, 'mac': 3000, 'lenovo': 30000, 'chicken': 10,&#125;print(msg_dic['applexxxxx']) # key 不存在的情况下，会报错# 输出结果KeyError: 'applexxxxx'if 'applexxxxx' in msg_dic: # 利用 if 判断 key 是否存在 print(msg_dic['applexxxxx'])else: print(None)# 代码比较多print(msg_dic.get('applexxxxx')) # key 不存在的情况下，默认返回None# 输出结果None# 也可以自定义返回值print(msg_dic.get('applexxxxx', 'xxxxx'))# 输出结果xxxxx dict.get() 取值12345678910111213141516d = &#123;'name': 'egon', 'age': 18&#125;d['sex']# 输出结果KeyError: 'sex'# 为了避免这种问题res = d.get('sex', '没有这个key')print(res)# 输出结果没有这个keyd = &#123;'name': 'egon', 'age': 18&#125;res = d.get('name', None) # 通常写Noneprint(res)# 输出结果egon dict.popitem() 随机删除123456d = &#123;'name': 'egon', 'age': 18&#125;res = print(d.popitem()) # 随机删，将删除的内容以元组格式返回print(d, res)# 输出结果&#123;'name': 'egon'&#125; ('age': 18) dict.update() 更新1234567891011d = &#123;'name': 'egon', 'age': 18&#125;d.update(&#123;'x': 1, 'name': 'EGON'&#125;) # 老字典 d 没有的则添加，有的则以新字典为准进行修改print(d)# 输出结果&#123;'name': 'EGON', 'age': 18, 'x': 1&#125;d1 = &#123;'x': 1, 'y': 2&#125;d1.update(&#123;'x': 2, 'z': 3&#125;) # 有原值就更新，没有的就新增print(d1)# 输出结果&#123;'x': 2, 'y': 2, 'z': 3&#125; dict.setdefault() 有则不改，无则增加123456789101112131415161718d = &#123;'name': 'egon', 'age': 18&#125;res = d.setdefault('name': 'EGON'&#125;) # 当key存在时，不修改值，会返回原值print(res)# 输出结果egond = &#123;'name': 'egon', 'age': 18&#125;res = d.setdefault('sex': 'male'&#125;) # 当key不存在时，则新增一个元素，会返回一个新值print(res)# 输出结果maled = &#123;'name': 'egon', 'age': 18&#125;d.setdefault('name': 'EGON'&#125;) # 当key存在时，不修改值d.setdefault('sex': 'male'&#125;) # 当key不存在时，则新增一个元素print(d)# 输出结果&#123;'name': 'egon', 'age': 18, 'sex': 'male'&#125; 12345678910&#123;&#125;.setdefault() # 有则不改，无则增加d = &#123;'x': 1, 'y': 2&#125;d.setdefault('x', 1000) # 当key存在时 则不改变 key 对应的值，返回原值res = d.setdefault('x', 1000)print(d)print(res)# 输出结果&#123;'x': 1, 'y': 2&#125;1 123456789d = &#123;'x': 1, 'y': 2&#125;d.setdefault('z', 1000) # key不存在 则增加一个 key:value，返回新增的valueres = d.setdefault('z', 1000)print(d)print(res)# 输出结果&#123;'x': 1, 'y': 2, 'z': 1000&#125;1000 1234567891011121314151617181920212223242526272829303132333435# 统计单词个数统计 s = 'hello alex alex say hello sb sb' 中每个单词的个数结果如：&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;s = 'hello alex alex say hello sb sb'words = s.split()print(words)# 输出结果['hello', 'alex', 'alex', 'say', 'hello', 'sb', 'sb']d = &#123;&#125;for word in words: if word not in d: d[word] = 1 else: d[word] += 1# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;d = &#123;&#125;words = s.split()for word in words: # print(word, words.count(word)) d[word] = words.count(word)print(d)# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125;d = &#123;&#125;words = s.split()for word in words: d.setdefault(word, words.count(word))print(d)# 输出结果&#123;'hello': 2, 'alex': 2, 'say': 1, 'sb': 2&#125; dict.fromkeys 用于字典的初始化，快速造出字典123456789101112131415161718192021222324252627282930&#123;&#125;.fromkeys(序列类型, 值)序列类型：有索引的类型（字符串，列表，元组）# 用于字典的初始化# items = ['name', 'age', 'sex']items = ('name', 'age', 'sex')dic = d.fromkeys(items, None)print(dic)# 输出结果&#123;'name': None, 'age': None, 'sex': None&#125;d = &#123;&#125;.fromkeys(['name', 'age', 'sex'], '初始值')print(d)# 输出结果&#123;'name': '初始值', 'age': '初始值', 'sex': '初始值'&#125;info = &#123;&#125;.fromkeys('hello', None)print(info)# 输出结果&#123;'h': None, 'e': None, 'l', None, 'o', None&#125;# 字典key 不能重复，所以这里只有一个 l# 实现 不用 formkeys，从以下元组中取出没一个元素，造一个字典items = ('name', 'age', 'sex')dic = &#123;&#125;for item in items: dic[item] = Noneprint(dic)# 输出结果&#123;'name': None, 'age': None, 'sex': None&#125; dict 字典类型总结 能存多个值，没有类型限制 无序（能够按索引取值的属于有序） 可变类型可变：值变，id不变。可变==不可hash 参考文档http://www.cnblogs.com/linhaifeng/articles/7133357.html#_label6]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python字典类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS禁止密码登录]]></title>
    <url>%2F2018%2F07%2F03%2FCentOS%E7%A6%81%E6%AD%A2%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[CentOS 禁止密码登录 允许 sshkey 密钥登录，禁止密码登录 编辑 SSH 配置文件12345678910111213141516vim /etc/ssh/sshd_config# 找到以下配置项#RSAAuthentication yes#PubkeyAuthentication yes#AuthorizedKeysFile .ssh/authorized_keys# 去调上面 3 行前面的 (#)注释# 找到下面 1 行PasswordAuthentication yesPermitRootLogin yes# 修改为PasswordAuthentication no # 禁止密码登录PermitRootLogin no # 禁止 root 登录PermitRootLogin without-password # 禁止 root 密码登录 重启 SSH 服务12systemctl reload sshdsystemctl -l status sshd 参考文档https://blog.csdn.net/u013372487/article/details/71307323]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>CentOS禁止密码登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper可视化界面zkui搭建与配置]]></title>
    <url>%2F2018%2F06%2F28%2FZookeeper%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2zkui%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Zookeeper可视化界面zkui搭建与配置一个允许在 Zookeeper 上进行 CRUD 操作的 UI 控制面板。 下载地址https://github.com/DeemOpen/zkui 运行环境jdk 7 初始化环境 zkui 是基于 java 语言开发，首先就要我们安装 jdk 环境。因为 zkui 需要我们手工进行编译、构建和打包，所以还需要安装 maven 环境。 安装 jdk1.712tar -zxvf jdk-7u80-linux-x64.tar.gz -C /data/chown -R root:root /data/jdk1.7.0_80/ 添加环境变量12345678910cat &gt;&gt; /etc/profile.d/jdk.sh &lt;&lt; “EOF”#!/bin/bashexport JAVA_HOME=/data/jdk1.7.0_80export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binEOFsource /etc/profilejava –version 生成 zkui 的 jar 包 zkui 的源码包，我们可以在 github 上进行下载https://github.com/DeemOpen/zkui.git1234567cd /data/tools/git clone https://github.com/DeemOpen/zkui.gitcd zkui/ll -h# 使用 mvn 命令进行编译构建打包mvn clean install 可以看到 maven 打包后生成了 zkui-2.0-SNAPSHOT.jar 和 zkui-2.0-SNAPSHOT-jar-with-dependencies.jar 两个文件，其中 zkui-2.0-SNAPSHOT-jar-with-dependencies.jar 是我们需要的 jar 文件。 启动 zkui zkui 运行的 jar 文件生成后，我们就可以直接运行该文件了。在运行该文件之前，我们还需要修改 zkui 的配置文件 config.cfg。config.cfg 文件中配置了，zkui 需要连接的 zookeeper 集群的 IP 地址和端口，访问 ui 的用户名和密码，以及 zkui 监听的端口号 123456789cd zkui/vim config.cfgserverPort=9090 # Web服务端口zkServer=10.1.1.127:2181,10.1.1.128:2181,10.1.1.129:2181 # 一个或多个 Zookeeper 节点地址ldapAuth=falseldapDomain=mycompany,mydomainldapUrl=ldap://&lt;ldap_host&gt;:&lt;ldap_port&gt;/dc=mycom,dc=comldapRoleSet=&#123;"users": [&#123; "username":"domain\\user1" , "role": "ADMIN" &#125;]&#125;userSet = &#123;"users": [&#123; "username":"admin" , "password":"manager","role": "ADMIN" &#125;,&#123; "username":"appconfig" , "password":"appconfig","role": "USER" &#125;]&#125; 默认用户信息 用户名：Admin（Admin权限，支持CRUD操作）密码：manager用户名：appconfig（Readonly权限，支持读取操作）密码：appconfig LDAP 配置 如果你想使用 LDAP 身份验证，则提供 LDAP url。这将优先于 roleSet property 文件认证。ldapUrl=ldap://&lt;ldap_host&gt;:&lt;ldap_port&gt;/dc=mycom,dc=com如果不提供此功能，则将使用默认 roleSet 文件认证。 12nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &gt; /data/app/zkui/logs/stdout.log 2&gt;&amp;1 &amp;netstat -tunlp | grep 9090 访问 http://x.x.x.x:9090 参考文档https://www.ilanni.com/?p=13646]]></content>
      <categories>
        <category>Zookeeper笔记</category>
      </categories>
      <tags>
        <tag>Zookeeper可视化界面zkui搭建与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ集群安装与配置]]></title>
    <url>%2F2018%2F06%2F27%2FActiveMQ%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ActiveMQ集群安装与配置ActiveMQ 集群是依赖于 ZooKeeper 集群而存在的在此我们把 ZooKeeper 集群和 ActiveMQ 集群安装在同样三台机器上。 ActiveMQ 集群原理 ActiveMQ 集群原理，使用 ZooKeeper 集群注册所有的 ActiveMQ Broker。只有其中的一个 Broker 可以对外提供服务，被视为 master。而其他的 Broker 处于待机状态，被视为 slave。而此时 slave 只是做数据的主从同步。 如果 master 因故障而不能提供服务，ZooKeeper 集群会从 slave 中选举出一个Broker 充当 master。slave 连接 master 并同步它们的存储状态，slave 不接受客户端连接。所有的存储操作都将被复制到连接至 master 的 slave 上。 如果 master 宕机了，得到了最新更新的 slave 会成为 master。而故障节点在恢复后会重新加入到集群中并连接 master 进入 slave 模式。 需要同步的消息操作都将等待存储状态被复制到其他节点的操作完成后才能完成。 所以，如果你配置了 replicas=3，那么假定大小是 (3/2)+1=2。master 将会存储并更新然后等待 (2-1)=1 个 slave 存储和更新完成，才汇报 success。 至于为什么是 2-1，熟悉 ZooKeeper 集群的应该知道，有一个 node 要作为观擦者存在。当一个新的 master 被选中，你需要至少保障一个假定 node 在线以能够找到拥有最新状态的 node。这个 node 可以成为新的 Master。因此，推荐运行至少 3 个 replica nodes，以防一个 node 失败了，服务中断。（原理与 Zookeeper 集群的高可用实现方式类似）。 初始化环境 至少需要三台机器，这三台机器都已经安装 ActiveMQ 服务，ZooKeeper 集群也已经配置完毕。这三台机器的 IP 分别为 10.1.1.127，10.1.1.128，10.1.1.129 查看 ZooKeeper 集群的情况1/data/app/zookeeper/bin/zkServer.sh status 环境初始化完毕后，开始配置 ActiveMQ 集群。 配置 ActiveMQ 集群 ActiveMQ 集群的配置比较简单，我们只需要修改 ActiveMQ 的配置文件 activemq.xml 中部分内容即可。ActiveMQ 根目录下的 conf/activemq.xml 文件，原来默认内容如下：1234vim conf/activemq.xml +81&lt;persistenceAdapter&gt;&lt;kahaDB directory=”$&#123;activemq.data&#125;/kahadb”/&gt;&lt;/persistenceAdapter&gt; 修改后的内容如下：12345678910111213vim conf/activemq.xml +81&lt;persistenceAdapter&gt;&lt;replicatedLevelDBdirectory=”$&#123;activemq.data&#125;/leveldb”replicas=”3″bind=”tcp://0.0.0.0:0″zkAddress=”10.1.1.127:2181,10.1.1.128:2181,10.1.1.129:2181″zkSessionTimeout=”4s”hostname=”10.1.1.127″sync=”local_disk”zkPath=”/activemq/leveldb-stores”/&gt;&lt;/persistenceAdapter&gt; 配置的含义解释如下：directory：表示 ActiveMQ 集群消息持久化保存到服务器上的路径，注意该路径一定要先创建好。replicas：表示 ActiveMQ 集群的节点个数。bind：表示当这个节点成为 master 后，绑定的机器的地址与端口。此处 0.0.0.0:0 表示绑定到本机所有可用 IP，而端口是随机的。zkAddress：表示 ZooKeeper 的 IP 和 port。如果是 ZooKeeper 集群的话，则用逗号隔开。zkSessionTimeout：表示 ActiveMQ 与 ZooKeeper 集群连接的会话超时时间。hostname：表示本机的 IP 地址。服务器根据不同的 IP 地址做出改变，其他配置相同。sync：在消息被消费完成前，同步信息所存贮的策略。如果有多种策略用逗号隔开，ActiveMQ 会选择较强的策略。而如果有 local_mem，local_disk 这两种策略的话，那么 ActiveMQ 则优先选择 local_disk 策略，存储在本地硬盘。zkPath：表示 ActiveMQ 在 ZooKeeper 集群上创建的 znode 节点的路径，也即是ZooKeeper 选举信息交换的存贮路径。注意：这 3 个 ActiveMQ 节点中的 brokerName 配置必须相同，否则不能加入集群。 启动 ActiveMQ 集群 ActiveMQ 集群配置完毕后，我们现在来启动 ActiveMQ 集群。但是在正式启动 ActiveMQ 集群之前，一定要先启动 ZooKeeper集群。 要启动 ActiveMQ 集群，我们只需要启动这 3 台服务器的 ActiveMQ 服务即可。如下：12/data/app/activemq/bin/activemq startps -ef | grep mq ActiveMQ 集群启动完毕，根据 ZooKeeper 的策略，会从这三台 ActiveMQ 服务器选一台作为 master 对外提供服务，其他两台作为 slave 等待运行，而 slave 只是做数据上的主从同步。 所以，ActiveMQ 集群后，访问http://10.1.1.127:8161/admin/http://10.1.1.128:8161/admin/http://10.1.1.129:8161/admin/只会有一个成功 那么现在在 ActiveMQ 集群中，如何查看哪一台服务器是 master 节点呢？我们可以通过查看这三台服务器哪一台服务器监听 8161 端口，来判断哪台服务器是 master 节点。 现在在切换到服务器上查看监听的端口，如下：1netstat -tunlp | grep 8161 可以很明显的看出，目前只有 10.1.1.127 这台服务器监听 8161 端口的。那就说明目前10.1.1.127 是 master 节点。其他两个节点是 slave 节点，处于待机状态，没有监听 8161 端口。 现在我们再来看访问 10.1.1.127 服务器 ActiveMQ 管理控制台看看，如下：http://10.1.1.127:8161/admin到此说明 ActiveMQ 集群已经部署完毕。 验证 ActiveMQ 集群高可用 要验证 ActiveMQ 集群的高可用，我们只需要关闭能访问http://x.x.x.x:8161/admin/ 的 ActiveMQ 服务，然后访问其他两个。 如果其中有一个能访问，那就说明 ActiveMQ+ZooKeeper 集群高可用已经配置成功。通过第四章节，我们知道目前 master 节点是 10.1.1.127 这台服务器。现在我们来关闭10.1.1.127 这台服务器的 ActiveMQ 服务，看看 ActiveMQ 集群，是否能正常访问。如下： 12ps -ef | grep mqkill -9 3889 我们已经把 10.1.1.127 这台服务器的 ActiveMQ 服务已经关闭了。现在我们再来看看目前哪台服务器是 master 节，也即是查看哪台服务器的 8161 端口对外提供服务器。如下：12netstat -tunlp | rep 8161ps -ef | rep mq 可以很明显的看出目前 10.1.1.128 这台服务器是 master 节点。现在我再来通过管理控制台访问10.1.1.128 的 8161 端口看看。如下：http://10.1.1.128:8161/admin/ 我们可以很明显的看出 10.1.1.127 这台服务器的 ActiveMQ 服务停止后，并没有影响 ActiveMQ 集群的正常运行。这也就说明了 ActiveMQ 集群是正常工作的。到此，有关 ActiveMQ 集群的搭建与配置已经全部完毕。 参考文档https://www.ilanni.com/?p=13569]]></content>
      <categories>
        <category>ActiveMQ笔记</category>
      </categories>
      <tags>
        <tag>ActiveMQ集群安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ安装与配置]]></title>
    <url>%2F2018%2F06%2F27%2FActiveMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ActiveMQ安装与配置 操作系统 CentOS7建议 ActiveMQ 集群 和 Zookeeper 集群部署在同一台服务器上，否则随着时间的增加，ActiveMQ 集群容易出现假死的情况。 JMS 支持的消息传递模型 JMS 支持两种消息传递模型：队列（Queue）和 主题（Topic）。 点对点传递模型 点对点（point-to-point，简称 PTP）Queue 消息传递模型。 通过该消息传递模型，一个应用程序（即消息生产者）可以向另外一个应用程序（即消息消费者）发送消息。 在此传递模型中，消息目的地类型是队列（即 Destination 接口实现类实例由 Session 接口实现类实例通过调用其 createQueue 方法并传入队列名称而创建）。 消息首先被传送至消息服务器端特定的队列中，然后从此对列中将消息传送至对此队列进行监听的某个消费者。同一个队列可以关联多个消息生产者和消息消费者，但一条消息仅能传递给一个消息消费者。 如果多个消息消费者正在监听队列上的消息，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。 如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。这种消息传递模型是传统意义上的懒模型或轮询模型。 在此模型中，消息不是自动推动给消息消费者的，而是要由消息消费者从队列中请求获得。 发布/订阅传递模型 发布/订阅（publish/subscribe，简称 pub/sub）Topic 消息传递模型。 通过该消息传递模型，应用程序能够将一条消息发送给多个消息消费者。在此传送模型中，消息目的地类型是主题（即 Destination 接口实现类实例由 Session 接口实现类实例通过调用其 createTopic 方法并传入主题名称而创建）。 消息首先由消息生产者发布至消息服务器中特定的主题中，然后由消息服务器将消息传送至所有已订阅此主题的消费者。 主题目标也支持长期订阅。长期订阅表示消费者已注册了主题目标，但在消息到达目标时该消费者可以处于非活动状态。 当消费者再次处于活动状态时，将会接收该消息。如果消费者均没有注册某个主题目标，该主题只保留注册了长期订阅的非活动消费者的消息。 与 PTP 消息传递模型不同，pub/sub 消息传递模型允许多个主题订阅者接收同一条消息。JMS 一直保留消息，直至所有主题订阅者都接收到消息为止。 pub/sub 消息传递模型基本上是一个推模型。在该模型中，消息会自动广播，消息消费者无须通过主动请求或轮询主题的方法来获得新的消息。 具体区别对比如下 类型 Topic Queue 概要 Publish Subscribe messaging 发布订阅消息 Point-to-Point 点对点 有无状态 Topic 数据默认不落地，是无状态的。 Queue 数据默认会在 mq 服务器上以文件形式保存，比如Active MQ 一般保存在 $AMQ_HOME/data/kr-store/data 下面。也可以配置成 DB 存储。 完整性保障 并不保证 publisher 发布的每条数据，Subscriber 都能接受到。 Queue 保证每条数据都能被 receiver 接收。 消息是否会丢失 一般来说 publisher 发布消息到某一个 topic 时，只有正在监听该 topic 地址的 sub 能够接收到消息；如果没有 sub 在监听，该 topic 就丢失了。 Sender 发送消息到目标 Queue，receiver 可以异步接收这个 Queue 上的消息。Queue 上的消息如果暂时没有 receiver 来取，也不会丢失。 消息发布接收策略 一对多的消息发布接收策略，监听同一个 topic 地址的多个 sub 都能收到 publisher 发送的消息。Sub 接收完通知 mq 服务器。 一对一的消息发布接收策略，一个 sender 发送的消息，只能有一个 receiver 接收。receiver 接收完后，通知 mq 服务器已接收，mq 服务器对 queue 里的消息采取删除或其他操作。 初始化环境在此我们安装的是 ActiveMQ 5.14.5，ActiveMQ 5.14.5 使用的是 jdk1.7。ActiveMQ 5.15.0 使用的是 jdk1.8。 安装 jdk1.71234cd /data/tools/wget -c http://mirrors.linuxeye.com/jdk/jdk-7u80-linux-x64.tar.gztar -zxvf jdk-7u80-linux-x64.tar.gz -C /data/chown -R root:root /data/jdk1.7.0_80 添加环境变量123456vim /etc/profileexport JAVA_HOME=/data/jdk1.7.0_80export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/binsource /etc/profilejava -version 关闭 防火墙 和 selinux，同步服务器时间123456ntpdate -u cn.ntp.org.cnsed -i ‘/SELINUX/s/enforcing/disabled/’ /etc/selinux/configsetenforce 0systemctl disable firewalld.servicesystemctl stop firewalld.serviceshutdown -r now 安装 ActiveMQ ActiveMQ 官网http://activemq.apache.org/ 下载 ActiveMQhttp://activemq.apache.org/download.htmlhttp://archive.apache.org/dist/activemq/ 下载 ActiveMQ5.14.51234mkdir -pv /data/app/activemqcd /data/tools/wget -c http://mirrors.hust.edu.cn/apache/activemq/5.14.5/apache-activemq-5.14.5-bin.tar.gztar -zxvf apache-activemq-5.14.5-bin.tar.gz -C /data/app/activemq –strip-components 1 查看 ActiveMQ 目录结构1ll -h 文件名/目录名 详解 activemq-all-5.14.5.jar ActiveMQ 所有 jar bin ActiveMQ 启动命令的二进制执行文件及一些命令脚本 conf ActiveMQ 配置目录，包含最基本的 ActiveMQ 配置文件 data ActiveMQ 数据目录，默认为空。包含 ActiveMQ 的进程文件、数据文件、日志文件。该目录也是 ActiveMQ 消息持久化的目录 docs 用户使用帮助相关文件 examples 操作 ActiveMQ 相关实例 lib ActiveMQ 需要的类库 webapps ActiveMQ 控制台应用目录 webapps-demo ActiveMQ 使用实例目录 LICENSE ActiveMQ 所有包使用的 Apache 开源消息协议 NOTICE ActiveMQ 版权信息 README 用户使用引导文件，包括一些文档及 URL 启动 ActiveMQ12/data/app/activemq/bin/activemq starttail -f /data/app/activemq/data/activemq.log ActiveMQ 启动方式 普通启动1/data/app/activemq/bin/activemq start 后台启动并指定日志文件1nohup /data/app/activemq/bin/activemq start &gt; /data/app/activemq/logs/smlog 2&gt;&amp;1 &amp; ActiveMQ 管理控制台 ActiveMQ 默认的管理后台端口是 8161，默认管理用户名和密码均是 admin。ActiveMQ 默认的管理后台端口，可以在 ActiveMQ 的配置文件 jetty.xml 中查看到12vim /data/app/activemq/conf/jetty.xml +110&lt;property name=”port” value=”8161″/&gt; ActiveMQ 默认管理用户名和密码均是 admin，如果要修改默认用户名和密码的话，可以通过修改 jetty-realm.properties 文件来达到目的123vim /data/app/activemq/conf/jetty-realm.propertiesadmin: password@123, adminuser: user@123, user 注意：ActiveMQ 用户名和密码的格式是1username: password, rolename 登陆管理控制台http://x.x.x.x:8161/admin 管理控制台介绍 在 ActiveMQ 的管理控制台，关注比较多的是 Queues队列 和 Topics主题。 Queues队列 选项 字段 详解 Number Of Pending Messages 表示还有多少条消息没有被消费，实际上是表示消息的积压程度。 Number Of Consumers 表示在该队列上还有多少消费者在等待接受消息。其实就是消费者的数量。 Messages Enqueued 表示生产了多少条消息。 Messages Dequeued 表示消费了多少条消息。 Topics主题 选项 字段 详解 Number Of Consumers 表示在该队列上还有多少消费者在等待接受消息。 Messages Enqueued 表示生产了多少条消息。 Messages Dequeued 表示消费了多少条消息。 参考文档https://www.ilanni.com/?p=13543]]></content>
      <categories>
        <category>ActiveMQ笔记</category>
      </categories>
      <tags>
        <tag>ActiveMQ安装与配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os模块]]></title>
    <url>%2F2018%2F06%2F21%2Fos%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os 模块 os 模块是与操作系统交互的一个接口 模块方法 注释 os.getcwd() 获取当前工作目录，即当前 python 脚本工作的目录路径 os.chdir(&quot;dirname&quot;) 改变当前脚本工作目录；相当于 shell 下 cd os.curdir 返回当前目录: (&#39;.&#39;) os.pardir 获取当前目录的父目录字符串名：(&#39;..&#39;) os.makedirs(&#39;dirname1/dirname2&#39;) 可生成多层递归目录 os.removedirs(&#39;dirname1&#39;) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(&#39;dirname&#39;) 生成单级目录；相当于 shell 中 mkdir dirname os.rmdir(&#39;dirname&#39;) 删除单级空目录，若目录不为空则无法删除，报错；相当于 shell 中 rmdir dirname os.listdir(&#39;dirname&#39;) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录 os.stat(&#39;path/filename&#39;) 获取文件/目录信息 os.sep 输出操作系统特定的路径分隔符，Windows下为&quot;\\&quot;，Linux下为&quot;/&quot; os.linesep 输出当前平台使用的行终止符，Windows下为&quot;\t\n&quot;，Linux下为&quot;\n&quot; os.pathsep 输出用于分割文件路径的字符串，Windows下为;，Linux下为: os.name 输出字符串指示当前使用平台。Windows-&gt;&#39;nt&#39;，Linux-&gt;&#39;posix&#39; os.system(&quot;bash command&quot;) 运行shell命令，直接显示 os.environ 获取系统环境变量 os.path.abspath(path) 返回 path 规范化的绝对路径 os.path.split(path) 将 path 分割成目录和文件名二元组返回 os.path.dirname(path) 返回 path 的目录。其实就是 os.path.split(path) 的第一个元素 os.path.basename(path) 返回 path 最后的文件名。如何 path 以 / 或 \ 结尾，那么就会返回空值。即 os.path.split(path) 的第二个元素 os.path.exists(path) 如果 path 存在，返回 True；如果 path 不存在，返回 False os.path.isabs(path) 如果 path 是绝对路径，返回 True os.path.isfile(path) 如果 path 是一个存在的文件，返回 True。否则返回 False os.path.isdir(path) 如果 path 是一个存在的目录，则返回 True。否则返回 False os.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回 path 所指向的文件或者目录的最后存取时间 os.path.getmtime(path) 返回 path 所指向的文件或者目录的最后修改时间 os.path.getsize(path) 返回 path 的大小 列出指定目录下的所有文件和子目录 包括隐藏文件，并以列表方式打印 12345import osprint(os.listdir(r'.'))# 输出结果['01 时间模块.py', '02 random模块.py', '03 os模块.py', '今日内容.txt'] 获取 文件/目录 信息12345678910import osprint(os.stat('今日内容.txt'))# 输出结果os.stat_result(st_mode=33206, st_ino=4503599627409980, st_dev=239211959, st_nlink=1, st_uid=0, st_gid=0, st_size=280, st_atime=1526694304, st_mtime=1526694304, st_ctime=1526694102)# 获取文件大小，以 bytes 为单位print(os.stat('今日内容.txt').st_size)# 输出结果280 获取 文件 大小信息12345import osprint(os.path.getsize(r'E:\PycharmProjects\SH_s1\day07\今日内容.txt'))# 输出结果280 os.system(&quot;bash command&quot;) 方法 运行shell命令，直接显示 123456789import osos.system('tasklist') # 输出 Windows 下当前所有进程列表# os.system() 只是单纯的执行命令，并不能把命令执行后的结果做进一步的处理res = os.system('tasklist')print('res----&gt;', res) # res变量只是命令的执行成功与否的执行状态# 输出结果res----&gt; 0 os.environ 方法 获取系统环境变量 123456789全局的用于在程序任何地方都需要用到它的结果的时候import osos.environ['login'] = 'yes'print(os.environ['login'])# 输出结果yes os.path.split(path) 方法 将 path 分割成 目录 和 文件名 二元组返回 12345678910print(os.path.split('/a/b/c/d.txt'))# 输出结果('/a/b/c', 'd.txt')print(os.path.split('/a/b/c/d.txt')[0])print(os.path.split('/a/b/c/d.txt')[1])# 输出结果/a/b/cd.txt os.path.dirname(path) 方法 返回 path 的 目录其实就是 os.path.split(path) 的第一个元素 123print(os.path.dirname('a/b/c/d.txt'))# 输出结果a/b/c os.path.basename(path) 方法 返回 path 最后的 文件名如何 path 以 / 或 \ 结尾，那么就会返回空值即 os.path.split(path) 的第二个元素 123print(os.path.basename('a/b/c/d.txt'))# 输出结果d.txt os.path.join(path1[, path2[, …]]) 方法 用于拼接路径将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 123print(os.path.join('a', 'b', 'c', 'd.txt'))# 输出结果a\b\c\d.txt 123print(os.path.join('a', 'b', 'D:\\', 'c', 'd.txt'))# 输出结果D:\c\d.txt 123print(os.path.join('a', 'b', 'd', 'c', '/', 'd.txt'))# 输出结果/d.txt os.path.normcase(path) 方法 只用于 Windows 系统，规范 Windows 目录在 Windows 平台上会将路径中所有字符转换为小写，将路径中的左斜杠转换为 Windows 中的右斜杠在 Linux 和 Mac 平台上，该函数会原样返回 path 123print(os.path.normcase('c:/windOws\\system32\\'))# 输出结果c:\windows\system32\ os.path.normpath(path) 方法 用于规范路径如 (..) 点点 (/) 斜杠 123456789101112print(os.path.normpath('c:\\windOws/a/b/../system32\\'))# 输出结果c:\windOws\a\system32print(os.path.normpath('c://windows\\System32\\../Temp/'))# 输出结果c:\windows\Tempa = '/Users/jieli/test1/\\\a1/\\\\aa.py/../..'print(os.path.normpath(a))# 输出结果/Users/jieli/test1 os 路径处理 常用路径处理方法 123os.path.dirname(os.path.dirname(os.path.abspath(__file__)))os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) OpenStack 中获取路径方式 1234567891011121314151617181920OpenStack 获取路径方式res = os.path.join( os.path.abspath(__file__), '..', '..')print(res)print(os.path.normpath(res))# 输出结果E:\PycharmProjects\SH_s1\day07\03 os模块.py\..\..E:\PycharmProjects\SH_s1# 合并一下print(os.path.normpath( os.path.join( os.path.abspath(__file__), '..', '..' ))) 12345678910import osimport os,syspossible_topdir = os.path.normpath(os.path.join( os.path.abspath(__file__), os.pardir, # 上一级 os.pardir, os.pardir))sys.path.insert(0, possible_topdir) 参考文档http://www.cnblogs.com/linhaifeng/articles/6384466.html#_label3]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>os模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调整Linux的网络栈Buffer_Size来提升网络性能]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%B0%83%E6%95%B4Linux%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A0%88Buffer_Size%E6%9D%A5%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[调整 Linux 的网络栈 Buffer Size 来提升网络性能 有两台位于不同数据中心的服务器，都用来处理很多并行的大文件传输。但是处理大文件，网络性能非常差。并且涉及到一个大文件，会导致性能降级。怎样通过调整 Linux下面的 TCP 来解决这个问题？ 默认，Linux 的 stack 是没有为广域网之间的大文件高速传输而配置的，这样做是为了节约内存资源。为了使连接的系统服务之间能有更加高速的网络处理更多的网络包，你可以很容易的通过增加网络 buffer size 来调整 Linux 网络 stack。 默认的 Linux buffer size 的最大值是非常小的，tcp 的内存是基于系统的内存自动计算的，你能通过键入以下命令找到实际的值 1cat /proc/sys/net/ipv4/tcp_mem 默认的和最大的接收数据包内存大小 12cat /proc/sys/net/core/rmem_defaultcat /proc/sys/net/core/rmem_max 默认的和最大的发送数据包内存的大小 12cat /proc/sys/net/core/wmem_defaultcat /proc/sys/net/core/wmem_max 最大的内存 buffers 的选项 1cat /proc/sys/net/core/optmem_max 调整值 为所有的协议队列设置操作系统层面的最大的发送 buffer size(wmem) 和 接收 buffer size (rmem)为 12MB。换句话说，设置内存数量，分配给每一个为了传送文件而打开或者是创建的 tcp socket。 警告！在大多数的 Linux 中 rmem_max 和 wmem_max 被分配的值为 128k，在一个低延迟的网络环境中，或者是 apps 比如 DNS、Web Server，这或许是足够的。尽管如此，如果延迟太大，默认的值可能就太小了，所以请记录以下在你的服务器上用来提高内存使用方法的设置。 12echo 'net.core.wmem_max=12582912' &gt;&gt; /etc/sysctl.confecho 'net.core.rmem_max=12582912' &gt;&gt; /etc/sysctl.conf 还需要设置 minimum size, initial size, and maximum size in bytes 12echo 'net.ipv4.tcp_rmem= 10240 87380 12582912' &gt;&gt; /etc/sysctl.confecho 'net.ipv4.tcp_wmem= 10240 87380 12582912' &gt;&gt; /etc/sysctl.conf 打开 window scaling，这是一个用来扩展传输窗口的选项 1echo 'net.ipv4.tcp_window_scaling = 1' &gt;&gt; /etc/sysctl.conf 确保定义在 RFC1323 中的 timestamps 打开 1echo 'net.ipv4.tcp_timestamps = 1' &gt;&gt; /etc/sysctl.conf 确保 select acknowledgments 1echo 'net.ipv4.tcp_sack = 1' &gt;&gt; /etc/sysctl.conf 这个 “select acknowledgments” 不知道该如何翻译，翻译为“选择确认？” 当连接关闭的时候，TCP 默认缓存了很多连接指标在 route cache 中，以至于在不久的将来，连接建立的时候，可以用这些值来设置初始化条件。通常，这提升了整体的性能，但是，有时候会引起性能下降， 如果设置的话，TCP 在关闭的时候不缓存这些指标。 1echo 'net.ipv4.tcp_no_metrics_save = 1' &gt;&gt; /etc/sysctl.conf 当 interface 接收到的数据包数量比内核处理速度的快的时候， 设置 input 队列最大的 packets 数量值。 1echo 'net.core.netdev_max_backlog = 5000' &gt;&gt; /etc/sysctl.conf 现在重载这些改变，使其生效 1sysctl -p 使用 tcpdump 命令查看 通过 eth0 数据包流量的变化 1tcpdump -ni eth0 参考文档https://segmentfault.com/a/1190000000473365 推荐阅读 请参考内核文档/networking/ip-sysctl.txt获取更加多的信息 请查看 sysctl 的 man 手册]]></content>
      <categories>
        <category>Linux内核优化笔记</category>
      </categories>
      <tags>
        <tag>调整Linux的网络栈Buffer_Size来提升网络性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat中Connector常用配置]]></title>
    <url>%2F2018%2F06%2F15%2FTomcat%E4%B8%ADConnector%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Tomcat 中 Connector 常用配置 模式 描述 BIO 阻塞式 I/O，采用传统的 java I/O 进行操作，该模式下每个请求都会创建一个线程，适用于并发量小的场景 NIO 同步非阻塞，比传统 BIO 能更好的支持大并发，Tomcat 8.0 后默认采用该模式 APR Tomcat 以JNI形式调用http服务器的核心动态链接库来处理文件读取或网络传输操作，需要编译安装 APR 库 AIO 异步非阻塞，Tomcat 8.0 后支持 配置方法：在 tomcat/conf/ 下 server.xml 12345`&lt;Connector port="8080" protocol="HTTP/1.1"/&gt;`BIO: protocol="org.apache.coyote.http11.Http11Protocol"NIO: protocol="org.apache.coyote.http11.Http11NioProtocol"AIO: protocol="org.apache.coyote.http11.Http11Nio2Protocol"APR: protocol="org.apache.coyote.http11.Http11AprProtocol" BIO（blocking I/O） 阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作（即 java.io 包及其子包）。默认的模式，性能最差，没有经过任何优化处理和支持。 NIO（non-blocking I/O） Java SE 1.4 及后续版本提供的一种新的 I/O 操作方式（即 java.nio 包及其子包）。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API。拥有比传统 I/O 操作（BIO）更好的并发运行性能。要让 Tomcat 以 NIO 模式来运行，修改配置文件：tomcat/conf/server.xml 修改以下内容123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 修改 protocol 的值为 org.apache.coyote.http11.Http11NioProtocol1234&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; 重启 Tomcat 后生效 在 Tomcat 6.0 之后，提供了 NIO 的方式，可以有效的提升性能，特别是在大量长连接/数据上传+下载等 Web 应用中此时 portocal=”org.apache.coyote.http11.Http11NioProtocol”Tomcat 支持：BIO，NIO，NIO2，APR 四种 I/O 模式，Tomcat 8.5 之前 默认为 BIO Tomcat 8.5 and 9.0 have completely dropped the BIO connector.Tomcat 8.5 和 9.0 完全删除了 BIO 连接器默认 NIO 模式 对于互联网应用，我们应该在 NIO、NIO2 之间做选择，因为它能够有效的提升性能（主要是并发能力）其中 NIO2 即为 AIO，需要 JDK 1.7+、Linux 2.6+ 才能支持。BIO：JDK 1.5+，tomcat 5.x+NIO：JDK 1.6+，tomcat 6.x+NIO2：JDK 1.7+，tomcat 7.x+为了保守起见，我们暂且基于 NIO 模式 查看 Tomcat Connector 运行模式方法一：在 http://x.x.x.x:8080/manager/status 中查看服务器状态 方法二：根据 Tomcat 启动日志信息判断BIO12INFO: Initializing ProtocolHandler ["http-bio-8080"]Aug 04, 2015 10:20:35 PM org.apache.coyote.AbstractProtocol init NIO12INFO: Initializing ProtocolHandler ["http-nio-8080"]Aug 04, 2015 10:27:58 PM org.apache.coyote.AbstractProtocol init APR12INFO: Initializing ProtocolHandler ["http-apr-8080"]Aug 04, 2015 10:33:45 PM org.apache.coyote.AbstractProtocol init 整合Tomcat apr 设置环境变量方法一：在 tomcat/bin/catalina.sh 中增加1行在 echo “Using CATALINA_BASE: $CATALINA_BASE” 的上一行添加CATALINA_OPTS=”-Djava.library.path=/data/apr/lib” 方法二：在 /etc/profile 中加入1export CATALINA_OPTS=-Djava.library.path=/usr/local/apr/lib 使配置生效1source /etc/profile 修改配置文件1234567vim tomcat/conf/server.xml &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;# 修改 `protocol` 的值为 `org.apache.coyote.http11.Http11NioProtocol`&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443" /&gt; 重启 Tomcat，启动日志出现以下内容证明此时以 APR 模式启动 参考文档：https://blog.csdn.net/fd2025/article/details/80007435]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat中Connector常用配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回到页首按钮显示百分比]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%9B%9E%E5%88%B0%E9%A1%B5%E9%A6%96%E6%8C%89%E9%92%AE%E6%98%BE%E7%A4%BA%E7%99%BE%E5%88%86%E6%AF%94%2F</url>
    <content type="text"><![CDATA[回到页首按钮显示百分比 Back-to-top 按钮显示百分比 编辑配置文件 Next主题配置文件 /hexo/themes/next/_config.yml 12# Scroll percent label in b2t button. scrollpercent: false 将 scrollpercen: 的值改为 true 即可]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>回到页首按钮显示百分比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加在线联系]]></title>
    <url>%2F2018%2F06%2F10%2FHexo%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[Hexo添加在线联系 当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。 配置方法 首先到 DaoVoice 上注册一个账号，注册完成后会得到一个 app_idhttp://dashboard.daovoice.io 获取 appid 的步骤 在 DaoVoice 的应用设置 -&gt; 安装到网站中的找到自己的 app_id然后在主题 /next/layout/_partials/head.swig 文件中最后添加代码 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 主题配置文件中添加配置 在主题配置文件 /next/_config.yml 中添加相应的配置 123# Online contactdaovoice: truedaovoice_app_id: 这里输入前面获取的app_id 调整位置 最后聊天图标的位置可能和一些东西重叠这个使用可以在控制面板中应用设置 -&gt; 聊天设置里面设置相对右边和底部的位置 参考文档https://www.ezlippi.com/blog/2018/01/next-chat.htmlhttps://meta.tn/a/c40f12eb1b892bbb8cda053c03c688e3f20e4f642164080ef463cd4a7bc3b042http://www.niww.me/2018/03/02/hexo-daovoice/]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加在线联系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题背景]]></title>
    <url>%2F2018%2F06%2F10%2FNext%E4%B8%BB%E9%A2%98%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Next主题背景个性化DIY 整理了一下博客，加个背景图片（BackGroundImage）调整一下视觉感官，背景图片 是动态变化的，每次刷新都会更新一张图 一个图片网站 分享一个非常 Nice 的图片网站，感觉这个国外的图片社区网站真的秒杀一众图片网站啊，不仅图片质量高，免费，而且还提供了随机拉取图片的服务 API，太赞，对于想实现动态背景，简直是福音https://source.unsplash.com/ 添加背景图片 修改 \themes\next\source\css\_custom\custom.styl 文件这个是 Next 故意留给用户自己个性化定制一些样式的文件，添加以下代码 123456body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125; URL 括号中直接添加图片的地址链接，也可以置换成你所喜欢的任意图片。repeat、attachment、position 就是调整图片的位置，不重复出现、不滚动等。]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next主题背景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加看板娘]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98%2F</url>
    <content type="text"><![CDATA[添加看板娘 实现效果 用 Git Bash Here 在站点根目录执行如下代码 12cd D:\hexo\npm install hexo-helper-live2d --save 然后打开 /themes/next/layout/_layout.swig 将下面代码放到 &lt;/body&gt; 之前{ { live2d() } }注意：由于官方更新了包，所以画删除线的不用做了 然后在这里可以看到一些已有的模型，记下想要的模型名字，使用安装命令https://huaji8.top/post/live2d-plugin-2.0/ 1npm install "模型的包名" 模型的包名 12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 以 hijiki 为例12345678910$ npm install "live2d-widget-model-hijiki" --savenpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)+ live2d-widget-model-hijiki@1.0.5added 1 package and audited 3800 packages in 8.046sfound 2 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for details$ npm install live2d-widget-model-tororo --save 在 配置文件 末尾添加代码 安装完成后，还需要在一些小小的修改在 _config.yml（Hexo站点 或 Next主题 皆可）中，加入以下内容 /blog/_config.yml或/blog/next/themes/_config.yml 123456789101112131415## 看板娘live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki display: position: right width: 150 height: 300 mobile: show: true # false 手机端不显示 详细配置1234567891011121314151617181920live2d: enable: true # 是否开启 scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url model: use: live2d-widget-model-wanko # 调用模型名，必须要先下载 display: position: right # 在博客的左边还是右边显示 width: 150 # 边框宽度 height: 300 # 边框高度 mobile: show: true # 是否在手机上显示 # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 根据需要可修改use:后的包名；调整长度和宽度；选择是否停用插件等。 参考文档https://wangyuyang.me/2018/04/06/对基于HEXO的NexT主题的美化/https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.mdhttps://alvabill.ml/hexo搭建个人博客-NexT主题优化/]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>添加看板娘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome自带的长截屏功能]]></title>
    <url>%2F2018%2F06%2F10%2FChrome%E8%87%AA%E5%B8%A6%E7%9A%84%E9%95%BF%E6%88%AA%E5%B1%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Chrome自带的长截屏功能 在 Google Chrome 里面，打开开发人员工具 按F12或网站上任意空白处右键 – 选择 “检查” 或者“审查元素” 快捷键 Ctrl + Shift + P，会看到右边的审查元素出现了一个输入框输入 screenshot 然后回车保存图片]]></content>
      <categories>
        <category>Chrome笔记</category>
      </categories>
      <tags>
        <tag>Chrome自带的长截屏功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chevereto图床]]></title>
    <url>%2F2018%2F06%2F10%2FChevereto%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[Chevereto图床 Chevereto 是一款采用 PHP 语言开发的网络相册脚本程序，支持多语言，提供中文语言包的下载的开源在线图片存储分享服务系统，支持本地上传和在线获取两种图像上传方式，并集成了 TinyURL 网址缩短服务。Chevereto 这套程序可以像 Discuz 或 WordPress 一样随意架设在任何空间上。而它的功能除了一般图片空间单纯的从电脑上传图片外，也支援利用网址也可以上传，最屌的是还有 TinyURL 的缩短网址的功能可以使用，因此这套 Chevereto 可以说是比市面上的图片空间好太多了。他是把图片上传到空间的，相信一般大家都一定会使用免费空间，在此建议大家在挑主机时尽可能使用 cPanel 的空间，因为可以使用 cPanel 特有的 「Cron Jobs」 来备份你上传的图片。 Chevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirements Clevereto 错误 404 解决方法 如果 Web服务 是 Nginx，基本第一步安装好后再次打开网站会出现 404 错误。因为 Chevereto 默认提供基于 Apache 环境的伪静态规则 需要设置以下 Rewrite 伪静态规则123456789101112131415location / &#123; if (-f $request_filename/index.html)&#123; rewrite (.*) $1/index.html break; &#125; if (-f $request_filename/index.php)&#123; rewrite (.*) $1/index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) /index.php; &#125; try_files $uri $uri/ /api.php;&#125;location /admin &#123; try_files $uri /admin/index.php?$args;&#125; 官方推荐配置123456789101112131415161718192021222324252627282930# Disable access to .ht* fileslocation ~ /\.ht &#123; deny all;&#125;# Disable access to sensitive files in app pathlocation ~ /(app|content|lib)/.*\.(po|php|lock|sql)$ &#123; deny all;&#125;# Disable log on not found images + image replacement# Image not found replacementlocation ~* (jpe?g|png|gif) &#123; log_not_found off; error_page 404 /content/images/system/default/404.gif;&#125;# Enable CORS header (avoids font rendering issues)location ~ \.(ttf|ttc|otf|eot|woff|woff2|font.css|css|js)$ &#123; add_header Access-Control-Allow-Origin "*";&#125;# Force serve upload path as static contentlocation ~ /images &#123;&#125;# Pretty URLs# Route dynamic request to index.phplocation / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 参考文档 https://www.zhujibiji.com/2017/11/install-chevere-to-build-your-image-sharing-website/https://lala.im/2478.html]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>Chevereto图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于图床的选择]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%BA%8A%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[关于图床的选择为什么要使用图床？ Hexo 文章中的图片，我们可以放到本地，然后一起部署到 Github 中，这样完全没有问题。然而 github pages 空间毕竟有限（貌似只有 300M）,另外图片的管理太混乱了，一些原创的图片可能被盗链。 很多技术人写作都用的是 MarkDown 轻量级标记语言进行博客写作，这种写作让我们不用像使用 Word 那样那么麻烦地调整排版和格式，只需专心写作并且照样完成排版的一种方式。但是，基本所有支持 MarkDown 本地写作工具都只能采用导入本地图片引用的方式，对于一篇需要大量图片阐述的文章以及该文章上传至网络图片丢失，这不得不是个很糟糕的问题。那么有什么比较好的解决方式吗？很多人采用的图片寄存于网络，用服务厂商作为图片存储的地方，大家都叫为 「图床」 。 那么像 CSDN 博客、简书平台不是都可以吗？是的，它们平台写文章的时候都可以导入图片然后得到一个图片网络地址。但是，图片数量多，一张一张上传，这不是贼烦嘛！那么有专门可以作 「图床」 功能的服务商吗？有的，比如七牛云。 网上谷歌搜下还是能搜到很多图床网站的，先随便列举一些 公共图床SM.MS https://sm.ms/SM.MS 是由 V2EX @Showfom 自建的，无外链限制，无流量限制的图床，支持 HTTPS，速度不错，已经运行两年多了。 极简图床 https://jiantuku.com/#/ 路过图床 https://imgchr.com/ Imgur https://imgur.com/Imgur 是一家国外老牌的图片存储服务商，国外速度很快，口碑不错，支持 HTTPS。但是国内速度很不稳定，所以追求国内速度的同学慎用。 Qchan图床http://tuchuang.org/ 微博图床 微博图床，可以自定义支持七牛，界面简洁美观，支持 Chrome 插件，注册后还可以同步上传历史。 自建图床 目前自建图床方案有两种 是利用云服务商提供的存储服务来作为图床，通过 API 来管理图片 是在 VPS 上安装开源的图片或文件管理程序，只要能提供外链，基本都可以作为图床来用。 建图床（云服务） 七牛云，又拍云，阿里云OSS 自建图床（开源方案） 如果你有 VPS，并且网络速度 OK 的话，自建图床也是一个不错的选择。 Lychee https://github.com/electerious/LycheeLychee 是一个开源免费的基于 PHP 的图片管理系统，支持 Docker 部署，可以直接当做图床来用，Lychee 还支持很多扩展。 树洞外链 https://yun.aoaoao.me/https://github.com/HFO4/shudong-share树洞外链 是一款免费开源的 PHP 外链网盘系统，界面简洁友好，支持七牛、本地、远程、阿里云OSS、又拍云五种储存方式，支持多用户系统，多上传方案策略。 Chevereto https://chevereto.com/https://github.com/Chevereto/Chevereto-Freehttps://chevereto.com/docs/requirementsChevereto 是一款分享照片的程序，可以非常轻松得在自己的服务器上搭建照片分享程序，功能强大，外观精美。Chevereto 本身是收费使用的，一次性付费，终身使用，但是其开源版本可以免费使用。 使用图床的目的是希望文章的图片资源能有更好的加载速度和稳定的显示效果。]]></content>
      <categories>
        <category>图床笔记</category>
      </categories>
      <tags>
        <tag>关于图床的选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之堆溢出处理]]></title>
    <url>%2F2018%2F06%2F10%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%A0%86%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java 虚拟机之堆溢出处理在 Java 程序的运行过程中，如果堆空间不足，则有可能抛出内存溢出错误 (Out Of Memory)，简称为 OOM。 如下文字显示了典型的堆内存溢出 1Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:20) 一旦发生这类问题，系统就会被迫退出。如果发生在生产环境，可能会引起严重的业务中断。为了能够不断改善系统，避免或减少这类错误的发生，需要在发生错误时，获得尽可能多的现场信息，以帮助研发人员排查现场问题。 Java 虚拟机提供了参数 -XX:+HeapDumpOnOutOfMemoryError，使用该参数，可以在内存溢出时导出整个堆信息。和它配合使用的还有 -XX:HeapDumpPath，可以指定导出堆的存放路径。 使用如下参数执行上述代码 1-Xms5m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/app/tomcat/logs/P02.dump 显然 20M 堆空间不足以容纳 25M 内存，系统比如发生内存溢出，在发生错误后，控制台输出如下 1java.lang.OutOfMemoryError: Java heap space Dumping heap to /data/app/tomcat/logs/P02.dump... Heap dump file created [23067302 bytes in 0.160 secs] Exception in thread “main” java.lang.OutOfMemoryError: Java heap space at geym.zbase.ch3.heap.DumpOOM.main(DumpOOM.java:19) 可以看到，虚拟机将当前的堆导出，并保存到 /data/app/tomcat/logs/P02.dump 文件下启动最小空间 5M，配了 20M 最大空间 ，发生了 内存溢出错误，dump 路径为 /data/app/tomcat/logs/P02.dump 使用 MAT 等工具打开该文件进行分析，可以很容易地找到这些 byte 数组和保存它们的 Vector 对象实例]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java虚拟机之堆溢出处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编译安装]]></title>
    <url>%2F2018%2F06%2F08%2FPython%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一般情况下，Linux 都会预装 Python，但是这个预装的 Python 版本一般都比较低，很多 Python 的新特性都没有，必须重新安装新一点的版本Python下载地址https://www.python.org/https://www.python.org/ftp/python/https://www.python.org/ftp/python/2.7.15/https://www.python.org/ftp/python/3.7.0/ 查看 Python 版本1234567python -V# CentOS 6.xPython 2.6.6# CentOS 7.xpython 2.7.5 做好链接，保留旧版本 pythoncd /usr/bin/cp /usr/bin/python /usr/bin/python_bak 如果发现 yum 不能用了，解决 yum 无法使用的问题因为 yum 依赖系统默认安装的 python 版本, 处理如下：vim /usr/bin/yum#!/usr/bin/python修改为-&gt; #!/usr/bin/python2.6 或 #!/usr/bin/env python2.6import systry: import yumexcept ImportError:……省略…… 这里不更改 原 Python 版本 安装依赖1yum -y install readline readline-devel sqlite sqlite-devel zlib zlib-devel openssl openssl-devel bzip2 bzip2-devel bzip2-libs 缺少 readline 支持的 IPythonWARNING: IPython History requires SQLite, your history will not be savedWARNING: Readline services not available or not loaded.WARNING: The auto-indent feature requires the readline library 下载 Python12wget -c https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xzwget -c https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tar.xz 安装 Python安装 Python 2.7.15123456tar -xvf Python-2.7.15.tgzcd Python-2.7.15/./configure \--prefix=/data/python2.7.15 --enable-optimizationsmake -j 4make install 安装 Python 3.7.0123456tar -xvf Python-3.7.0.tgzcd Python-3.7.0/./configure \--prefix=/data/python3.7.0 --enable-optimizationsmake -j 4make install 添加 Python 环境变量12345vim /etc/profile.d/python.sh#!/bin/bashexport PATH=$PATH:/data/python3.7.0/binsource /etc/profile 或 12echo -e '\nexport PATH=$PATH:/data/python2.7.15/bin' &gt;&gt; /etc/profileecho -e 'export PATH=$PATH:/data/python3.7.0/bin' &gt;&gt; /etc/profile PS：如果安装 easy_intall 时报 zlib 没有安装，Linux下直接 yum -y install zlib zlib-devel，然后重新编译 Python2.7.15 继续就可以了cp /usr/bin/python /usr/bin/python_bakln -svnf /data/python2.7.15/bin/python2.7 /usr/bin/python setuptools 安装 下载地址https://pypi.python.org/pypi/setuptoolshttps://pypi.python.org/simple/setuptools/ 1234tar -zxvf setuptools-40.0.0.tar.gzcd setuptools-40.0.0python3 setup.py buildpython3 setup.py install 安装 pip pip 下载地址https://pypi.org/project/pip/ 1234tar -xvf pip-18.0.tar.gzcd pip-18.0/python3 setup.py buildpython3 setup.py install 安装 IPython IPython 是一个 python 的交互式 Shell，比默认的 Python Shell 好用一点，支持变量自动补全，自动缩进，支持 Bash Shell 命令，内置了许多很有用的功能和函数IPython 下载地址https://pypi.org/project/ipython/ 1234tar -zxvf ipython-6.4.0.tar.gzcd ipython-6.4.0/python3 setup.py buildpython3 setup.py install pip 安装 python 第三方库1234pip3 install requestspip3 install pyapi-gitlabpip3 install readlinepip3 install rlcompleter2 Python 组件更新123pip3 install --upgrade pippip3 install --upgrade setuptoolspip3 install --upgrade requests]]></content>
      <categories>
        <category>Python笔记</category>
      </categories>
      <tags>
        <tag>Python编译安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志切割]]></title>
    <url>%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志切割 12345678910111213141516vim logcut.sh#!/bin/bashday=$(date +"%Y-%m-%d")yesterday=$(date -d "yesterday" +%Y-%m-%d)logsdir=(/data/app/*/logs)for logdir in $&#123;logsdir[@]&#125;do for logfile in $(ls $&#123;logdir[@]&#125; | egrep "stdout.log|catalina.out") do cp $logdir/$logfile $logdir/$&#123;logfile%.log&#125;.$&#123;day&#125;.log cp $logs/$file $logs/$&#123;file%.out&#125;.$&#123;day&#125;.out cat /dev/null &gt; $logdir/$logfile donedone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志切割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本日志压缩]]></title>
    <url>%2F2018%2F06%2F08%2FShell%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[Shell 脚本日志压缩打包 压缩 7 天前日志每个月 1 号，创建上个月的目录，年-月 2018-04将 gz 压缩文件拷贝到 年-月 2018-04 目录中 1234567891011121314151617181920vim compresslog.sh#!/bin/bashday=$(date +"%d")month=$(date +"%Y-%d")lastmonth=$(date +"%Y-%m" -d "last month")lastweek=$(date +"%Y-%m-%d" -d "last week")logsdir=(/data/app/*/logs)for logs in $&#123;logsdir[@]&#125;do find $logs/ -mtime +7 -regextype posix-extended -regex ".*\.(log|out|txt)" -exec gzip &#123;&#125; \;done[ $day == 01 ] &amp;&amp; cd $&#123;logsdir[@]&#125; &amp;&amp; mkdir -pv $lastmonthfor logdir in $&#123;logsdir[@]&#125;do [ -d $logdir/$lastmonth ] || mkdir -pv $logdir/$lastmonth mv $logdir/*gz $logdir/$lastmonthdone]]></content>
      <categories>
        <category>Shell笔记</category>
      </categories>
      <tags>
        <tag>Shell脚本日志压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LVM 磁盘扩展]]></title>
    <url>%2F2018%2F06%2F07%2FLVM%E7%A3%81%E7%9B%98%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[LVM 磁盘扩展 查看磁盘空间1df -h 查看 LV 信息1lvs 查看 VG 信息1vgs 创建 PV1pvcreate /dev/vdb 扩展已有的 VG 容量1vgextend vgdata /dev/vdb Couldn&#39;t&#39; create temporary archive name.因为磁盘实在太小了或已经没有空间了，无法执行，删除一些数据就好了 12vgextend vgdata /dev/sdaVolume group "vgdata" successfully extended 查看 VG 信息1vgs 扩展已有 LV 容量123lvextend -l +100%FREE /dev/vgdata/lvdatalvextend -L +99.99G -n /dev/vgdata/lvdatalvextend -L +1020M -n /dev/vgdata/lvdata -L # 指定逻辑卷的大小，单位为 kKmMgGtT 字节，也就是 Size-l # 指定逻辑卷的大小，单位为 PE 数 重新加载逻辑卷12345# 加载 ext 文件系统resize2fs /dev/vgdata/lvdata# 加载 xfs 文件系统xfs_growfs /dev/vgdata/lvdata]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>LVM 磁盘扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建LVM]]></title>
    <url>%2F2018%2F06%2F07%2FLVM%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[创建 LVM LVM 创建过程创建PV -&gt; 创建VG -&gt; 创建LV -&gt; 格式化LV -&gt; mount挂载 常用命令pvcreate 设备名vgcreate 卷组名 物理卷lvcreate -L 大小 -n 逻辑卷名 卷组名 LVM 常用命令表 功能 管理物理卷 管理卷组 管理逻辑卷 Scan 扫描 pvscan vgscan lvscan Create 创建 pvcreate vgcreate lvcreate Display 显示 pvdisplay vgdisplay lvdisplay Remove 删除 pvremove vgremove lvremove Extend 扩展 vgextend lvextend Reduce 减少 vgreduce lvreduce 安装 LVM1yum -y install lvm2 创建 PV12pvcreate /dev/vdbPhysical volume "/dev/vdb" successfully created 创建 VG12vgcreate vgdata /dev/vdbVolume group "vgdata" successfully created 创建 LV12345lvcreate -L 49.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created.lvcreate -L 99.99G -n lvdata vgdata /dev/vdbLogical volume "lvdata" created. 文件系统格式化12345# 格式化 ext 文件系统mkfs.ext4 /dev/vgdata/lvdata# 格式化 xfs 文件系统mkfs.xfs /dev/vgdata/lvdata 挂载逻辑卷到目录12mkdir -pv /datamount /dev/vgdata/lvdata /data 编辑 /etc/fstab1234vim /etc/fstab...省略.../dev/mapper/vgdata-lvdata /data xfs defaults 0 0...省略... ###]]></content>
      <categories>
        <category>LVM笔记</category>
      </categories>
      <tags>
        <tag>创建LVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加文章结束标记]]></title>
    <url>%2F2018%2F06%2F07%2FNext%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[添加文章结束标记 编辑 /hexo/themes/next/layout/_macro/post.swig 文件在 if theme.wechat_subscriber.enabled and not is_index 上面添加如下代码 代码片段123456&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt;&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125; &lt;div&gt; &#123;% include 'wechat-subscriber.swig' %&#125; &lt;/div&gt;&#123;% endif %&#125; 显示效果1————— The End —————]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加文章结束标记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加音乐]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[Next 添加音乐 去网易云音乐搜索喜欢的音乐，点击生成外链播放器，复制代码直接放到博文末尾即可height 设为 0 可隐藏播放器，但仍然可以播放音乐auto 设成 0 可手动播放，默认是 1 自动播放 编辑 /hexo/themes/next/layout/_custom/sidebar.swig 文件里，播放器会显示在站点预览中或编辑 /hexo/themes/next/layout/_macro/sidebar.swig 文件里 123# 将代码粘贴到一个合适的位置&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2188265841&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加分类及标签]]></title>
    <url>%2F2018%2F06%2F06%2FHexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[Hexo添加分类及标签创建 分类 选项 生成 分类 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page categories 成功后会提示 1INFO Created: ~/hexo/source/categories/index.md 根据上面的路径，找到 index.md 这个文件，打开后默认内容是这样的 1234---title: 文章分类date: 2018-06-06 22:49:07--- 添加 type: &quot;categories&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "categories"--- 给文章添加 “categories” 属性 打开需要添加分类的文章，为其添加 categories 属性下方的 categories: Hexo笔记 表示添加这篇文章到 Hexo笔记 这个分类注意：hexo 一篇文章只能属于一个分类，也就是说如果在 - Hexo笔记 下方添加 - xxxhexo 不会产生两个分类，而是把分类嵌套（即该文章属于 - Hexo笔记 下的 - xxx 分类） 123456---title: Hexo添加分类及标签date: 2018-06-06 22:44:41categories: - Hexo笔记--- 至此，成功给文章添加分类，点击首页的 分类 可以看到该分类下的所有文章当然，只有添加了 categories: xxx 的文章才会被收录到首页的 分类 中 创建标签选项 生成 标签 页并添加 type 属性打开命令行，进入博客所在文件夹，执行命令 1hexo new page tags 成功后会提示 1INFO Created: ~/hexo/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的 1234---title: 标签date: 2018-06-06 22:49:07--- 添加 type: &quot;tags&quot; 到内容中，添加后是这样的 12345---title: 文章分类date: 2018-06-06 22:49:07type: "tags"--- 给文章添加tags属性打开需要添加标签的文章，为其添加 tags 属性下方的tags:Hexo添加分类及标签- 表格- 表单验证就是这篇文章的标签了 12345678910---title: Hexo添加分类及标签date: 2018-06-06 22:49:07categories: - Hexo笔记tags:- Hexo添加分类及标签- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的标签可以看到该标签下的所有文章当然，只有添加了 tags: xxx 的文章才会被收录到首页的标签中细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的所以我们可以打开 \hexo\scaffolds/post.md 文件，在 tages:上面加入categories:1234567vim /hexo/scaffolds/post.md---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- 保存后执行hexo new &quot;文章名&quot;命令生成的文件，页面里就有categories:项了\hexo\scaffolds\ 目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo添加分类及标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置网站的图标Favicon]]></title>
    <url>%2F2018%2F06%2F06%2FHexo%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%AB%99%E7%9A%84%E5%9B%BE%E6%A0%87Favicon%2F</url>
    <content type="text"><![CDATA[Hexo 设置网站的图标 Favicon ico图标使用 32x32去别的网站下载或 PS 制作，并将图标名称改为 favicon.ico然后把图标放在 \next\themes\next\source\images\ 目录下也可以放在 hexo\source\images 目录下，这个目录没有可以自己手动创建 修改 next主题配置文件，\next\themes\next\_config.yml 文件12345678favicon: small: /images/favicon-16x16-next.png #medium: /images/favicon-32x32-next.png medium: /images/favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo设置网站的图标Favicon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next添加访问量]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Next添加访问量 使用 Next 主题自带的不蒜子统计，仅限于在文章页面显示阅读量，不在首页显示 修改 themes\next\ _config.yml 文件123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访问人数(UV) site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量(PV) site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 总访问量 (PV) 总访问量独立访客 (UV) 访问人数网站的浏览次数为 PV网站的访客数为 UVPV 计算方式，单个用户连续点击 N 篇文章，记录 N 次访问量UV 计算方式，单个用户连续点击 N 篇文章，只记录 1 次访客数可以根据需要添加相应的统计功能 查看底部显示效果]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next添加访问量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next修改小型代码块颜色]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E4%BF%AE%E6%94%B9%E5%B0%8F%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%9D%97%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Next 修改小型代码块颜色 修改 \themes\next\source\css\ _variables\base.styl 文件可以加入自定义颜色，如下中已经给出了许多种颜色 12345678910111213// Colors// colors for use across theme.// --------------------------------------------------$whitesmoke = #f5f5f5$gainsboro = #eee$gray-lighter = #ddd...$blue = #0684bd$blue-deep = #262a30$orange = #fc6423 修改 $code-background 与 $code-foreground 的值 以下的各个参数自己根据需求进行设置即可 1234567// Code &amp; Code Blocks// --------------------------------------------------$code-font-family = $font-family-monospace$code-font-size = 13px$code-foreground = $black-light //设置成自己喜欢的颜色即可$code-background = $gainsboro //设置成自己喜欢的颜色即可$code-border-radius = 4px 在 \themes\next\source\css\ _variables\base.styl 文件内还有很多的参数，可以酌情进行修改]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next修改小型代码块颜色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next头像圆形旋转]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E5%A4%B4%E5%83%8F%E5%9C%86%E5%BD%A2%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[头像变成圆形，鼠标停留在上面发生旋转效果 介绍一下实现头像圆形，鼠标经过旋转或者一直让旋转效果修改 Hexo 目录下 \themes\next\source\css\_common\components\sidebar\sidebar-author.styl 文件 头像圆形修改 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转修改 修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 方法二：修改 themes/next/source/css/_common/components/sidebar/sidebar-author.styl 123456789101112131415161718192021222324.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 头像循环旋转效果修改 修改 sidebar-author.styl 文件，添加如下代码 12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下 12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码 12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125;]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next头像圆形旋转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置首页隐藏指定文章]]></title>
    <url>%2F2018%2F06%2F06%2FNext%E8%AE%BE%E7%BD%AE%E9%A6%96%E9%A1%B5%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Next设置首页隐藏指定文章 修改 next 主题文件夹下的 layout 中的 index.swig 文件定位修改 post_template.render(post, true) 1234567891011\themes\next\layout\index.swig...省略...&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.visible !== 'hide' %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt;...省略... 其中修改的是为文章的首页显示添加判断条件 在新的 post 中添加 visible 字段来控制是否首页显示 例如：当前这篇文章 12345title: Next设置首页隐藏指定文章date: 2018-06-06 01:08:59categories: Next笔记tags: Next设置首页隐藏指定文章visible: hide 这里如果加上 hide 则该文章就不会在文章首页显示，如果留空则表示默认显示]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置首页隐藏指定文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks 安装]]></title>
    <url>%2F2018%2F06%2F06%2FShadowsocks%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Shadowsocks 安装 123456yum -y install python-pippip install --upgrade pippip install shadowsockswhich ssserverpip install M2Cryptopip install gevent 123456789101112131415161718vim /etc/systemd/system/shadowsocks.service[Unit]Description=Shadowsocks[Service]Type=simpleTimeoutStartSec=0PIDFile=/data/shadowsocks/var/run/ssserver.pidExecStart=/usr/bin/ssserver -c /data/shadowsocks/conf/shadowsocks.json -d start \ --pid-file /data/shadowsocks/var/run/ssserver.pid \ --log-file /data/shadowsocks/logs/ssserver.logRestart=on-abortRestartSec=10sPrivateTmp=true[Install]WantedBy=multi-user.targettail -f /data/shadowsocks/logs/ssserver.log 123456789101112131415mkdir -pv /data/shadowsocks/&#123;conf,logs,var/run&#125;cd /data/shadowsocks/vim shadowsocks.json&#123; "server":"149.28.231.171", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "8888":"gmlyo", "8889":"glmyo" &#125;, "timeout":300, "method":"aes-256-cfb", "fast_open":false&#125; 1234567systemctl daemon-reloadsystemctl start shadowsockssystemctl -l status shadowsockssystemctl enable shadowsockssystemctl stop shadowsockssystemctl restart shadowsocksjournalctl -fu shadowsocks 12345678910111213141516171819202122232425262728293031323334# 查看防火墙状态systemctl status firewalldsystemctl -l status firewalld# 查看防火墙，添加的端口也可以看到firewall-cmd --list-all# 显示所有公共区域（public）所有设置firewall-cmd --zone=public --list-all# 查看开放的服务firewall-cmd --list-services# 显示服务列表firewall-cmd --get-services# 永久添加开放端口firewall-cmd --zone=public --permanent --add-port=8888/tcpfirewall-cmd --zone=public --permanent --add-port=1194/udp# 查询刚插入的规则是否生效firewall-cmd --zone=public --query-port=1985/tcp# 查询指定的端口是否永久开放firewall-cmd --zone=public --permanent --query-port=1985/tcp# 永久删除正在开放的端口firewall-cmd --zone=public --permanent --remove-port=8080/tcpfirewall-cmd --zone=public --permanent --remove-port=1194/udp# 重新加载配置firewall-cmd --reload# 查看所有打开的端口firewall-cmd --zone=public --list-portsfirewall-cmd --zone=dmz --list-ports]]></content>
      <categories>
        <category>Shadowsocks笔记</category>
      </categories>
      <tags>
        <tag>Shadowsocks 安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat_APR_安装]]></title>
    <url>%2F2018%2F06%2F05%2FTomcat_APR_%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Tomcat APR 安装 APR(Apache portable Run-time libraries) 可移植运行时库，是 Apache HTTP 服务的支持库，提供了一组映射到下层操作系统的 API。Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高 Tomcat 对静态文件的处理性能。改善 Tomcat 对静态文件的处理性能，同时如果使用了 HTTPS 方式传输的话，也可以提升 SSL 的处理性能。默认情况下，Tomcat 是用 BIO 的方式来实现网络通信的，性能非常低。Tomcat apr 也是在 Tomcat 上运行高并发应用的首选模式。APR 使用 JNI 的方式来读取文件以及进行网络传输，从操作系统级别来解决异步的 I/O 问题，大幅度的提高性能。如果操作系统不支持某个特定的功能，APR 将提供一个模拟的实现，这样程序员使用 APR 编写真正可在不同平台上移植的程序 安装依赖12345Tomcat 和 JDKyum install -y apr-develyum install -y gcc gcc-develyum install -y openssl openssl-develyum install -y expat-devel 下载 apr 下载地址：https://apr.apache.org/download.cgi 1234cd /data/tools/wget -c http://mirrors.shu.edu.cn/apache//apr/apr-1.6.3.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-util-1.6.1.tar.gzwget -c http://mirrors.shu.edu.cn/apache//apr/apr-iconv-1.2.2.tar.gz 安装 apr1234567891011121314151617181920212223# 解压并进入解压目录cd /data/tools/tar -zxvf apr-1.6.3.tar.gzcd apr-1.6.3/# 配置，安装在 /data/ 目录下./configure --prefix=/data/apr# 报错信息config.status: executing libtool commandsrm: cannot remove 'libtoolT': No such file or directoryconfig.status: executing default commands# 解决方法# 编辑 configure 文件cd apr-1.6.3/vim configure把 $RM "$cfgfile" 这行代码注释掉或 把 $RM "$cfgfile" 这行删除掉或 写成 $RM -f "$cfgfile"重新再运行 ./configure 就可以了# 编译安装make -j 4make install 安装 apr-iconv1234567891011# 解压并进入解压目录cd /data/tools/tar -zxvf apr-iconv-1.2.2.tar.gzcd apr-iconv-1.2.2/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-iconv \--with-apr=/data/apr# 编译安装make -j 4make install 安装 apr-util123456789101112131415161718192021222324252627# 解压并进入解压目录cd /data/tools/tar -zxvf apr-util-1.6.1.tar.gzcd apr-util-1.6.1/# 配置，安装在 /data/ 目录下./configure \--prefix=/data/apr-util \--with-apr=/data/apr \--with-apr-iconv=/data/apr-iconv/bin/apriconv# 编译安装make -j 4# 报错信息xml/apr_xml.c:35:19: fatal error: expat.h: No such file or directory #include &lt;expat.h&gt; ^compilation terminated.make[1]: *** [xml/apr_xml.lo] Error 1make[1]: Leaving directory `/data/tools/apr-util-1.6.1'make: *** [all-recursive] Error 1# 解决办法# 缺少 expat 开发库，安装 expat 库yum install -y expat-devel# 重新执行make -j 4make install 配置 Tomcat 使用 apr 库 什么是 tomcat-native ？tomcat-native 库为 Tomcat 提供了本地实现tomcat-native 依赖于三个组件：APR，OpenSSL，JDK 大致就是通过 tomcat-native 库，使 tomcat 运行时通过 APR 更多的调用本地 API，达到提升性能的目的。由于依赖关系，安装时，先安装 APR，OpenSSL，然后再安装 tomcat-native，最后配置 tomcat 启动时依赖的库路径。 安装配置 Tomcat native 具体的安装步骤其实在 tomcat 自带的 tomcat-native.tar.gz 文件中就有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 进入 Tomcat bin 目录cd /data/app/tomcat/bin/# 解压 tomcat-native.tar.gz 后进入解压目录tar -zxvf tomcat-native.tar.gz# cd tomcat-native-1.2.8-src/native/ # Tomcat7cd tomcat-native-1.1.33-src/jni/native/# 配置 指定 JDK 的目录并加入 SSL./configure \--prefix=/data/apr \--with-apr=/data/apr/bin/apr-1-config \--with-java-home=/data/jdk1.8.0_172 \--with-ssl=yes# 编译安装make -j 4make installwarning: remember to run 'libtool --finish /usr/local/apr/lib'libtool --finish /data/apr/lib-bash: libtool: command not foundyum -y install libtool libtool-devellibtool --finish /data/apr/lib###################################################################################################cd tomcat-native-1.2.16-src/native//data/apr/build-1/libtool --mode=install /bin/install -c -m 755 libtcnative-1.la /data/apr/liblibtool: install: /bin/install -c -m 755 .libs/libtcnative-1.so.0.2.16 /data/apr/lib/libtcnative-1.so.0.2.16libtool: install: (cd /data/apr/lib &amp;&amp; &#123; ln -s -f libtcnative-1.so.0.2.16 libtcnative-1.so.0 || &#123; rm -f libtcnative-1.so.0 &amp;&amp; ln -s libtcnative-1.so.0.2.16 libtcnative-1.so.0; &#125;; &#125;)libtool: install: (cd /data/apr/lib &amp;&amp; &#123; ln -s -f libtcnative-1.so.0.2.16 libtcnative-1.so || &#123; rm -f libtcnative-1.so &amp;&amp; ln -s libtcnative-1.so.0.2.16 libtcnative-1.so; &#125;; &#125;)libtool: install: /bin/install -c -m 755 .libs/libtcnative-1.lai /data/apr/lib/libtcnative-1.lalibtool: install: /bin/install -c -m 755 .libs/libtcnative-1.a /data/apr/lib/libtcnative-1.alibtool: install: chmod 644 /data/apr/lib/libtcnative-1.alibtool: install: ranlib /data/apr/lib/libtcnative-1.alibtool: finish: PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/data/jdk1.8.0_144/bin:/data/jdk1.8.0_144/jre/bin:/root/bin:/sbin" ldconfig -n /data/apr/lib----------------------------------------------------------------------Libraries have been installed in: /data/apr/libIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the '-LLIBDIR'flag during linking and do at least one of the following: - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the 'LD_RUN_PATH' environment variable during linking - use the '-Wl,-rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to '/etc/ld.so.conf'See any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------# 将 apr 加载到 ldconfig 中vim /etc/ld.so.conf.d/apr.conf/data/apr/lib/data/apr-util/lib/data/apr-iconv/lib# 重新加载以下 ldconfigldconfig -v | grep apr/data/apr/lib: libapr-1.so.0 -&gt; libapr-1.so.0.6.3/data/apr-util/lib: libaprutil-1.so.0 -&gt; libaprutil-1.so.0.6.1/data/apr-iconv/lib: libapriconv-1.so.0 -&gt; libapriconv-1.so.0.2.2 CentOS 6.x 安装配置 Tomcat native CentOS 6.x 会出现以下这类问题 1234checking OpenSSL library version &gt;= 1.0.2... Found OPENSSL_VERSION_NUMBER 0x1000105f (OpenSSL 1.0.1e 11 Feb 2013)Require OPENSSL_VERSION_NUMBER 0x1000200f or greater (1.0.2)configure: error: Your version of OpenSSL is not compatible with this version of tcnative OpenSSL 版本与 tcnative 版本不兼容CentOS 7.2 或以上版本不会出现这类问题需要手工安装 OpenSSL 1.0.2 或以上版本 123456789101112# 下载 OpenSSLwget -c https://www.openssl.org/source/openssl-1.0.2p.tar.gz或wget -c https://www.openssl.org/source/openssl-1.1.0i.tar.gz# 安装 OpenSSLtar -xvf openssl-1.1.0i.tar.gzcd openssl-1.1.0i/./config --prefix=/usr/local/openssl./config -tmake -j 4make install 123456789101112131415161718192021222324252627282930313233# 将 openssl 的 lib 加入系统 ldconfig 中vim /etc/ld.so.conf.d/openssl.conf/usr/local/openssl/lib# 加载一下ldconfig -vldconfig -v | grep libssl# 查看 OpenSSL 版本/usr/local/openssl/bin/openssl version -a# 如果遇到以下错误openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directoryopenssl: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory# 是由于 OpenSSL 库的位置不正确造成的# 做一下软链接，就好了ln -svnf /usr/local/openssl/lib/libssl.so.1.1 /usr/lib64/libssl.so.1.1ln -svnf /usr/local/openssl/lib/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1# 配置环境变量vim /etc/profile.d/openssl.sh#!/bin/bashexport OPENSSL_HOME=/usr/local/opensslexport PATH=$PATH:$OPENSSL_HOME/binopenssl version -a# 或把原来的命令备份一下，做个软链接ll -h /usr/bin/opensslmv /usr/bin/openssl&#123;,_bak&#125;mv /usr/include/openssl&#123;,openssl_bak&#125;ln -svnf /usr/local/openssl/bin/openssl /usr/bin/opensslln -svnf /usr/local/openssl/include/openssl /usr/include/openssl 有 两 种方式配置 Tomcat 使用 apr 库方式一：配置 Tomcat Native 环境变量 在 Linux 系统中，只要 $LD_LIBRARY_PATH 变量值所在路径包含 Tomcat 本地库默认就使用 org.apache.coyote.http11.Http11AprProtocol 12345vim /etc/profile.d/apr.sh#!/bin/bashexport LD_LIBRARY_PATH=/data/apr/libsource /etc/profile 方式二：将 apr 库路径参数添加到 Tomcat 系统变量中（推荐） 编辑 $CATALINA_HOME/bin/setenv.sh 文件（如果文件不存在，新建文件） 1export CATALINA_OPTS="$CATALINA_OPTS -Djava.library.path=/data/apr/lib" 修改 $TOMCAT_HOME/conf/server.xml 12345&lt;Connector port="8000" protocol="org.apache.coyote.http11.Http11AprProtocol" connectionTimeout="20000" redirectPort="8443"protocal 修改为 org.apache.coyote.http11.Http11AprProtocol，重启 tomcat 测试 启动 Tomcat，若在控制台或日志出现类似如下示例信息则表示 APR 配置成功 1INFO: Loaded APR based Apache Tomcat Native library 1.1.33. 检查是否安装成功如果看到下面的启动日志，表示成功 123456Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["http-apr-8080"]Sep 17, 2017 1:59:19 PM org.apache.coyote.AbstractProtocol startINFO: Starting ProtocolHandler ["ajp-apr-8009"]Sep 17, 2017 1:59:19 PM org.apache.catalina.startup.Catalina startINFO: Server startup in 31002 ms]]></content>
      <categories>
        <category>Tomcat笔记</category>
      </categories>
      <tags>
        <tag>Tomcat_APR_安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不通过inventory文件，指定host运行Ansible]]></title>
    <url>%2F2018%2F06%2F05%2F%E4%B8%8D%E9%80%9A%E8%BF%87inventory%E6%96%87%E4%BB%B6%EF%BC%8C%E6%8C%87%E5%AE%9Ahost%E8%BF%90%E8%A1%8CAnsible%2F</url>
    <content type="text"><![CDATA[如何不通过 inventory 文件，直接指定 host 运行 Ansible？ 使用过 ansible 的都知道，不管是运行 Ad-Hoc 还是 playbook，都需要指定一个 inventory 文件，或者使用默认的 inventory 文件。但是现在有一个主机，它尚未在 inventory 文件中配置，那么我们该如何用 ansible 对其进行操作呢？ 一般我们执行都是这样的 12345ansible 192.168.35.215 -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125; 这时需要在 inventory 文件 /etc/ansible/hosts 中配置 192.168.35.215 信息 12[NgxProxy]192.168.35.215 如果没有在 inventory 文件中配置该主机信息，又想用 ansible 对其进行操作就需要用到逗号 , 字符，使用方法如下 123456# Host and IP addressansible all -i example.com,ansible all -i 93.184.216.119,# Requires 'hosts: all' in your playbookansible-playbook -i example.com, playbook.yml 需要注意的是，需要指定范围为 all 12345ansible all -i 192.168.35.215, -m ping192.168.35.215 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;]]></content>
      <categories>
        <category>Ansible笔记</category>
      </categories>
      <tags>
        <tag>如何不通过 inventory 文件，直接指定 host 运行 Ansible？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客生成一个站点地图]]></title>
    <url>%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[给博客生成一个站点地图 安装 hexo-generator-seo-friendly-sitemap1npm install hexo-generator-seo-friendly-sitemap --save 在站点配置文件 _config.yml 中添加12sitemap: path: sitemap.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客生成一个站点地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next给博客添加feed]]></title>
    <url>%2F2018%2F06%2F04%2FNext%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0feed%2F</url>
    <content type="text"><![CDATA[给博客添加 feed 安装 hexo-generator-feed1npm install hexo-generator-feed --save 配置到站点配置文件 _config.yml12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 最后，在你 next 主题下的 _config.yml 下，添加 RSS 订阅链接即可1rss: /atom.xml]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next给博客添加feed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora快捷键]]></title>
    <url>%2F2018%2F06%2F04%2FTypora%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Typora常用快捷键 功能 快捷键 新建界面窗口 Ctrl + Shift + N 新建文件 Ctrl + N 打开文件 Ctrl + O 序列表 输入-之后输入空格 序列表 输入数字+“.”之后输入空格 务列表 -[空格]空格 文字 标题 Ctrl + 数字 表格 Ctrl + t 成目录 [TOC]按回车 选中一整行 Ctrl + l 选中单词 Ctrl + d 选中相同格式的文字 Ctrl + e 跳转到文章开头 Ctrl + home 跳转到文章结尾 Ctrl + end 搜索 Ctrl + f 替换 Ctrl + h 引用 输入&gt; 后输入空格 代码块 Ctrl + Alt + f 加粗 Ctrl + b 斜体 Ctrl + i 字体 Ctrl + 数字 下划线 Ctrl + u 删除线 Alt + Shift + 5 插入图片 直接拖动到指定位置即可或Ctrl + Shift + i 插入链接 Ctrl + k]]></content>
      <categories>
        <category>Typora笔记</category>
      </categories>
      <tags>
        <tag>Typora快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安全加固心得]]></title>
    <url>%2F2018%2F06%2F04%2FNginx%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Nginx安全加固心得 Nginx 发展多年，自身的安全漏洞比较少，发现软件漏洞，一般利用软件包管理器升级一下就好了。本文侧重讲述的不是 Nginx 自身的安全，而是利用 Nginx 来加固 Web应用，干一些应用防火墙（WAF）干的活。在做安全加固的时候，我们一定要头脑清晰，手里拿着刀，一刀一刀的切，将我们不想要的流量干掉，除去隐患。 屏蔽 IP 假设我们的网站只是一个国内小站，有着公司业务，不是靠广告生存的那种，那么可以用 Geoip 模块封杀掉除中国和美国外的所有IP。这样可以过滤大部分来自国外的恶意扫描或者无用访问。不用担心封杀了网络蜘蛛。主流的网络蜘蛛（百度/谷歌/必应/搜狗）已经包含在了我们的IP范围内了。如果是公网的登录后台，更应该屏蔽彻底一点。 123if ( $geoip_country_code !~ ^(CN|US)$ ) &#123; return 403;&#125; （很多人担心geoip库不够准确，诚然，中国城市级别的IP段会有误差，但是国家级别的IP段一般是没有问题的，并且geoip库可以随时在线更新） 封杀各种 user-agent user-agent 也即浏览器标识，每个正常的web请求都包含用户的浏览器信息，除非经过伪装，恶意扫描工具一般都会在user-agent里留下某些特征字眼，比如 scan，nmap 等。我们可以用正则匹配这些字眼，从而达到过滤的目的，请根据需要调整。 123456if ($http_user_agent ~* "java|python|perl|ruby|curl|bash|echo|uname|base64|decode|md5sum|select|concat|httprequest|httpclient|nmap|scan" ) &#123; return 403;&#125;if ($http_user_agent ~* "" ) &#123; return 403;&#125; 这里分析得不够细致，具体的非法 user-agent 还得慢慢从日志中逐个提取。通过上面两个大招，相信你的日志里很快就会有大量的 403 记录。，我们接着干。如果网站提供公共 api，注意与开发者约定好 UA，防止撞墙 封杀特定的 URL 特定的文件扩展名，比如 .bak 123location ~* \.(bak|save|sh|sql|mdb|svn|git|old)$ &#123; rewrite ^/(.*)$ $host permanent;&#125; 知名程序，比如 phpmyadmin 123location /(admin|phpadmin|status) &#123; deny all; &#125; 封杀特定的 http 方法和行为，比如 123456if ($request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 405;&#125;if ($http_range ~ "\d&#123;9,&#125;") &#123; return 444;&#125; 强制网站使用域名访问，可以逃过IP扫描，比如123if ( $host !~* 'abc.com' ) &#123; return 403;&#125; url 参数过滤敏感字，比如1234567if ($query_string ~* "union.*select.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; if ($query_string ~* "concat.*\(") &#123; rewrite ^/(.*)$ $host permanent;&#125; 强制要求referer123if ($http_referer = "" ) ｛ return 403;｝ 如果不想用403，也可以rewrite一个url，比如一个400页面 123456&lt;html&gt; &lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor="white"&gt; &lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx/1.2.0&lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 小结 可以将上述规则结合起来使用，同时匹配多条规则时才会封杀，下面是一个来自老外的稍微复杂一点的例子： 123456789101112131415set $add 1; location /index.php &#123; limit_except GET POST &#123; deny all; &#125; set $ban ""; if ($http_referer = "" ) &#123;set $ban $ban$add;&#125; if ($request_method = POST ) &#123;set $ban $ban$add;&#125; if ($query_string = "action=login" )&#123;set $ban $ban$add;&#125; if ($ban = 111 ) &#123; access_log /var/log/[133]nginx/ban IP; return 404; &#125; proxy_pass http://127.0.0.1:8000; #here is a patch &#125; 其它方法 封杀IP 定时做日志分析，手动将恶意IP加入 iptables 拒绝名单，推荐使用 ipset 模块。 12yum install -y ipset ipset-serviceipset create badip hash:net maxelem 65535iptables -I INPUT -m set --match-set badip src -p tcp --dport 80 -j DROP/etc/init.d/iptables saveipset add badip 1.1.1.2ipset add badip 2.2.2.0/24/etc/init.d/ipset save ipset 还支持 timeout，类似 redis 的 TTL，timeout 之后会自动删除，比较人性化。比如下面的例子就是 timeout 默认 3600 秒，支持自定义 timeout 12ipset destroy badipipset create badip hash:net maxelem 65535 timeout 3600ipset add badip 1.1.1.1ipset add badip 2.2.2.0/24 timeout 60ipset add badip 3.3.3.0/24 timeout 7200 在日志分析的自动化程度比较高，准确率比较好的情况下，可以考虑通过条件触发 ipset。 限速 适当限制客户端的请求带宽，请求频率，请求连接数，这里不展开论述。根据具体需求，阀值应当稍稍宽泛一点。特别要注意办公室/网吧场景的用户，他们的特点是多人使用同一个网络出口。 目录只读 如果没有上传需求，完全可以把网站根目录弄成只读的，加固安全。做了一点小动作，给网站根目录搞了一个只读的挂载点。这里假设网站根目录为 /var/www/html 1234mkdir -pv /datamkdir -pv /var/www/htmlmount --bind /data /var/www/htmlmount -o remount,ro --bind /data /var/www/html 网站内容实际位于/data，网站内容更新就往/data里更新，目录/var/www/html无法执行任何写操作，否则会报错“Read-only file system”，极大程度上可以防止提权篡改。 overlayfs 这种方法跟上面的方法类似，但是有所区别假设网站根目录/var/www/html有一个目录upload是要求可读写的，其他只读即可，那么仔细看下面的操作 123456mkdir -pv /data/lowermkdir -pv /data/uppermkdir -pv /data/workermv /var/www/html/upload /data/upper/mv /var/www/html/* /data/lower/mount -t overlayfs overlay -o lower=/data/lower,upper=/data/upper,workdir=/data/worker /var/www/html 这样就完美实现了读写分离，底层目录只读，上层目录可写。如果程序被篡改，上层目录 /data/upper 除了 upload 内容之外，还会生成其他文件。overlayfs 因为特殊的机制，建议使用 Linux 内核4.0+，否则比较消耗硬盘的 inode。 定时总结和丰富过滤规则]]></content>
      <categories>
        <category>Nginx笔记</category>
      </categories>
      <tags>
        <tag>Nginx安全加固心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next设置阅读全文]]></title>
    <url>%2F2018%2F06%2F03%2FNext%E8%AE%BE%E7%BD%AE%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87%2F</url>
    <content type="text"><![CDATA[如何设置「阅读全文」？ 在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。NexT 提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在 主题配置文件 中添加： 123auto_excerpt: enable: true # 改成 true length: 150 # 默认展示的高度 默认截取的长度为 150 字符，可以根据需要自行设定建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外，这种方式也可以让 Hexo 中的插件更好的识别。 需要注意的是，点击「阅读全文」之后，文章会自动定位到 所在位置，想要修改成从头阅读需要修改 主题配置文件 _config.yml 文件： 12# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: false]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next设置阅读全文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next开启站内搜索]]></title>
    <url>%2F2018%2F06%2F03%2FNext%E5%BC%80%E5%90%AF%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[Next 如何开启站内搜索？ NexT 主题支持集成 Swiftype、微搜索、Local Search 和 Algolia,Swiftype 和 Algolia 都只有一段时间的试用期，可以采用 Hexo 提供的Local Search，原理是通过 hexo-generator-search 插件在本地生成一个 search.xml 文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 Local Search 由 flashlab 贡献 安装步骤安装 hexo-generator-search 在站点的根目录下执行以下命令 1npm install hexo-generator-search --save 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令1npm install hexo-generator-searchdb --save 启用搜索 编辑 站点配置 文件，新增以下内容到任意位置 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置 文件，启用本地搜索功能 123# Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>Next笔记</category>
      </categories>
      <tags>
        <tag>Next开启站内搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kickstart自动应答文件]]></title>
    <url>%2F2018%2F06%2F03%2FKickstart%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Kickstart 自动应答文件 Cobbler vim /var/lib/cobbler/kickstarts/centos7.5-ks.cfg1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Cobbler for Kickstart Configurator for CentOS 7 by clsninstallurl --url=$treetextlang en_US.UTF-8keyboard uszerombrbootloader --location=mbr --driveorder=sda --append="crashkernel=auto rhgb quiet"#Network information$SNIPPET('network_config')#network --bootproto=dhcp --device=eth0 --onboot=yes --noipv6 --hostname=CentOS7timezone --utc Asia/Shanghaiauthconfig --enableshadow --passalgo=sha512rootpw --iscrypted $default_password_cryptedclearpart --all --initlabel# Disk partitioning informationpart pv.374 --fstype="lvmpv" --ondisk=sda --size=2052part pv.671 --fstype="lvmpv" --ondisk=sda --size=20484part pv.639 --fstype="lvmpv" --ondisk=sda --size=1 --growpart /boot --fstype="xfs" --ondisk=sda --size=500volgroup vgswap --pesize=4096 pv.374volgroup vgroot --pesize=4096 pv.671volgroup vgdata --pesize=4096 pv.639logvol / --fstype="xfs" --size=20480 --name=lvroot --vgname=vgrootlogvol swap --fstype="swap" --size=2048 --name=lvswap --vgname=vgswaplogvol /data --fstype="xfs" --size=1 --grow --name=lvdata --vgname=vgdatafirstboot --disableselinux --disabledfirewall --disabledlogging --level=inforeboot%pre$SNIPPET('log_ks_pre')$SNIPPET('kickstart_start')$SNIPPET('pre_install_network_config')# Enable installation monitoring$SNIPPET('pre_anamon')%end%packages@^minimal@compat-libraries@core@debugging@developmentbash-completionchronydos2unixkexec-toolslrzsznmapsysstattelnettreevimwgetnet-tools%end%postsystemctl disable postfix.service%end]]></content>
      <categories>
        <category>Cobbler笔记</category>
      </categories>
      <tags>
        <tag>Kickstart自动应答文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装]]></title>
    <url>%2F2018%2F06%2F03%2FHexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Hexo 简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 安装 进入 D:\Blog\gmlyo\ 自定义目录，右键鼠标，点击 Git Bash Here，输入 npm 命令即可安装 12345678910111213141516右击 Git Bash Herecd /d/Blog/gmlyo/npm install hexo -g 或 npm install hexo-cli -ghexo init 或 hexo init blog; cd blog/# 第一句是安装 hexo# 第二句是安装 hexo 部署到 git page 的 deployer# 两个都需要安装# Hexo 初始化配置（有点漫长的等待。。。）npm initHexo 初始化完成后，Hexo 将会在指定文件夹中新建所需要的文件hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # 或 hexo generatehexo s # 或 hexo server 可以在打开浏览器访问 http://localhost:4000/ 查看 查看 hexo 版本信息12345678910111213141516171819# 查看 hexo 版本信息hexo -vhexo: 3.7.1hexo-cli: 1.1.0os: Windows_NT 10.0.16299 win32 x64http_parser: 2.8.0node: 10.3.0v8: 6.6.346.32-node.9uv: 1.20.3zlib: 1.2.11ares: 1.14.0modules: 64nghttp2: 1.29.0napi: 3openssl: 1.1.0hicu: 61.1unicode: 10.0cldr: 33.0tz: 2018c 常用 Hexo 命令123456# 生成静态文件，会在当前目录下生成一个新的叫做 public 的文件夹hexo generate (hexo g)# 启动本地 Web 服务，用于博客的预览hexo server (hexo s)# 部署播客到远端（比如github, heroku等平台）hexo deploy (hexo d) 其他常用命令12hexo new "postName" # 新建文章hexo new page "pageName" # 新建页面 常用简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 常用组合12hexo d -g # 生成部署hexo s -g # 生成预览]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 绑定自定义域名]]></title>
    <url>%2F2018%2F06%2F03%2FHexo%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[如何将自己购买的域名连接到 Github Pages？ 12345678在 source 目录下新建 CNAME 文件，在首行添加网站域名如：www.gmlyo.com注意前面没有 https://，http:// 等信息，然后重新重新生成并部署站点hexo clean # 清楚 public 目录，不然有时因为缓存问题，服务器更新不了主题hexo g # hexo generadehexo d # hexo deploy或hexo d -g 设置域名解析1234561、先添加一个CNAME，主机记录写@，后面记录值写上你的 xxx.github.io2、再添加一个CNAME，主机记录写www，后面记录值也是 xxx.github.io这样别人用 www 和不用 www 都能访问你的网站其实 www 的方式，会先解析成 https://xxx.github.io，然后根据 CNAME 再变成 http://www.gmlyo.com，即中间是经过一次转换的。注：除了使用 CNAME 记录也有人使用 A 记录，后面的记录值是写 Github Page 里面的 IP 地址，但有时候 IP 地址会更改，导致最后解析不正确，所以还是推荐用 CNAME 别名记录要好些，不建议用 IP。3、等待10分钟左右，域名生效后刷新浏览器，使用自定义域名访问网站即可 Hexo 部署后，CNAME 会被自动删除，如何解决？123将需要上传至 Github 的文件放在 source 目录下如：CNAME, README.md, favicon.ico, images 目录等将这些都放在 source 目录下，每次上传就不会消失了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 绑定自定义域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 删除文章]]></title>
    <url>%2F2018%2F06%2F03%2FHexo%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Hexo 如何删除文章？ 1234567891011删除文章的过程很简单，先删除本地文件，然后通过生成和部署命令将远程仓库中的文件也一并删除。以最开始默认形成的 hello-world.md 这篇文章为例首先进入 D:\Blog\gmlyo\source\_posts\ 文件夹中找到 hello-world.md 文件，在本地直接执行删除。然后依次执行hexo cleanhexo ghexo d再去主页查看就会发现博客上面已经什么都没有了]]></content>
      <categories>
        <category>Hexo笔记</category>
      </categories>
      <tags>
        <tag>Hexo 删除文章</tag>
      </tags>
  </entry>
</search>
